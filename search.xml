<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CentOS 6.5安装NodeJS]]></title>
    <url>%2F2017%2F09%2F05%2FCentOS-6-5%E5%AE%89%E8%A3%85NodeJS%2F</url>
    <content type="text"><![CDATA[NodeJS 需要 gcc4.8+ 版本（ gcc 4.8 开始全面支持 C 11 和 C++ 11 的新特性）的支持。然而 CentOS6.5 系统默认版本是 4.4.7 ，需要升级 gcc 版本，否则在编译 NodeJS 时，会出现如下警告： 1WARNING: C++ compiler too old, need g++ 4.8 or clang++ 3.4 (CXX=g++) 升级 gcc 版本查看gcc版本: 123456# gcc -v 使用内建 specs。目标：x86_64-redhat-linux配置为：../configure --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-bootstrap --enable-shared --enable-threads=posix --enable-checking=release --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-languages=c,c++,objc,obj-c++,java,fortran,ada --enable-java-awt=gtk --disable-dssi --with-java-home=/usr/lib/jvm/java-1.5.0-gcj-1.5.0.0/jre --enable-libgcj-multifile --enable-java-maintainer-mode --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --disable-libjava-multilib --with-ppl --with-cloog --with-tune=generic --with-arch_32=i686 --build=x86_64-redhat-linux线程模型：posixgcc 版本 4.4.7 20120313 (Red Hat 4.4.7-17) (GCC) CentOS6.5 的系统源提供的 gcc 最新版本是 4.4.7，不能通过 yum 来更新 gcc，这里用编译安装。gcc下载点 有所有的 gcc 版本下载，最新版本是 7.2.0。 安装依赖1234567安装C和C++的静态库# yum install libgcc.i686 glibc-devel.i686安装旧版本的gcc、c++编辑器# yum install gcc gcc-c++ # yum install texinfo-tex flex zip 编译安装下载解压安装包 123# cd /usr/local/src# wget https://ftp.gnu.org/gnu/gcc/gcc-4.8.2/gcc-4.8.2.tar.gz# tar zxvf gcc-4.8.2.tar.gz 官方推荐，用 download_prerequisites 脚本下载编译必备的一些依赖包（如gmp、mpfr、mpc、cloog、isl等依赖库），自动解压当前目录 12# cd gcc-4.8.2# ./contrib/download_prerequisites 编译安装的路径是 /usr/src/gcc-4.8.2/，生成编译文件Makefile 123# mkdir /usr/src/gcc-4.8.2# cd /usr/src/gcc-4.8.2/# /usr/local/src/gcc-4.8.2/configure --enable-checking=release --enable-languages=c,c++ --disable-multilib 执行编译（ ORZ，这过程会很久，大概两小时吧，基本把CPU和内存占光） 1# make 安装 1# make install 替换系统低版本gcc程序系统自带低版本 gcc 4.4.7 的文件位置是 /usr/bin/gcc 和 /usr/bin/lib ，这时需要将这些文件替换为最新安装的 gcc 文件，这里通过建立软链接替换。 123456# mv /usr/bin/c++ /usr/bin/c++.bak# ln -s /usr/local/bin/c++ /usr/bin/c++# mv /usr/bin/g++ /usr/bin/g++.bak# ln -s /usr/local/bin/g++ /usr/bin/g++# mv /usr/bin/gcc /usr/bin/gcc.bak # ln -s /usr/local/bin/gcc /usr/bin/gcc 查看gcc版本： 12345678# gcc -v使用内建 specs。COLLECT_GCC=gccCOLLECT_LTO_WRAPPER=/usr/local/libexec/gcc/x86_64-unknown-linux-gnu/4.8.2/lto-wrapper目标：x86_64-unknown-linux-gnu配置为：/usr/local/src/gcc-4.8.2/configure --enable-checking=release --enable-languages=c,c++ --disable-multilib线程模型：posixgcc 版本 4.8.2 (GCC) 替换系统gcc动态链接库123456789101112131415161718192021# strings /usr/lib64/libstdc++.so.6 | grep GLIBCGLIBCXX_3.4GLIBCXX_3.4.1GLIBCXX_3.4.2GLIBCXX_3.4.3GLIBCXX_3.4.4GLIBCXX_3.4.5GLIBCXX_3.4.6GLIBCXX_3.4.7GLIBCXX_3.4.8GLIBCXX_3.4.9GLIBCXX_3.4.10GLIBCXX_3.4.11GLIBCXX_3.4.12GLIBCXX_3.4.13GLIBC_2.2.5GLIBC_2.3GLIBC_2.4GLIBC_2.3.2GLIBCXX_FORCE_NEWGLIBCXX_DEBUG_MESSAGE_LENGTH 可看出，gcc的动态链接库还是处于旧版本，说明生成的动态库没有替换旧版本 gcc 的动态库。 新版的gcc动态链接库位置是 /usr/local/lib64/libstdc++.so.6.0.18，替换gcc的动态链接库： 1234# cp /usr/local/lib64/libstdc++.so.6.0.18 /usr/lib64 # cd /usr/lib64/# rm -f ./libstdc++.so.6# ln -s libstdc++.so.6.0.18 libstdc++.so.6 查看gcc动态链接库： 123456789101112131415161718192021222324252627# strings /usr/lib64/libstdc++.so.6 | grep GLIBCGLIBCXX_3.4GLIBCXX_3.4.1GLIBCXX_3.4.2GLIBCXX_3.4.3GLIBCXX_3.4.4GLIBCXX_3.4.5GLIBCXX_3.4.6GLIBCXX_3.4.7GLIBCXX_3.4.8GLIBCXX_3.4.9GLIBCXX_3.4.10GLIBCXX_3.4.11GLIBCXX_3.4.12GLIBCXX_3.4.13GLIBCXX_3.4.14GLIBCXX_3.4.15GLIBCXX_3.4.16GLIBCXX_3.4.17GLIBCXX_3.4.18GLIBCXX_3.4.19GLIBC_2.3GLIBC_2.2.5GLIBC_2.14GLIBC_2.3.2GLIBCXX_FORCE_NEWGLIBCXX_DEBUG_MESSAGE_LENGTH 结果表明，gcc动态链接库升级成功。 编译安装 NodeJS下载并解压从 NodeJS官网 下载想要的版本，这里安装的版本是 v7.10.0。 123# cd /usr/local/src/# wget https://nodejs.org/dist/v7.10.0/node-v7.10.0.tar.gz# tar zxvf node-v7.10.0.tar.gz 编译安装安装路径 /usr/local/node ： 1234# cd node-v7.10.0# mkdir /usr/local/node# ./configure --prefix=/usr/local/node# make &amp;&amp; make install 配置环境变量配置系统的环境变量，打开 /etc/profile ，加入： 123NODE_HOME=/usr/local/nodePATH=$NODE_HOME/bin:$PATHexport NODE_HOME PATH 手动加载生效 1# source /etc/profile 查看版本号查看NodeJS的版本号，检查是否安装成功： 12# node -vv7.10.0 参考资料：CentOS6.5升级gcc-4.8]]></content>
      <categories>
        <category>技术杂项</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git仓库迁移]]></title>
    <url>%2F2017%2F09%2F04%2FGit%E4%BB%93%E5%BA%93%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[在运维工作中，常遇到Git仓库迁移的问题，如合并多个Git服务器，更换Git托管商等。这篇文章主要记录Git仓库迁移的几种方案。 单个库导入迁移步骤： 使用 --mirror 参数，从当前Git服务器 clone 仓库代码 在目标Git服务器新建一个同名的空仓库 使用 --mirror 参数，将代码 push 到目标Git服务器 12345678使用mirror参数，克隆裸仓库# git clone --mirror git@git.XXX.com/test/test_api.git进入仓库目录# cd test_api.git使用mirror参数，再次push仓库代码到另外一个Git服务器# git push --no-verify --mirror git@git.NNN.com/dev/test_api.git 有三种clone的方法 123# git clone &lt;repository&gt; &lt;directory&gt;# git clone --bare &lt;repository&gt; &lt;directory.git&gt;# git clone --mirror &lt;repository&gt; &lt;directory.git&gt; 方法1，指向的版本库创建一个克隆到目录。目录相当于克隆版本库的工作区，文件都会检出，版本库位于工作区下的 .git 目录中。 方法2和方法3创建的克隆版本库都不含工作区，直接就是版本库的内容，这样的版本库称为裸版本库。一般约定俗成裸版本库的目录名以.git为后缀。 方法3区别于方法2之处在于，方法3克隆出来的裸版本对上游版本库进行了注册，这样可以在裸版本库中使用 git fetch 命令和上游版本库进行持续同步。 这种方法的缺点是，单个仓库迁移，麻烦而且效率很慢。 GitLab同版本间进行数据迁移Gitlab数据迁移需在同版本之间进行。因为不同版本的Gitlab之间，数据库的库表结构与程序的实现方式是有差异的。若需从服务器A 把Gitlab的数据迁移至 服务器B，则 服务器B 需部署与服务器A 同样版本的Gitlab才可。 备份这里的GitLab是 omnibus 安装包安装的，默认备份目录是 /var/opt/gitlab/backups。 备份命令： 1gitlab-rake gitlab:backup:create 该命令会在备份目录（默认：/var/opt/gitlab/backups/）下创建一个tar压缩包xxxxxxxx_gitlab_backup.tar，其中开头的xxxxxx是备份创建的时间戳，这个压缩包包括GitLab整个的完整部分。 数据迁移从源GitLab服务器的备份目录中，拷贝备份文件到目标GitLab服务器的备份目录。 1/var/opt/gitlab/backups/1499244722_2017_07_05_9.2.6_gitlab_backup.tar 停止 unicorn 和 sidekiq ，保证数据库没有新的连接，不会有写数据情况。 123456789停止相关数据连接服务# gitlab-ctl stop unicorn# gitlab-ctl stop sidekiq备份恢复，完成数据迁移# gitlab-rake gitlab:import:restore BACKUP=1499242399_2017_07_05_9.2.6重启GitLab服务# gitlab-ctl start]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 6.x 上搭建docker]]></title>
    <url>%2F2017%2F08%2F31%2FCentOS-6-x-%E4%B8%8A%E6%90%AD%E5%BB%BAdocker%2F</url>
    <content type="text"><![CDATA[Docker是一个能够把开发应用程序自动部署到容器的开源引擎。它由Docker公司的团队编写，基于Apache 2.0开源协议授权。它提供了一个简单、轻量的建模方式，使开发生命周期更高效快速，鼓励了面向服务的架构设计。 前提条件内核Docker 运行环境对内核要求比较高，一般建议直接在Ubuntu这样的平台上运行。但作为一个容器标准，Docker也支持其他如 CentOS，Mac OS X，Windows等其他平台。目前Docker支持以下Red Hat和Red Hat系发行版：(不支持32位) (RHEL|CentOS) 6.5及以上版本（64位）Fedora 19及以上版本（64位） 在运行于这些系统时，需要 内核版本 &gt;= 3.8 ，因为这些内核包含了运行Docker的一些特定修改。查看内核版本： 12# uname -r2.6.32-431.el6.x86_64 注意：3.8 &gt; 内核版本 &gt;= 2.6.32-431 这些内核版本虽然也能支持Docker运行，但是支持得不好，仍会在运行时出现很多bug。推荐 内核版本 &gt;= 3.8 。 检查Device MapperDocker默认使用AUFS作为存储驱动，但是AUFS并没有被包括在Linux的主线内核中。CentOS中可以使用Device Mapper作为存储驱动，这是在2.6.9内核版本引入的新功能。需要先确认是否启用该功能: 12# ls -l /sys/class/misc/device-mapperlrwxrwxrwx 1 root root 0 8月 31 17:33 /sys/class/misc/device-mapper -&gt; ../../devices/virtual/misc/device-mapper 如果没有检测到Device Mapper，需要安装其软件包： 1# yum install device-mapper -y 然后重新加载 dm_mod 内核模块： 1# modprobe dm_mod 升级内核版本查看当前内核版本1234# cat /etc/redhat-releaseCentOS release 6.5 (Final)# uname -r2.6.32-431.el6.x86_64 CentOS 6.5 系统默认的内核版本是 2.6.32-431.el6.x86_64，不符合Docker的安装条件，需要升级内核版本。 升级内核版本至3.10.0在yum的 ELRepo 源中,有 mainline（3.13.x）、long-term（3.10.x）这2个内核版本，考虑到long-term更稳定，会长期更新，所以选择这个版本。 导入 Public key 1# rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org 安装ELRepo源 1# rpm -ivh http://www.elrepo.org/elrepo-release-6-8.el6.elrepo.noarch.rpm 安装kernel-lt 或 kernel-ml（任选一个） 12345# kernel-lt，内核版本：3.10.x# yum --enablerepo=elrepo-kernel install kernel-lt -y# 或者kernel-ml，内核版本：3.13.x# yum --enablerepo=elrepo-kernel install kernel-ml -y 编辑 grub.conf 文件，修改 Grub 引导顺序 1234567891011121314# cat /etc/grub.confdevice (hd0) HD(1,800,64000,ab0fd74d-ecf9-42ff-8c69-0fa5d3af4fd2)default=1timeout=5splashimage=(hd0,1)/grub/splash.xpm.gzhiddenmenutitle CentOS (3.10.107-1.el6.elrepo.x86_64) root (hd0,1) kernel /vmlinuz-3.10.107-1.el6.elrepo.x86_64 ro root=/dev/mapper/vg_localhost-lv_root rd_NO_LUKS rd_NO_MD rd_LVM_LV=vg_localhost/lv_swap crashkernel=128M LANG=zh_CN.UTF-8 rd_LVM_LV=vg_localhost/lv_root KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet initrd /initramfs-3.10.107-1.el6.elrepo.x86_64.imgtitle CentOS (2.6.32-431.el6.x86_64) root (hd0,1) kernel /vmlinuz-2.6.32-431.el6.x86_64 ro root=/dev/mapper/vg_localhost-lv_root rd_NO_LUKS rd_NO_MD rd_LVM_LV=vg_localhost/lv_swap crashkernel=128M LANG=zh_CN.UTF-8 rd_LVM_LV=vg_localhost/lv_root KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet initrd /initramfs-2.6.32-431.el6.x86_64.img 确认刚安装的内核在哪个位置，然后设置default值(从0开始)。一般新安装的内核会在第一个位置，所以设置 default=0。 重启服务器，查看内核版本 1234# reboot# uname -r3.10.107-1.el6.elrepo.x86_64 安装Docker对于CentOS 6.5，Docker可以在 EPEL 源中找到，安装 EPEL 源 1# rpm -Uvh http://www.gtlib.gatech.edu/pub/fedora-epel/6/i386/epel-release-6-8.noarch.rpm 删除CentOS 6.5默认自带的Docker 1# yum remove docker -y 安装docker-io的RPM包 1# yum install docker-io -y 查看Docker版本 1234567891011# docker versionClient version: 1.7.1Client API version: 1.19Go version (client): go1.4.2Git commit (client): 786b29d/1.7.1OS/Arch (client): linux/amd64Server version: 1.7.1Server API version: 1.19Go version (server): go1.4.2Git commit (server): 786b29d/1.7.1OS/Arch (server): linux/amd64 启动Docker服务 1# service docker start]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 6.x 上安装Go]]></title>
    <url>%2F2017%2F08%2F30%2FCentOS-6-x-%E4%B8%8A%E5%AE%89%E8%A3%85Go%2F</url>
    <content type="text"><![CDATA[Go 语言是由Google开发的一种静态强类型、编译型、并发型并具有垃圾回收功能的开源编程语言。Go语言是基于Inferno操作系统所开发的。Go语言于2009年11月正式宣布推出，成为开放源代码项目，并在Linux及Mac OS X平台上进行了实现，后来追加了Windows系统下的实现。 Go语言官网目前最新版本：Go 1.9 对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。 安装Go获取Go语言的二进制归档文件： 12# cd /usr/local/src# wget https://storage.googleapis.com/golang/go1.7.3.linux-amd64.tar.gz 解压安装： 1# tar zxvf go1.7.3.linux-amd64.tar.gz -C /usr/local/ 配置Go环境现在，你需要设置转到语言环境变量为您的项目。通常你需要设置3个环境变量 GOROOT，GOPATH 和 PATH 。 GOROOT 是软件包安装在系统上的位置。GOPATH 是你的工作目录。 例如我的项目目录是 ~/Projects/Proj1 ，则 GOPATH=$HOME/Projects/Proj1 在 /etc/bashrc 中加入： 123GOROOT=/usr/local/goGOPATH=$HOME/Projects/Proj1 # 根据实际项目路径更改PATH=$GOPATH/bin:$GOROOT/bin:$PATH 手动加载生效： 1# source /etc/bashrc 验证安装是否成功检查Go版本 12# go versiongo version go1.7.3 linux/amd64 验证所有环境变量是否配置正确 123456789101112131415# go envGOARCH=&quot;amd64&quot;GOBIN=&quot;&quot;GOEXE=&quot;&quot;GOHOSTARCH=&quot;amd64&quot;GOHOSTOS=&quot;linux&quot;GOOS=&quot;linux&quot;GOPATH=&quot;/root/Projects/Proj1&quot;GORACE=&quot;&quot;GOROOT=&quot;/usr/local/go&quot;GOTOOLDIR=&quot;/usr/local/go/pkg/tool/linux_amd64&quot;CC=&quot;gcc&quot;GOGCCFLAGS=&quot;-fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build311841584=/tmp/go-build&quot;CXX=&quot;g++&quot;CGO_ENABLED=&quot;1&quot;]]></content>
      <categories>
        <category>技术杂项</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 6.x 安装JDK8]]></title>
    <url>%2F2017%2F08%2F30%2FCentOS-6-%E5%AE%89%E8%A3%85JDK8%2F</url>
    <content type="text"><![CDATA[CentOS 6.x 系统默认安装了JDK7，可根据需要决定是否卸载JDK7。 123# rpm -qa |grep jdkjava-1.7.0-openjdk-devel-1.7.0.121-2.6.8.1.el6_8.x86_64java-1.7.0-openjdk-1.7.0.121-2.6.8.1.el6_8.x86_64 下载解压 JDK可以从其官方下载页面下载最新的Java SE Development Kit 8版本，或使用以下命令从shell下载。 对于64位系统： 1234# mkdir /usr/local/java# cd /usr/local/java# wget --no-cookies --no-check-certificate --header &quot;Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie&quot; &quot;http://download.oracle.com/otn-pub/java/jdk/8u141-b15/336fa29ff2bb4ef291e347e091f7f4a7/jdk-8u141-linux-x64.tar.gz&quot;# tar zxvf jdk-8u141-linux-x64.tar.gz 对于32位系统： 1234# mkdir /usr/local/java# cd /usr/local/java# wget --no-cookies --no-check-certificate --header &quot;Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie&quot; &quot;http://download.oracle.com/otn-pub/java/jdk/8u141-b15/336fa29ff2bb4ef291e347e091f7f4a7/jdk-8u141-linux-i586.tar.gz&quot;# tar zxvf jdk-8u141-linux-i586.tar.gz 配置环境变量绝大多数的Java应用，都是基于其环境变量来工作的，必须设置好。在系统环境变量文件 /etc/profile 中添加如下代码： 123456JAVA_HOME=/usr/local/java/jdk1.8.0_141JRE_HOME=/usr/local/java/jdk1.8.0_141/jreCLASSPATH=$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libPATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binexport JAVA_HOME JRE_HOME CLASSPATH PATH 手动加载生效： 1# source /etc/profile 验证JDK版本检查JDK版本： 1234# java -versionjava version &quot;1.8.0_141&quot;Java(TM) SE Runtime Environment (build 1.8.0_141-b15)Java HotSpot(TM) 64-Bit Server VM (build 25.141-b15, mixed mode)]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用docker命令清单]]></title>
    <url>%2F2017%2F08%2F29%2F%E5%B8%B8%E7%94%A8docker%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95%2F</url>
    <content type="text"><![CDATA[连接到正在运行的容器上在使用 -d 参数时，容器启动后会进入后台。有时候，我们需要进入容器进行操作，可以用docker自带的命令 docker attach。要 attach 上去的容器必须正在运行，可以同时连接上同一个容器来共享屏幕（与 screen 命令类似） 注意：直接用 docker attach $CONTAINER_ID 命令连接上容器， CTRL-C 退出后，容器会停止运行。这不符合我们的需求，在 attach 时可以带上 --sig-proxy=false 来确保 CTRL-D 或 CTRL-C 不会关闭容器。 1# docker attach --sig-proxy=false [$CONTAINER_ID | NAMES] 若容器当前正在前台运行进程，如输出nginx的访问日志，而又想连上容器另外执行命令时，不能用 docker attach 命令，可以使用 docker exec 在容器内启动一个交互shell。 在容器内部运行进程在 Docker 1.3 之后，docker exec 命令被引入，该命令可以在容器内部额外启动新进程。可在容器内运行的进程有两种： 后台任务：在容器内运行且没有交互需求交互式任务：保持在前台运行 在容器中运行后台任务1# docker exec -d test touch /tmp/test.txt -d 表明需要运行一个后台进程，test 是容器名，touch /tmp/test.txt 是要要执行的命令。上述例子中的命令会在 test 容器内创建一个空文件 /tmp/test.txt。通过 docker exec 后台命令，可以在正在运行的容器中进行维护、监控和管理任务。 在容器内运行交互命令1# docker exec -t -i test /bin/bash -t 和 -i 参数为我们执行的进程创建了 TTY 并且捕捉 STDIN 。test 是容器名，/bin/bash 是要执行的命令。上述命令会在 test 容器中创建一个新的 bash 会话，有了这个会话，我们就可以在该容器中运行其他命令，而且用 exit 命令退出该会话后，容器不会停止。]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python图像处理库:pillow]]></title>
    <url>%2F2017%2F08%2F15%2FPython%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%BA%93-pillow%2F</url>
    <content type="text"><![CDATA[PIL(Python Imaging Library) 是pyhton常用的图像处理库，官方网站，最新版本是 1.1.7 ，于2009年9月发布，支持Python 1.5.2 - 2.7。PIL项目似乎已经停止开发了，PIL仓库 最后一次提交是2011年。python 3.x 版本是无法使用原PIL库的，得使用Pillow库。 Pillow 库则是 PIL 的一个友好Fork，维护和开发活跃，Pillow 兼容 PIL 的绝大多数语法，推荐使用。Pillow 库提供了广泛的文件格式支持，强大的图像处理能力，主要包括图像储存、图像显示、格式转换以及基本的图像处理操作等。 Pillow项目仓库Pillow官网Pillow文档 安装和介绍先安装一些依赖包，对于Mac OS系统，可以用 HomeBrew 来安装。这里使用的是python3.x，所以用 pip3 来安装pillow。 12$ brew install libtiff libjpeg libpng webp little-cms2 freetype$ sudo pip3 install pillow pillow库有几个重要的类： Image ImageDraw ImageFont Image模块PIL 最重要的类是 Image，而Image类定义在同名的 Image 模块里。使用PIL的功能，一般都是从新建一个 Image 类的实例开始。你可以通过多种方法创建 Image 类的实例，如用 Image 模块的 open() 函数打开已有的图像，也可以处理其他实例，或者从零开始构建一个实例。 12&gt;&gt;&gt; from PIL import Image&gt;&gt;&gt; im = Image.open('avatar.jpeg') 上面代码引入了 Image 模块，利用模块的 open() 函数，打开了当前目录中的 avatar.jpeg 图像，构建了 im 实例。如果打开失败，会抛出 IOError 异常。 Image实例有5个属性，如下： format : 返回图像的格式(PNG,JPG,None等)。如果图像不是从文件读取的，它的值就是None mode : 返回图像的模式。常用模式有 L (luminance) 表示灰度图像, RGB 表示真彩色图像, and CMYK 表示出版图像。官方说明-图像模式完整列表 size : 是一个二元tuple，包含width和height（宽度和高度，单位都是px） palette : 仅当 mode 为 P 时有效，返回 ImagePalette 实例 info : 以字典的形式返回实例的信息 12345678910&gt;&gt;&gt; print(im.format)JPEG&gt;&gt;&gt; print(im.mode)RGB&gt;&gt;&gt; print(im.size)(640, 640)&gt;&gt;&gt; print(im.palette)None&gt;&gt;&gt; print(im.info)&#123;'jfif': 257, 'jfif_unit': 0, 'exif': 'Exif\x00\x00MM\x00*\x00\x00\x00\x08\x00\x02\x01\x12\x00\x03\x00\x00\x00\x01\x00\x01\x00\x00\x87i\x00\x04\x00\x00\x00\x01\x00\x00\x00&amp;\x00\x00\x00\x00\x00\x03\xa0\x01\x00\x03\x00\x00\x00\x01\x00\x01\x00\x00\xa0\x02\x00\x04\x00\x00\x00\x01\x00\x00\x02\x80\xa0\x03\x00\x04\x00\x00\x00\x01\x00\x00\x02\x80\x00\x00\x00\x00', 'progressive': 1, 'jfif_version': (1, 1), 'jfif_density': (72, 72), 'progression': 1&#125; 可以使用 show() 方法来查看实例（PIL 会将实例暂存为一个临时文件，然后打开它） 1&gt;&gt;&gt; im.show() 转换图像格式PIL 模块支持大量的图像格式。使用 open() 函数从磁盘中读取图像文件，不需要指定图像格式，它会根据文件内容自动确定图像格式。可使用 save(filename,format) 函数以特定的图像格式保存图像。若不指定图像格式，save() 方法会根据文件扩展名来选择相应的图像格式。 例子：转换图像格式的脚本（转为png格式） 123456789101112from PIL import Imageimport osimport sys for infile in sys.argv[1:]: f,e = os.path.splitext(infile) # f 变量是除扩展名以外的文件名，e 变量是扩展名 outfile = f +".png" # 拼凑输出文件名 if infile != outfile: # 保存的图像格式跟原图像格式不一样 try: Image.open(infile).save(outfile) # 转换图像格式 except IOError: print("Cannot convert", infile) # 图像无法打开，则处理异常 创建缩略图缩略图是网络开发或者图像软件预览常用的一种基本技术，使用Python的Pillow图像库可以很方便地建立缩略图。Image 类的 thumbnail() 方法可以用来制作缩略图。它接受一个二元数组作为缩略图的尺寸，然后将实例缩小到指定尺寸。 例子：生成JPEG缩略图，大小是原图像的四分之一 12345678910111213import os, sysfrom PIL import Imagefor infile in sys.argv[1:]: outfile = os.path.splitext(infile)[0] + ".thumbnail" # 缩略图文件名+后缀 if infile != outfile: try: im = Image.open(infile) # 打开图像 x, y = im.size # 获取原图像的大小（width、height） im.thumbnail((x//2, y//2)) # 缩略图大小 im.save(outfile, "JPEG") # 保存为 JPEG 格式 except IOError: print "cannot create thumbnail for", infile 注意：Pillow库不会直接解码或者加载图像栅格数据。当你打开一个文件，只会读取文件头信息用来确定格式，颜色模式，大小等等，文件的剩余部分不会主动处理。这意味着打开一个图像文件的操作十分快速，跟图像大小和压缩方式无关。 图像的剪切、粘贴与合并操作Image 类包含很多操作图像区域的方法。 裁剪子矩形crop() 方法可以从图像中提取一个子矩形选区，如下： 123im = Image.open("avatar.jpeg")box = (100,100,300,300)region = im.crop(box) 矩形选区区域由一个4元元组决定，元组信息表示 (左,上,右,下) 的坐标。Pillow库以图像左上角为坐标原点 (0,0)，单位是 px 。因此，上述代码是复制了一个 200x200 pixels 的矩形选区。 处理子图，粘贴回原图12region = region.transpose(Image.ROTATE_180) # 旋转180°im.paste(region, box) transpose() 方法可以将图片左右颠倒、上下颠倒、旋转 90°、旋转 180° 或旋转 270°。paste() 方法则可以将一个 Image 实例粘贴到另一个 Image 实例上。 注意：当你粘贴矩形选区的时候必须保证尺寸一致。此外，矩形选区不能在图像外。然而你不必保证矩形选区和原图的颜色模式一致，如果不一致，目标图像会在保存的时候自动进行转换。 例子（扩展实例）：翻转图像 123456789101112131415161718192021222324from PIL import Imagedef roll(image, delta): "Roll an image sideways" xsize, ysize = image.size delta = delta % xsize # 翻卷多少像素 if delta == 0: return image # 不翻卷图形 part1 = image.crop((0, 0, delta, ysize)) # 左边矩形选区 part2 = image.crop((delta, 0, xsize, ysize)) # 右边矩形选区 part1.load() part2.load() image.paste(part2, (0, 0, xsize-delta, ysize)) # 原右边图形贴到左边 image.paste(part1, (xsize-delta, 0, xsize, ysize)) # 原左边图形贴到右边 return imageim = Image.open('avatar.jpeg')print(im.size) # (356, 362)roll(im,100).save('avatar_roll.jpeg','JPEG') 要注意的是，当你使用 crop() 方法来修改图像文件的时候, load() 方法会首先被调用。这是由于修改是一个惰性操作。如果 load() 未被调用，那么在 paste 使用前都不会执行修改这个操作。这暗示着 part1 会在首次修改 image 的时候被修改。 分离和合并颜色通道对于多通道图像，有时候处理时希望能够分别对每个通道处理，处理完成后重新合成多通道，如下： 12r,g,b = im.split()im = Image.merge('RGB',(r,g,b)) 对于 split() 函数，如果是单通道的，则返回其本身。否则，返回各个通道。 几何变换Image 类包含了 resize() 和 rotate 方法来变换图像。前者需要传入一个表示新大小的元组，后者需要传入旋转的角度。 简单的几何变换12out = im.resize((128, 128))out = im.rotate(45) # 顺时针角度表示 要想以90°旋转图像，可以使用 rotate 方法，也可以使用 transpose() 方法，后者能水平或垂直翻转图像。 旋转图像12345out = im.transpose(Image.FLIP_LEFT_RIGHT) # 左右颠倒out = im.transpose(Image.FLIP_TOP_BOTTOM) # 上下颠倒out = im.transpose(Image.ROTATE_90) # 旋转90°out = im.transpose(Image.ROTATE_180) # 旋转180°out = im.transpose(Image.ROTATE_270) # 旋转270° 更通用的图像变换方法可以使用 transform() ImageDraw模块ImageDraw 模块提供了 Draw 类，它能在 Image 实例上进行简单的2D绘画。你可以使用这个模块来创建新图像或者修饰现有图像。 有关PIL的更高级绘图库，可以参考 aggdraw模块 创建 Draw 类的实例要在 Image 实例上绘制新的图样，首先要创建一个 Draw 类的实例。 123from PIL import Image,ImageDrawim = Image.open('avatar.jpeg')drawAvatar = ImageDraw.Draw(im) 基本绘画操作这里粗略介绍下 Draw 类中的基本绘画操作函数(英文都是函数名)： 弦/弧/扇形: chord / arc / pieslice 椭圆: ellipse 线段/多段线: line 点: point 多边形: polygon 矩形: rectangle 文字: text 文字大小: textsize 详细的使用说明，请看官方文档：Draw类的各函数使用说明 画直线为熟悉 Draw 类的函数的使用，下面以画几条线为例来说明。 Draw 类提供了 line(xy,options) 函数绘制直线。其中 xy 表示坐标列表，它可以是任何包含2元组[(x,y),…]或者数字[x,y,…]的序列对象，至少包含两个坐标： [(x1, y1), (x2, y2), …] ：包含若干个元组的列表 [x1, y1, x2, y2, …] ：按照顺序包含坐标信息的列表 [x1, y1, (x2, y2), …] ：以上两种情况的混合 ((x1, y1), (x2, y2), …) ：包含若干个元组的元组 (x1, y1, x2, y2, …) ：按照顺序包含坐标信息的元组 (x1, y1, (x2, y2), …) ：以上两种情况的混合 options 可用的选项： fill = (R,G,B) ：指定线条颜色 width = integer ：指定线条宽度，单位是px 1234567891011121314from PIL import Image,ImageDrawim = Image.open('avatar.jpeg')drawAvatar = ImageDraw.Draw(im)xSize,ySize = im.size# 三等分位置drawAvatar.line([0, 0.33 * ySize, xSize, 0.33 * ySize],\ fill = (255, 100, 0), width = 3)# 左下角到中心点，右下角到中心点drawAvatar.line([(0, ySize), (0.5 * xSize, 0.5 * ySize), (xSize, ySize)],\ fill = (255, 0, 0), width = 3)im.save('avatar_line.jpeg') 这里边，我们画了一条平行线和两条短线组成的折线（虽然看着有点像喷鼻血 ORZ ）。 画弧线Draw 类也提供了 arc(xy, start, end, options) 函数来绘制弧线。 xy 是个长度为4的列表，用来表示一个 bounding box(边界区域)。如[x0, y0, x1, y1]，分别表示 弧线最左侧距离左边、弧线最顶点距离上边、弧线最右侧距离左边、弧线最低点距离上边的距离。start 和 end 则是弧的起止角度，单位是 °。其中水平向右的方向为 0°，竖直向下的方向为 90°，水平向左的方向为 180°，竖直向上的方向为 270°。options 中可用选项： fill = (R, G, B) ：指定线条颜色 1234567from PIL import Image,ImageDrawim = Image.open('avatar.jpeg')drawAvatar = ImageDraw.Draw(im)drawAvatar.arc([10,20,100,300],0,270,fill=(255,0,0))im.save('avatar_arc.jpeg') arc 方法将在内切于 bounding box(边界区域) 的椭圆中，按照给定的起止角度切下一段弧，并绘制于 Image 实例之上。 在图片上写字Draw 类提供了 text(xy, text, options) 函数，可以在 Image 实例上写字。 xy 指定的是文本左上角的顶点，而不是文本中心。options 中可用选项： fill = (R, G, B) ：指定线条颜色 font = ImageFont instance ：指定字体，接受一个 ImageFont 的实例 12345678910from PIL import Image,ImageDrawim = Image.open('avatar.jpeg')drawAvatar = ImageDraw.Draw(im)xSize,ySize = im.sizedrawAvatar.text([0.95 * xSize,0.05 * ySize], "6", fill = (255,0,0))im.save('avatar_text.jpeg') 这里不指定 font ，表示使用 ImageDraw 的默认字体。可以发现，默认字体太小了，为了调整字体，需要借助 ImageFont 模块。 ImageFont模块PIL 可以使用 bitmap 字体或者 OpenType/TrueType 字体。Bitmap 字体被存储在 PIL 自己的格式中，一般包含两个文件： 后缀是 .pil ，包含字体的矩阵； 后缀是 .pbm，包含栅格数据。 ImageFont 模块中，可以使用 load() 函数加载一个 bitmap 字体，使用 truetype(fontfile, fontsize) 函数加载一个 OpenType/TrueType 字体(注意，这个函数需要额外安装_imageingft模块)。 OpenType 标准定义了 OpenType 文件名称的后缀名： 包含TureType字体的OpenType文件后缀名为 .ttf 包含PostScript字体的文件后缀名为 .OTF 包含一系列TrueType字体的字体包文件，那么后缀名为 .TTC 例子：将你的 QQ 头像（或者微博头像）右上角加上红色的数字，类似于微信未读信息数量那种提示效果。 12345678910111213141516171819202122232425#!/usr/bin/env python# _*_ coding:utf-8 _*_from PIL import Image,ImageDraw,ImageFont# 需要传入参数：字符串，字体颜色def drawText(text,color,imageName,new_imageName): avatar = Image.open(imageName) drawAvatar = ImageDraw.Draw(avatar) xSize,ySize = avatar.size # 指定字体大小 fontSize = min(xSize,ySize) // 12 # 引用本地TrueType格式的字体文件，创建一个ImageFont实例 myFont = ImageFont.truetype('/Library/Fonts/Arial.ttf',fontSize) # 在图片上写字，y轴位置根据字体大小变化，fill参数指定字的颜色，font参数必须是ImageFont实例的值 drawAvatar.text([0.9 * xSize, 0.1 * ySize - fontSize], text,fill = color, font = myFont) avatar.save(new_imageName)if __name__ == '__main__': color = (255,0,0) drawText('9',color,'avatar.jpeg','avatar_new.jpeg') ImageFilter模块ImageFilter 是 PIL 的滤镜模块，提供了滤波器的相关定义，这些滤波器主要用于 Image 类的 filter() 方法。 滤镜名称和含义说明： ImageFilter.BLUR ：模糊滤镜 ImageFilter.CONTOUR ：轮廓 ImageFilter.EDGE_ENHANCE ：边界加强 ImageFilter.EDGE_ENHANCE_MORE ：边界加强(阀值更大) ImageFilter.EMBOSS ：浮雕滤镜 ImageFilter.FIND_EDGES ：边界滤镜 ImageFilter.SMOOTH ：平滑滤镜 ImageFilter.SMOOTH_MORE ：平滑滤镜(阀值更大) ImageFilter.SHARPEN ：锐化滤镜 例子：生成字母验证码图片 123456789101112131415161718192021222324252627282930313233343536373839404142#!/usr/bin/env python# _*_ coding:utf-8 _*_from PIL import Image, ImageDraw, ImageFont, ImageFilterimport random# 随机字母（大写）:def rndChar(): return chr(random.randint(65, 90))# 随机颜色1:def rndColor(): return (random.randint(64, 255), random.randint(64, 255), random.randint(64, 255))# 随机颜色2:def rndColor2(): return (random.randint(32, 127), random.randint(32, 127), random.randint(32, 127))# 图片大小：240 x 60width = 60 * 4height = 60# 创建Image对象，背景为白色image = Image.new(&apos;RGB&apos;, (width, height), (255, 255, 255))# 创建Draw对象draw = ImageDraw.Draw(image)# 创建Font对象，字体为“Arial.ttf”font = ImageFont.truetype(&apos;Arial.ttf&apos;, 36)# 用随机颜色填充每个像素for x in range(width): for y in range(height): draw.point((x, y), fill=rndColor()) # 输出4个字母，字母颜色随机for t in range(4): draw.text((60 * t + 10, 10), rndChar(), font=font, fill=rndColor2()) # 对图像模糊image = image.filter(ImageFilter.BLUR)image.save(&apos;code.jpg&apos;, &apos;jpeg&apos;) 用随机颜色填充图像的每个像素，再画上字母(颜色随机)，最后对图像进行模糊。 强大图像处理库介绍Python还有个更强大的第三方图像处理库：OpenCV OpenCV 全称: Open Source Computer Vision Library，是一个开源的跨平台计算机视觉库，GitHub地址。OpecCV 主要用C/C++语言编写，也提供了Python、Java等语言的接口。 网上有几个写得挺不错的教程：OpenCV-Python中文教程Python-OpenCV 图像与视频处理给深度学习入门者的Python快速教程 - 番外篇之Python-OpenCV 全文参考文档PIL 简明教程 - 基本用法Pillow官方文档Python图像处理库Pillow入门PIL 简明教程 - 在现有的图片上涂涂改改]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python时间模块]]></title>
    <url>%2F2017%2F08%2F09%2Fpython%E6%97%B6%E9%97%B4%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[python关于时间和日期的处理模块，常见的有以下几个： 内置模块：time、datetime、calendar第三方模块：pytz time模块基于C语言的库函数(library functions)，提供的接口与C标准库 time.h 基本一致。datetime模块是基于time模块扩展的，提供的接口则更直观、更容易调用。datetime模块有datetime.date(日期)、datetime.time(时间)、datetime.datetime(日期时间)三个类 time模块时间戳、元组、字符串之间相互转换在time模块中，时间日期有三种表现形式： 时间戳：一般指Unix时间戳，从 1970/1/1 0:0:0 到现在的秒数 元组形式(struct_time)：本地时间、UTC时间 格式化字符串形式 三种表现形式： 123456789101112131415&gt;&gt;&gt; import time# 时间戳&gt;&gt;&gt; time.time()1502333067.252786# 元组形式，分别为本地时间和UTC时间&gt;&gt;&gt; time.localtime()time.struct_time(tm_year=2017, tm_mon=8, tm_mday=10, tm_hour=10, tm_min=45, tm_sec=54, tm_wday=3, tm_yday=222, tm_isdst=0)&gt;&gt;&gt; time.gmtime()time.struct_time(tm_year=2017, tm_mon=8, tm_mday=10, tm_hour=2, tm_min=45, tm_sec=59, tm_wday=3, tm_yday=222, tm_isdst=0)# 格式化字符串&gt;&gt;&gt; time.strftime("%Y-%m-%d %H:%M:%S")'2017-08-10 10:46:43' 如上图，三种方式相互转换(不能时间戳转格式化字符串，或者格式化字符串转时间戳，要通过中间元组形式转换) 1234567891011121314151617181920212223242526&gt;&gt;&gt; import time&gt;&gt;&gt; timestamp = time.time()&gt;&gt;&gt; print(timestamp)1502679390.184194# 时间戳 转 元组形式&gt;&gt;&gt; time.localtime(timestamp)time.struct_time(tm_year=2017, tm_mon=8, tm_mday=14, tm_hour=10, tm_min=56, tm_sec=30, tm_wday=0, tm_yday=226, tm_isdst=0)&gt;&gt;&gt; time.gmtime(timestamp)time.struct_time(tm_year=2017, tm_mon=8, tm_mday=14, tm_hour=2, tm_min=56, tm_sec=30, tm_wday=0, tm_yday=226, tm_isdst=0)# 元组形式 转 时间戳&gt;&gt;&gt; time.mktime(time.localtime(timestamp))1502679390.0&gt;&gt;&gt; time.mktime(time.gmtime(timestamp))1502650590.0# 元组形式 转 字符串形式&gt;&gt;&gt; time.strftime("%Y-%m-%d %H:%M:%S",time.localtime(timestamp))'2017-08-14 10:56:30'&gt;&gt;&gt; time.strftime("%Y-%m-%d %H:%M:%S",time.gmtime(timestamp))'2017-08-14 02:56:30'# 字符串形式 转 元组形式&gt;&gt;&gt; time.strptime('2016-11-25', "%Y-%m-%d")time.struct_time(tm_year=2016, tm_mon=11, tm_mday=25, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=4, tm_yday=330, tm_isdst=-1) datetime模块时间戳、datetime类型、字符串之间相互转换datetime模块中包含4个主要的类： datetime.time：时间类，只包含时、分、秒、微秒等时间信息。 datetime.date：日期类，只包含年、月、日、星期等日期信息。 datetime.datetime：日期时间类，包含以上两者的全部信息。 datetime.timedelta：时间日期差值类，用来表示两个datetime之间的差值。 在datetime模块中，时间日期主要表现为三种常用形式： 时间戳：一般指Unix时间戳，从 1970-1-1 0:0:0 到现在的秒数 datetime类型：本地时间、UTC时间 格式化字符串形式 如上图，datetime模块的三种形式相互转换 12345678910111213141516171819202122232425&gt;&gt;&gt; from datetime import datetime# 获取datetime.datetime类型的本地时间和UTC时间&gt;&gt;&gt; datetime_local = datetime.now()&gt;&gt;&gt; datetime_utc = datetime.utcnow()# datetime类型 转 时间戳&gt;&gt;&gt; datetime_local.timestamp()1502336341.267918&gt;&gt;&gt; datetime_utc.timestamp()1502307553.165676# 时间戳 转 datetime类型 （本地时间和UTC时间）&gt;&gt;&gt; datetime.fromtimestamp(time.time())datetime.datetime(2017, 8, 10, 11, 46, 13, 106668)&gt;&gt;&gt; datetime.utcfromtimestamp(time.time())datetime.datetime(2017, 8, 10, 3, 46, 23, 873827)# datetime类型 转 字符串形式&gt;&gt;&gt; datetime.now().strftime("%Y-%m-%d %H:%M:%S")'2017-08-10 14:49:20'# 字符串形式 转 datetime类型&gt;&gt;&gt; datetime.strptime("2017-8-10 14:47:12","%Y-%m-%d %H:%M:%S")datetime.datetime(2017, 8, 10, 14, 47, 12) 当然，也可以将 datetime类型 转为 元组形式 12345# datetime类型 转 元组形式 （本地时间和UTC时间）&gt;&gt;&gt; datetime_local.timetuple()time.struct_time(tm_year=2017, tm_mon=8, tm_mday=10, tm_hour=11, tm_min=39, tm_sec=1, tm_wday=3, tm_yday=222, tm_isdst=-1)&gt;&gt;&gt; datetime_utc.utctimetuple()time.struct_time(tm_year=2017, tm_mon=8, tm_mday=10, tm_hour=3, tm_min=39, tm_sec=13, tm_wday=3, tm_yday=222, tm_isdst=0) timedelta类datetime模块中有个timedelta类，timedelta对象代表两个时间之间的时间差，两个date 或 datetime 类型对象相减时，可以返回一个timedelta对象。 原型如下： class datetime.timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0)所有参数可选，默认都是0，参数的值可以是整数、浮点数、正数或者负数。 例子：计算昨天的日期时间 12345678&gt;&gt;&gt; from datetime import timedelta&gt;&gt;&gt; now = datetime.now()&gt;&gt;&gt; print(now)2017-08-14 11:11:19.815021&gt;&gt;&gt; nowdatetime.datetime(2017, 8, 14, 11, 11, 19, 815021)&gt;&gt;&gt; now - timedelta(days=1)datetime.datetime(2017, 8, 13, 11, 11, 19, 815021) timezone类datetime模块中有个timezone类，是tzinfo的子类。timezone类，其每个实例表示由与UTC的固定偏移量定义的时区。 class datetime.timezone(offset, name=None) offset 参数必须指定为表示本地时间和UTC之间差异的 timedelta 对象。它必须严格地在 -timedelta(hours=24) 和 timedelta(hours=24) 之间，并且表示整数分钟，否则产生 ValueError。 name 参数是可选的。如果指定，它必须是将被用作 datetime.tzname() 方法返回值的字符串。 Python3.2开始才提供了datetime.timezone类。 本地时间转UTC时间本地时间是指系统设定时区的时间，例如北京时间是UTC+8:00时区的时间，而UTC时间指UTC+0:00时区的时间。 一个datetime类型有一个时区属性tzinfo，但是默认为None，所以无法区分这个datetime到底是哪个时区，除非强行给datetime设置一个时区： 12345678&gt;&gt;&gt; from datetime import datetime,timedelta,timezone&gt;&gt;&gt; tz_utc_8 = timezone(timedelta(hours=8)) # 创建时区UTC+8:00&gt;&gt;&gt; now = datetime.now()&gt;&gt;&gt; nowdatetime.datetime(2017, 8, 10, 17, 21, 35, 983594)&gt;&gt;&gt; dt = now.replace(tzinfo=tz_utc_8) # 强制设置为UTC+8:00时区&gt;&gt;&gt; dtdatetime.datetime(2017, 8, 10, 17, 21, 35, 983594, tzinfo=datetime.timezone(datetime.timedelta(0, 28800))) 例子：获取用户输入的日期和时间，如2017-8-10 15:02:11，以及一个时区信息UTC+6:00，均是字符串类型，编写一个函数将其转换为timestamp 1234567891011121314import refrom datetime import timezone, timedeltadef to_timestamp(dt_str, tz_str): date = datetime.strptime(dt_str, '%Y-%m-%d %H:%M:%S') # 字符串 转 datetime类型 tz_int = int(re.search('(\-|\+)\d+', tz_str).group()) # 正则匹配，获取时区号(+或-) tz_utc_x = timezone(timedelta(hours=tz_int)) # 时区变量 date_utc = date.replace(tzinfo=tz_utc_x) # 强制设置时区 tstamp = date_utc.timestamp() # datetime类型 转 时间戳 return tstamp# 测试t1 = to_timestamp('2015-6-1 08:10:30', 'UTC+7:00')assert t1 == 1433121030.0, t1 time模块和datetime模块之间相互转换time 转 datetime 123&gt;&gt;&gt; timestamp = time.time()&gt;&gt;&gt; datetime.fromtimestamp(timestamp)datetime.datetime(2017, 8, 10, 14, 57, 47, 666371) datetime 转 time：先将datetime类型转为元组形式，再转为时间戳 123&gt;&gt;&gt; datetime_local = datetime.now()&gt;&gt;&gt; time.mktime(datetime_local.timetuple())1502348313.0 pytz模块pytz模块，使用Olson TZ Database解决了跨平台的时区计算一致性问题，解决了夏令时带来的计算问题。 参考资料：你真的了解Python中的日期时间处理吗？廖雪峰python教程-datetime模块]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[换源总集]]></title>
    <url>%2F2017%2F08%2F08%2F%E6%8D%A2%E6%BA%90%E6%80%BB%E9%9B%86%2F</url>
    <content type="text"><![CDATA[很多国外镜像，在国内访问会很慢。遇到这种情况，可以通过两种方法解决： 使用代理更换为国内源 这里总结常用的换源和介绍国内较好的源。 Pypi 换源mac系统要注意，mac在家目录中默认没有 .pip 目录，要自己创建进入家目录，新建 .pip 目录，在该目录中新建一个文件 pip.conf 123$ cd ~$ mkdir .pip$ touch .pip/pip.conf 编辑 pip.conf 配置文件，加入国内的pypi源 123456# 阿里云的pypi源[global]index-url = http://mirrors.aliyun.com/pypi/simple/[install]trusted-host=mirrors.aliyun.com 或者： 123456# 豆瓣的pypi源[global]index-url = http://pypi.douban.com/simple[install]trusted-host=pypi.douban.com Homebrew 换源Homebrew是一款自由及开放源代码的软件包管理系统，用以简化 Mac OS 系统上的软件安装过程。Homebrew主要分两部分：git repo（位于GitHub）和 二进制bottles（位于bintray），这两者在国内访问都不太顺畅。可以替换成国内的镜像。 USTC的官方文档 替换和重置Homebrew默认源这里使用中科大的镜像，速度蛮快的。 123# 替换brew.git$ cd "$(brew --repo)"$ git remote set-url origin https://mirrors.ustc.edu.cn/brew.git 当中科大源失效或宕机时，可以切回官方源： 123# 重置brew.git$ cd &quot;$(brew --repo)&quot;$ git remote set-url origin https://github.com/Homebrew/brew.git 替换和重置Homebrew Bottles源Homebrew Bottles是Homebrew提供的二进制代码包。对于bash用户： 12$ echo &apos;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&apos; &gt;&gt; ~/.bash_profile$ source ~/.bash_profile 对于zsh用户： 12$ echo &apos;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&apos; &gt;&gt; ~/.zshrc$ source ~/.zshrc 注释掉bash或zsh配置文件里的有关Homebrew Bottles即可恢复官方源。然后重读该配置文件使其生效。 Docker换源国内有3家的Docker镜像源蛮不错，速度挺快的： DaoCloud USTC(中科大) 阿里云 DaoCloud的Docker加速器DaoCloud加速器需要用户注册，每个用户每月限制10GB。注册登录后，访问配置Docker加速器，会介绍如何使用。 红色涂改处的地址，会根据每个人ID不同而有不同。记得设置后，要重新启动docker服务： 1# service docker restart 注意，该Docker加速器对Docker版本有要求，需要 Docker 1.8 或更高版本才能使用。 USTC的Docker镜像官方文档 Docker镜像使用帮助 里已写得很清楚，这里就不冗余的贴出来。USTC的镜像源做的很好，速度很快，个人强烈推荐使用。 阿里云的Docker加速器阿里云的会繁琐点，不仅要注册为阿里云用户，还要加入开发者平台。配置方法跟DaoCloud的类似，也是开通加速器后给一个URL，详情看：Docker镜像加速器的配置 阿里云的Docker加速器，要求Docker版本 大于 1.10 。]]></content>
      <categories>
        <category>技术杂项</category>
      </categories>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用操作]]></title>
    <url>%2F2017%2F07%2F26%2FGit%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[整理Git的常用命令，方便以后查找。 配置用户信息Git的设置文件为 .gitconfig ，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 设置用户名称和邮箱地址，--global 表示全局设置，本机上所有的Git仓库通用该配置 12$ git config --global user.name &quot;[name]&quot;$ git config --global user.email &quot;[email address]&quot; 查看配置文件 12345# 查看[仓库级|全局级|系统级]的 config$ git config [--local|--global|--system] -l# 查看当前生效的配置$ git config -l 编辑配置文件 123456789# 查看仓库级的config$ git config --local -e$ git config -e # 查看全局级的config$ git config --global -e# 查看系统级的config$ git config --system -e 添加1234567891011# 添加指定文件到暂存区，可指定多个文件$ git add [file1] [dir/file2] ...# 添加指定文件到暂存区，可指定通配符；如 *.txt，匹配所有txt文件$ git add [file-pattern]# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add . 提交123456789101112131415# 提交暂存区所有文件到仓库区，一定要记得添加提交信息(message)$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区 (省略 git add 那一步)$ git commit -a # 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 删除文件12345678# 删除工作区文件(已被追踪的文件)，并将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件(在暂存区中删除)，但该文件会保留在工作区$ git rm --cached [file]# 文件改名(工作区)，并将这个改名放入暂存区$ git mv [file-oldname] [file-newname] 查看信息1234567891011121314151617181920212223242526# 检查当前文件状态$ git status# 显示当前分支的版本历史(按提交时间排序)$ git log# 简洁模式，每个提交只显示一行信息，包括 commit id（版本号）和 提交说明$ git log --pretty=oneline# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-commit]..[second-commit]# 显示某次提交的元数据和内容变化$ git show [commit-id]# 显示当前分支的最近几次操作(操作历史)$ git reflog 分支1234567891011121314151617181920212223# 列出所有的分支，"*" 标识的是当前分支$ git branch # 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建分支，但仍停留在当前分支$ git branch [branch-name]# 新建分支，并切换到该分支$ git checkout -b [branch-name]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 合并指定分支到当前分支$ git merge [branch-name]# 删除分支$ git branch -d [branch-name] 标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag-name]# 新建一个tag在指定commit$ git tag [tag-name] [commit-id]# 新建一个tag，并指定标签注释说明$ git tag -a [tag-name] -m "message"# 提交指定tag到指定远程仓库（ git push 默认不提交标签到远程仓库）$ git push [remote-name] [tag-name]# 提交所有的tag到指定远程仓库$ git push [remote-name] --tags# 查看tag信息$ git show [tag-name]# 删除本地tag$ git tag -d [tag-name]# 删除指定远程仓库的tag$ git push [remote-name] :refs/tags/[tag-name] 远程同步默认远程仓库名：origin默认分支：master 1234567891011121314151617181920212223242526# 抓取指定远程仓库的所有变动，不做合并，不影响工作区$ git fetch [remote]# 显示所有远程仓库(显示仓库地址)$ git remote -v# 显示指定远程仓库的信息(仓库地址、HEAD指向分支、所有分支等)$ git remote show [remote-name]# 增加一个新的远程仓库，并命名$ git remote add [remote-name] [url]# 删除指定的远程仓库$ git remote remove [remote-name]# 取回指定远程仓库的变化，并与本地分支合并$ git pull [remote-name] [branch-name]# 上传本地指定分支到指定远程仓库$ git push [remote-name] [branch-name]# 推送所有分支到指定远程仓库$ git push [remote-name] --all# 强行推送当前分支到指定远程仓库，即使有冲突$ git push [remote-name] --force 撤销修改12345678910111213141516171819# 恢复暂存区指定文件到工作区( 没"--"，就变成切换分支了 )$ git checkout -- [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit-id] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 暂时将未提交的变化移到堆栈中(工作区变干净)# 从堆栈中恢复最新的存储，--index 重新应用之前被暂存的变更$ git stash$ git stash pop [--index] 版本回退1234567# 新建一个commit，用来撤销指定的commit（commit历史会保留）# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit-id]# 回滚到commit-id，将该commit-id之后的commit都删除。(commit历史会被删掉)# --hard 重设暂存区和工作区$ git reset --hard [commit-id] 抄自阮一峰老师的博文：常用 Git 命令清单 基本没啥自己整理的，该篇博文权当自己备忘用。]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用GitLab的Webhooks功能，实现网站代码自动更新部署]]></title>
    <url>%2F2017%2F07%2F04%2F%E5%88%A9%E7%94%A8GitLab%E7%9A%84Webhooks%E5%8A%9F%E8%83%BD%EF%BC%8C%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%AB%99%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[根据业务需求，已部署GitLab-CE，网站代码上线流程如下图： 开发者 push 推送代码之后，网站代码仍没更新，还需要操作多一步：登录前端web服务器，手动git pull 拉取更新的代码。这一步是运维的工作，很无趣又烦琐。 幸亏，GitLab提供了Webhooks功能，可以轻松实现网站代码自动更新部署。 一、webhooks原理Webhooks的原理 Project webhooks allow you to trigger a URL if for example new code is pushed or a new issue is created.You can configure webhooks to listen for specific events like pushes, issues or merge requests. GitLab will send a POST request with data to the webhook URL.Webhooks can be used to update an external issue tracker, trigger CI jobs, update a backup mirror, or even deploy to your production server. 简单说明 webhooks允许指定一个URL，用于触发push或其他事件时进行自定义操作。例如，当开发者push代码到GitLab服务器，会触发push事件，GitLab会发送一个POST请求连带数据（数据格式）给webhooks指定的URL，该URL可以是前端web的php程序或Python程序等。这样，每当GitLab有push事件，就能在前端web服务器上执行一个脚本程序。 使用webhooks的步骤： 在前端web服务器上安装Git客户端，用于拉取远程仓库 git pull 创建并添加公钥，以便免密码拉取远程仓库 创建脚本程序，并配置webhooks 二、安装Git客户端在前端web服务器上，执行以下安装命令 1# yum install git 三、创建并添加公钥前端web服务器的 nginx 和 php-fpm 都是以 www 用户来运行的，所以要为www用户创建并添加公钥。 www 用户的家目录是: /home/www/ 修改 www 用户的 shell 为 /bin/bash 1www:x:511:511::/home/www:/bin/bash 创建用户的公钥12# su www$ ssh-keygen -t rsa 遇到交互，全部回车就好。最后会在/home/www/.ssh 目录下生成两个文件，私钥文件：id_rsa，公钥文件：id_rsa.pub 添加公钥到GitLab后台获取www用户的公钥文件内容： 1cat /home/www/.ssh/id_rsa.pub 复制公钥内容，添加公钥，GitLab后台添加公钥的位置：管理员 &gt; Settings &gt; SSH Keys 修改网站根目录的权限修改网站根目录( /home/www/test/ ) 的权限，否则以www用户git pull 会报权限问题。 12# chmod 775 /home/www/test/ -R# chown www.www /home/www/test/ -R 测试测试www用户基于公钥是否能从Git服务器远程拉取代码 手动执行pull操作 123# su www$ cd /home/www/test/ $ git pull 四、部署webhooks编写webhooks应用的PHP程序在前端web服务器的网站根目录（/home/www/test/）下新建一个webhooks.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?php//网站目录$www_file='/home/www/test/';//打开网站目录下的hooks.log文件,需要在服务器上创建,并给写权限$fs = fopen('/home/www/test/hooks.log', 'a');fwrite($fs, '================ Update Start ==============='.PHP_EOL.PHP_EOL);//自定义字串掩码 用于验证$access_token = 'QhNO8YHqym5PHQQsexapF7041xOhzm62DRH';//接受的ip数组，也就是允许哪些IP访问这个文件 这里是gitlab服务器IP$access_ip = array('192.168.1.15','14.xxx.xxx.19');//如果使用www.xxx.com/xxx.php?token=xxxxxxx 的方式来传送验证字符串，则用这个方法获取# $client_token = $_GET['token'];// 获取请求端的secret token$client_token = $_SERVER["HTTP_X_GITLAB_TOKEN"];//获取请求端的IP$client_ip = $_SERVER['REMOTE_ADDR'];//把请求的IP和时间写进logfwrite($fs, 'Request on ['.date("Y-m-d H:i:s").'] from ['.$client_ip.']'.PHP_EOL);//验证token 有错就写进日志并退出if ($client_token !== $access_token)&#123; echo "error 403"; fwrite($fs, "Invalid token [&#123;$client_token&#125;]".PHP_EOL); exit(0);&#125;//验证ipif ( !in_array($client_ip, $access_ip))&#123; echo "error 503"; fwrite($fs, "Invalid ip [&#123;$client_ip&#125;]".PHP_EOL); exit(0);&#125;//获取请求端发送来的信息，具体格式参见gitlab的文档$json = file_get_contents('php://input');$data = json_decode($json, true);//如果有需要 可以打开下面，把传送过来的信息写进log# fwrite($fs, 'Data: '.print_r($data, true).PHP_EOL);//执行shell命令并把返回信息写进日志$output=shell_exec("cd $www_file &amp;&amp; git pull 2&gt;&amp;1");fwrite($fs, 'Info:'. $output.PHP_EOL);fwrite($fs,PHP_EOL. '================ Update End ==============='.PHP_EOL.PHP_EOL);$fs and fclose($fs);?&gt; 修改PHP配置因为webhooks用到的php代码中使用了 shell_exec 函数，一般配置php会禁止这个函数，需要打开 shell_exec 函数。修改前端web服务器上php.ini的 disable_functions 列表，去掉 shell_exec 。重启php-fpm服务。 配置GitLabproject &gt; Settings &gt; Integrations Secret Token中字符串的值，要跟webhooks.php中$access_token 的值相同。Enable SSL verification 不要勾。 可以按 [Test] 按钮，测试配置是否生效。 五、遇到的问题在部署webhooks中，遇到了个很诡异的问题。 前提说明 GitLab-CE 版本：9.2.6使用xhang项目对GitLab-CE进行汉化过 问题描述： 已成功部署webhooks，按 [Test] 按钮测试正常。但在实际使用中，开发者push代码后，webhooks.php没有被执行，前端web代码没有git pull 记录，日志也没有记录。GitLab没有检测到开发者的push事件。 问题分析： 通过另外部署一套同版本的、不打汉化补丁的GitLab-CE，发现不是汉化补丁的问题。 回想起之前遇到的一个问题，在GitLab-CE上新创建test项目时，开发者push后，GitLab上仍然显示该项目是空项目，无法检测到push事件，后来还是通过修改项目名来使得其能识别push事件。 问题解决： 后来偶然发现，webhooks时GitLab没有及时检测到开发者的push事件，是因为对 /var/opt/gitlab/ 目录做了软链接的缘故。去掉软链接，改为正常的目录路径。]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git问题集锦]]></title>
    <url>%2F2017%2F06%2F27%2FGit%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6%2F</url>
    <content type="text"><![CDATA[记录Git使用过程中出现的问题 git子模块问题最近要将某个项目的代码加入Git版本控制，在该项目目录做Git初始化后，提交推送到Git服务器。 123456# cd test# git init# git remote add origin git@gitlab.xxx.com:test/test.git# git add .# git commit -m "Initial commit"# git push -u origin master 将该项目拉到本地电脑的时候，出现了问题，monolog目录下没有拉到任何文件 手动在项目代码服务器上 git add 该目录下的文件，也报错： 1fatal: Pathspec &apos;composer.json&apos; is in submodule &apos;web/passport_v3/vendor/monolog/monolog/&apos; 分析：monolog 本身就是一个git库，父目录被Git初始化后，monolog目录变成了子模块。 现在，不需要将monolog目录作为子模块。 解决方法： 删除monolog目录下git相关的文件，如.git目录、.gitignore等 用git rm –cached 删除已经被提交到暂存区的特定文件，重新添加提交 1234# cd test# git rm -rf --cached web/passport_v3/vendor/monolog/monolog/# git add web/passport_v3/vendor/monolog/monolog/# git commit -m "子模块问题解决" Git回滚远程版本提取仓库根目录下的某目录文件，配置为另外一个Git仓库线上服务器中，dev 仓库下有个 test 目录，这是一个项目目录，现想将该目录内容提取出来，另外配置一个git仓库。 在Git服务器上创建一个裸仓库，裸仓库没有工作区，因服务器上的Git仓库纯粹为了共享，不让用户直接登录Git服务器改工作区，并且Git服务器上的仓库通常都以 .git 结尾。 123# cd /git# git init --bare test.git# chown -R git.git test.git 克隆空仓库 test 到线上服务器，拷贝 test 目录下的所有文件到空仓库 test 目录。 123# cd /home/www# git clone git@xx.xx.xx.xx:/git/test.git# cp -a /home/www/dev/test/* /home/www/test/ 添加文件并提交 12# git add .# git commit -m &quot;初始化提交&quot; 配置好 .gitignore，推送到Git服务器 1# git push 在版本库中删除 dev 仓库下的 test 目录，本地工作区保留目录文件 12# cd /home/www/dev# git rm -r --cached test]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitLab汉化指南]]></title>
    <url>%2F2017%2F06%2F24%2FGitLab%E6%B1%89%E5%8C%96%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[为了方便，降低新手上手的难度，对GitLab进行汉化。 以下介绍GitLab汉化的两个方法 1、直接安装中文版GitLab中文社区有集成了中文版的rpm安装包，可以直接去下载安装。 GitLab中文社区的安装源，目前汉化的最新版本是 gitlab-ce-9.3.0 CentOS 6.x 中，安装GitLab中文版： 12# curl -LJO https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el6/gitlab-ce-9.3.0-ce.0.el6.x86_64.rpm# rpm -i gitlab-ce-9.3.0-ce.0.el6.x86_64.rpm 修改配置/etc/gitlab/gitlab.rb，绑定域名： 1external_url &apos;http://gitlab.xxx.com&apos; 修改这个配置，会影响GitLab里面显示的仓库链接。 使配置生效： 12345678# 重新生成配置，启动服务gitlab-ctl reconfigure # 清空缓存gitlab-rake cache:clear RAILS_ENV=production # 重启所有 gitlab 组件gitlab-ctl restart 2、汉化确定GitLab安装版本通过官方提供的GitLab-CE Omnibus安装包安装了GitLab CE 9.2.6 1# cat /opt/gitlab/embedded/service/gitlab-rails/VERSION 克隆GitLab汉化源代码仓库12345# 克隆 GitLab.com 仓库git clone https://gitlab.com/xhang/gitlab.git# 如果是8.8之前的版本可以使用这个git clone https://gitlab.com/larryli/gitlab.git larryli项目 ：只更新到8.8.5版本。 xhang项目 ：延续Larry Li项目的8-8-zh中文版本进行更新，目前最新版本是9.3.0 。 根据安装的版本到 LarryLi项目 或 xhang项目 查看汉化是否支持，注意只要前两位版本号一致就好，如：安装GitLab版本是8.8.6，可以使用 v8.8.0 汉化版本。 打汉化补丁以 9.2.6 版本为例（使用xhang的git仓库） 123456789101112131415161718# 进入克隆仓库得到的gitlab目录cd gitlab # 查看tag版本，选择合适的汉化版本git tag# 对比不同，这里比较的是tag，v9.2.6为英文原版，v9.2.6-zh为汉化版本。diff结果是汉化补丁。git diff v9.2.6..v9.2.6-zh &gt; /tmp/9.2.6.diff# 停止gitlabgitlab-ctl stop# 应用汉化补丁cd /opt/gitlab/embedded/service/gitlab-railsgit apply /tmp/9.2.6.diff# 启动gitlabgitlab-ctl start 如果汉化中出现问题，请重新安装GitLab，注意要先备份数据。]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitLab搭建及配置]]></title>
    <url>%2F2017%2F06%2F23%2FGitLab%E6%90%AD%E5%BB%BA%E5%8F%8A%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[由于公司业务，需要上Git版本控制。 目前市面上比较有名的Git服务提供商，国外有GitHub、BitBucket、GitLab，国内有Coding。 现有的服务商，对于免费的套餐都有一定的限制。比如：GitHub只允许建立免费的开源repository，建立私有的仓库需要收费。BitBucket允许建立无限制的私有项目，不过对于项目中参与的开发人员是有人数限制的，当团队中开发者规模达到一定数量后，需要付费购买相应的套餐。 GitLab社区版是免费的，不但能建立免费的私有仓库而且没有数量上限，参与人员也没有数量限制，还能设置成员的权限，甚至细致到具体某条分支的权限，以及强大的工作流等等。 GitLab很适合中小型非开源项目公司。 一、GitLab 简介GitLab 是一个利用Ruby on Rails 开发的开源版本控制系统，实现一个自托管的Git项目仓库，可通过Web界面进行访问公开的或者私人项目。 它拥有与GitHub类似的功能，能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。团队成员可以利用内置的简单聊天程序（Wall）进行交流。它还提供一个代码片段收集功能可以轻松实现代码复用，便于日后有需要的时候进行查找。 开源中国代码托管平台 码云 就是基于GitLab项目搭建。 GitLab 分为 GitLab Community Edition(CE) 社区版 和 GitLab Enterprise Edition(EE) 专业版。社区版免费，专业版收费，两个版本在功能上的差异对比，可以参考官方对比说明 二、GitLab 安装和配置安装社区版，GitLab CE 版本：9.2.6 1、GitLab安装通过GitLab官方提供的Omnibus安装包来安装，相对方便。Omnibus安装包套件整合了大部分的套件（Nginx、ruby on rails、git、redis、postgresql等），再不用额外安装这些软件，减轻了绝大部分安装量。 GitLab官方安装文档 ：CentOS6.x系统 安装依赖包，并配置postfix服务为GitLab邮件服务123# yum install curl openssh-server openssh-clients postfix cronie# service postfix start# chkconfig postfix on 打开HTTP和SSH端口12# iptables -I INPUT -m tcp -p tcp --dport 22 -j ACCEPT# iptables -I INPUT -m tcp -p tcp --dport 80 -j ACCEPT 两种安装源 从官方镜像源安装 添加GitLab仓库并安装到服务器上 1234# curl -sS http://packages.gitlab.cc/install/gitlab-ce/script.rpm.sh | sudo bash# yum install gitlab-ce # 自动安装最新版本# yum install gitlab-ce-9.2.1-ce.0.el6 # 安装指定版本 从第三方镜像源安装 官方镜像源在国外，国内安装会很慢，甚至有时因网络问题会无法安装。 国内推荐使用清华大学开源软件镜像源。 新建 /etc/yum.repos.d/gitlab-ce.repo，内容为： 12345[gitlab-ce]name=Gitlab CE Repositorybaseurl=https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el$releasever/gpgcheck=0enabled=1 再执行 12# yum makecache # 更新本地YUM缓存# yum install gitlab-ce # 自动安装最新版本 修改配置文件/etc/gitlab/gitlab.rb，绑定域名1external_url &apos;http://gitlab.xxx.com&apos; 启动GitLab，使得配置生效1# gitlab-ctl reconfigure 在Dnspod中添加解析记录使用浏览器访问GitLab 首次访问GitLab,系统会让你重新设置管理员的密码,设置成功后会返回登录界面.默认的管理员账号是root,如果你想更改默认管理员账号,请输入上面设置的新密码登录系统后修改帐号名. GitLab安装细节12345主配置文件: /etc/gitlab/gitlab.rbGitLab 文档根目录: /opt/gitlab默认存储库位置: /var/opt/gitlab/git-data/repositoriesGitLab Nginx 配置文件路径: /var/opt/gitlab/nginx/conf/gitlab-http.confPostgresql 数据目录: /var/opt/gitlab/postgresql/data GitLab由以下服务构成 nginx: 静态web服务器 gitlab-shell: 用于处理Git命令和修改authorized keys列表 gitlab-workhorse: 轻量级的反向代理服务器 logrotate：日志文件管理工具 postgresql：数据库 redis：缓存数据库 sidekiq：用于在后台执行队列任务（异步执行） unicorn：An HTTP server for Rack applications，GitLab Rails应用是托管在这个服务器上面的。 2、配置SMTP服务如果你不想用服务器自带的postfix服务来发邮件，可以改用SMTP服务。 修改GitLab邮件服务配置(gitlab.rb文件)，使用腾讯企业邮箱的SMTP服务器，填写账号和密码 1234567gitlab_rails[&apos;smtp_address&apos;] = &quot;smtp.exmail.qq.com&quot;gitlab_rails[&apos;smtp_port&apos;] = 25gitlab_rails[&apos;smtp_user_name&apos;] = &quot;xxx&quot;gitlab_rails[&apos;smtp_password&apos;] = &quot;xxx&quot;gitlab_rails[&apos;smtp_domain&apos;] = &quot;smtp.qq.com&quot;gitlab_rails[&apos;smtp_authentication&apos;] = &apos;plain&apos;gitlab_rails[&apos;smtp_enable_starttls_auto&apos;] = true 使配置生效 12# gitlab-ctl reconfigure# gitlab-rake cache:clear RAILS_ENV=production # 清除缓存 3、GitLab配置HTTPSGitLab默认是使用HTTP的，可以手动配置为HTTPS 上传SSL证书创建ssl目录，用于存放SSL证书 12# mkdir -p /etc/gitlab/ssl# chmod 0700 /etc/gitlab/ssl 上传证书并修改证书权限 1# chmod 600 /etc/gitlab/ssl/* 修改GitLab的配置文件修改配置文件/etc/gitlab/gitlab.rb 1234external_url &quot;https://gitlab.xxx.com&quot;nginx[&apos;redirect_http_to_https&apos;] = truenginx[&apos;ssl_certificate&apos;] = &quot;/etc/gitlab/ssl/gitlab.xxx.com.crt&quot;nginx[&apos;ssl_certificate_key&apos;] = &quot;/etc/gitlab/ssl/gitlab.xxx.com.key&quot; 重建配置，使其生效 1# gitlab-ctl reconfigure 以上操作后，GitLab自带的Nginx服务的配置文件 /var/opt/gitlab/nginx/conf/gitlab-http.conf 会被重新修改： 12345678server &#123; listen *:80; server_name gitlab.xxx.com; server_tokens off; ## Don&apos;t show the nginx version number, a security best practice return 301 https://gitlab.xxx.com:443$request_uri; access_log /var/log/gitlab/nginx/gitlab_access.log gitlab_access; error_log /var/log/gitlab/nginx/gitlab_error.log;&#125; 不用额外再配置，HTTP 会自动跳转到 HTTPS 。 开放443端口在防火墙上开放443端口，用于HTTPS 1# iptables -I INPUT -m tcp -p tcp --dport 443 -j ACCEPT 4、修改root用户密码对于普通用户而言，可通过系统重置密码，接收邮件即可。可是GitLab管理员账号，缺省邮箱 admin@example.com 是个不存在的邮箱地址，无法通过邮箱修改密码。官方修改密码文档，根据文档，修改root密码的方法如下： 打开与Rails程序交互的控制台在root权限下，执行： 1# gitlab-rails console production 等待一会，直到控制台加载成功。 获取用户信息并修改root用户密码123456789101112# gitlab-rails console productionLoading production environment (Rails 4.2.8)irb(main):001:0&gt; user = User.where(id: 1).first=&gt; #&lt;User id: 1, email: &quot;admin@example.com&quot;......irb(main):009:0&gt; user.password = &apos;12345678&apos;=&gt; &quot;12345678&quot;irb(main):010:0&gt; user.password_confirmation = &apos;12345678&apos;=&gt; &quot;12345678&quot;irb(main):011:0&gt; user.save!Enqueued ActionMailer::DeliveryJob (Job ID: 510bb5be-a156-4522-9983-44d8a895e92a) to Sidekiq(mailers) with arguments: &quot;DeviseMailer&quot;, &quot;password_change&quot;, &quot;deliver_now&quot;, gid://gitlab/User/1=&gt; trueirb(main):011:0&gt; exit 三、GitLab 常用命令运维管理排查1234567891011121314151617181920# 查看版本cat /opt/gitlab/embedded/service/gitlab-rails/VERSION# 检查gitlabgitlab-rake gitlab:check SANITIZE=true --trace# 实时查看日志gitlab-ctl tail# 数据库关系升级gitlab-rake db:migrate# 清理redis缓存gitlab-rake cache:clear# 升级GitLab-ce 版本yum update gitlab-ce# 升级PostgreSQL最新版本gitlab-ctl pg-upgrade 服务管理123456789101112131415161718192021222324# 启动所有 gitlab 组件：gitlab-ctl start# 停止所有 gitlab 组件：gitlab-ctl stop# 停止所有 gitlab postgresql 组件：gitlab-ctl stop postgresql# 停止相关数据连接服务gitlab-ctl stop unicorngitlab-ctl stop sidekiq# 重启所有 gitlab 组件：gitlab-ctl restart# 重启所有 gitlab gitlab-workhorse 组件：gitlab-ctl restart gitlab-workhorse# 查看服务状态gitlab-ctl status# 生成配置并启动服务gitlab-ctl reconfigure 日志1234567891011121314151617181920212223# 实时查看所有日志gitlab-ctl tail# 实时检查redis的日志gitlab-ctl tail redis # 实时检查postgresql的日志gitlab-ctl tail postgresql # 检查gitlab-workhorse的日志gitlab-ctl tail gitlab-workhorse # 检查logrotate的日志gitlab-ctl tail logrotate # 检查nginx的日志gitlab-ctl tail nginx # 检查sidekiq的日志gitlab-ctl tail sidekiq # 检查unicorn的日志gitlab-ctl tail unicorn 四、GitLab备份和恢复备份GitLab作为公司项目代码的版本管理系统，数据非常重要，必须做好备份。 修改备份目录GitLab备份的默认目录是 /var/opt/gitlab/backups ，如果想改备份目录，可修改/etc/gitlab/gitlab.rb： 1gitlab_rails[&apos;backup_path&apos;] = &apos;/data/backups&apos; 修改配置后，记得： 1gitlab-ctl reconfigure 备份命令1gitlab-rake gitlab:backup:create 该命令会在备份目录（默认：/var/opt/gitlab/backups/）下创建一个tar压缩包xxxxxxxx_gitlab_backup.tar，其中开头的xxxxxx是备份创建的时间戳，这个压缩包包括GitLab整个的完整部分。 自动备份通过任务计划crontab 实现自动备份 12# 每天2点备份gitlab数据0 2 * * * /usr/bin/gitlab-rake gitlab:backup:create 备份保留7天可设置只保留最近7天的备份，编辑配置文件 /etc/gitlab/gitlab.rb 12# 数值单位：秒gitlab_rails[&apos;backup_keep_time&apos;] = 604800 重新加载gitlab配置文件 1gitlab-ctl reconfigure 恢复备份文件： 1/var/opt/gitlab/backups/1499244722_2017_07_05_9.2.6_gitlab_backup.tar 停止 unicorn 和 sidekiq ，保证数据库没有新的连接，不会有写数据情况。 1234567891011# 停止相关数据连接服务gitlab-ctl stop unicorngitlab-ctl stop sidekiq# 指定恢复文件，会自动去备份目录找。确保备份目录中有这个文件。# 指定文件名的格式类似：1499242399_2017_07_05_9.2.6，程序会自动在文件名后补上：“_gitlab_backup.tar”# 一定按这样的格式指定，否则会出现 The backup file does not exist! 的错误gitlab-rake gitlab:backup:restore BACKUP=1499242399_2017_07_05_9.2.6# 启动Gitlabgitlab-ctl start]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 安装]]></title>
    <url>%2F2017%2F06%2F22%2FGit-%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Git 简介 Git是目前世界上最先进的分布式版本控制系统，用C语言开发的，以追求最高的性能。Linux之父 Linus Torvalds 用10天编出Git第一个版本。 在CentOS 6.x/7.x 上安装最新版的Git CentOS 6.5 上，官方yum源的git版本是 1.7.1 。CentOS 7 上，官方yum源的git版本是 1.8.3 。 下面介绍安装最新版Git的两种方法 1、通过第三方RPM包来安装可以使用WANDisco的yum源安装Git，里边有WANDisco集成的rpm安装包。截止2017年6月22日，WANDisco的最新版本是2.11.1 安装WANDisco repo包centos 6.x 1# yum install http://opensource.wandisco.com/centos/6/git/x86_64/wandisco-git-release-6-1.noarch.rpm centos 7.x 1# yum install http://opensource.wandisco.com/centos/7/git/x86_64/wandisco-git-release-7-1.noarch.rpm 安装最新版Git1# yum install git -y 验证已安装的Git版本1# git version 2、编译安装安装依赖包Git 的工作需要调用 curl，zlib，openssl，expat，libiconv 等库的代码，所以需要先安装这些依赖工具。 12# yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel -y# yum install gcc perl-ExtUtils-MakeMaker -y 下载解压并编译安装GitGit镜像源，截止2017年6月22日，镜像源中提供的git源代码最新版是 2.13.1 。 123# cd /usr/local/src/# wget https://www.kernel.org/pub/software/scm/git/git-2.13.1.tar.gz# tar zxvf git-2.13.1.tar.gz 下载并解压Git源代码后，继续编译安装Git 12345# cd git-2.13.1# make configure# ./configure --prefix=/usr/local/git# make all doc info# make install install-doc install-html install-info 配置环境变量 12# echo &quot;export PATH=$PATH:/usr/local/git/bin&quot; &gt;&gt; /etc/bashrc# source /etc/bashrc 检查Git版本1# git version]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 查询缓存]]></title>
    <url>%2F2017%2F06%2F20%2FMySQL-%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[开启查询缓存后，查询语句的解析过程： 在解析一个查询语句之前，如果查询缓存是打开的，那么MySQL会优先检查这个查询是否命中查询缓存中的数据。如果当前的查询恰好命中了查询缓存，那么在返回查询结果之前MySQL会检查一次用户权限。若权限没有问题，MySQL会跳过所有其他阶段（解析、优化、执行等），直接从缓存中拿到结果并返回给客户端。这种情况下，查询不会被解析，不用生成执行计划，不会被执行。 开启查询缓存设置使用查询缓存的方式使用 query_cache_type 变量来开启查询缓存，开启方式有三种： ON : 正常缓存。表示在使用 SELECT 语句查询时，若没指定 SQL_NO_CACHE 或其他非确定性函数，则一般都会将查询结果缓存下来。 DEMAND ：指定SQL_CACHE才缓存。表示在使用 SELECT 语句查询时，必须在该 SELECT 语句中指定 SQL_CACHE 才会将该SELECT语句的查询结果缓存下来。 例如：select SQL_CACHE name from user where id = 15; #只有明确指定 SQL_CACHE 的SELECT语句，才会将查询结果缓存。 OFF： 关闭查询缓存。 立刻生效，重启服务失效1mysql&gt; set global query_cache_type=1; 注意: 当my.cnf 中，query_cache_type = OFF ，启动mysql服务后，在mysql命令行中使用上面语句开启查询缓存，会报错： 1ERROR 1651 (HY000): Query cache is disabled; restart the server with query_cache_type=1 to enable it 遇到这种情况，是无法在mysql命令行中开启查询缓存的，必须修改my.cnf的query_cache_type = ON，然后重启mysql服务。 永久生效修改 my.cnf : 1query_cache_type = ON 重启 mysql 服务 设置查询缓存的大小 query_cache_size ：查询缓存的总体可用空间。 注意: 如果 query_cache_size=0 ，那即便你设置了 query_cache_type = ON，查询缓存仍然是无法工作的。 立刻生效，重启服务失效1mysql&gt; set global query_cache_size=536870912; #单位为字节，必须为1024的倍数。 永久生效修改 my.cnf : 1query_cache_size = 500M #支持单位：K,M,G 重启 mysql 服务 查询缓存相关参数与缓存功能相关的服务器变量： 1234567891011mysql&gt; SHOW GLOBAL VARIABLES LIKE &apos;query_cache%&apos;;+------------------------------+----------+| Variable_name | Value |+------------------------------+----------+| query_cache_limit | 1048576 || query_cache_min_res_unit | 4096 || query_cache_size | 16777216 || query_cache_strip_comments | OFF || query_cache_type | ON || query_cache_wlock_invalidate | OFF |+------------------------------+----------+ 变量说明： 123456query_cache_limit : MySQL能够缓存的最大查询结果；如果某查询的结果大小大于此值，则不会被缓存；query_cache_min_res_unit : 查询缓存中分配内存的最小单位；(注意：此值通常是需要调整的，此值被调整为接近所有查询结果的平均值是最好的) 计算单个查询的平均缓存大小：（query_cache_size-Qcache_free_memory）/Qcache_queries_in_cachequery_cache_size : 查询缓存的总体可用空间，单位为字节；其必须为1024的倍数；query_cache_type: 查询缓存类型；是否开启缓存功能，开启方式有三种&#123;ON|OFF|DEMAND&#125;；query_cache_wlock_invalidate : 当其它会话锁定此次查询用到的资源时，是否不能再从缓存中返回数据；（OFF表示可以从缓存中返回数据） 关闭查询缓存关闭查询缓存，需要以下两步： 将query_cache_type设置为OFF。 将查询缓存的大小设置为0，这样才会真正不缓存数据。 注意: 即便query_cache_size = 0，但 query_cache_type 非 0 的话，在实际环境中，可能会频繁发生报错：Waiting for query cache lock 。 查询缓存状态1、与缓存相关的状态变量不能也无需修改这些状态数据。 12345678910111213mysql&gt; SHOW GLOBAL STATUS LIKE &apos;Qcache%&apos;;+-------------------------+----------+| Variable_name | Value |+-------------------------+----------+| Qcache_free_blocks | 1 | #查询缓存中的空闲块| Qcache_free_memory | 16759656| #查询缓存中尚未使用的空闲内存空间| Qcache_hits | 16 | #缓存命中次数| Qcache_inserts | 71 | #向查询缓存中添加缓存记录的条数| Qcache_lowmem_prunes | 0 | #表示因缓存满了而不得不清理部分缓存以存储新的缓存，这样操作的次数。若此数值过大，则表示缓存空间太小了。| Qcache_not_cached | 57 | #没能被缓存的次数| Qcache_queries_in_cache | 0 | #此时仍留在查询缓存的缓存个数| Qcache_total_blocks | 1 | #共分配出去的块数+-------------------------+----------+ 2、衡量缓存是否有效缓存命中率的计算（次数）12345678mysql&gt; SHOW GLOBAL STATUS WHERE Variable_name=&apos;Qcache_hits&apos; OR Variable_name=&apos;Com_select&apos;;+---------------+-----------+| Variable_name | Value |+---------------+-----------+| Com_select | 279292490 | #非缓存查询次数| Qcache_hits | 307366973 | # 缓存命中次数+---------------+----------- 缓存命中率：Qcache_hits/(Qcache_hits+Com_select) “命中和写入”的比率这是另外一种衡量缓存是否有效的指标。 1234567mysql&gt; SHOW GLOBAL STATUS WHERE Variable_name=&apos;Qcache_hits&apos; OR Variable_name=&apos;Qcache_inserts&apos;;+----------------+-----------+| Variable_name | Value |+----------------+-----------+| Qcache_hits | 307416113 | #缓存命中次数| Qcache_inserts | 108873957 | #向查询缓存中添加缓存记录的条数+----------------+-----------+ “命中和写入”的比率: Qcache_hits/Qcache_inserts # 如果此比值大于3:1, 说明缓存也是有效的；如果高于10:1，相当理想；]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密、解密原理和openssl自建CA过程详解]]></title>
    <url>%2F2017%2F06%2F19%2F%E5%8A%A0%E5%AF%86%E3%80%81%E8%A7%A3%E5%AF%86%E5%8E%9F%E7%90%86%E5%92%8Copenssl%E8%87%AA%E5%BB%BACA%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、加密和解密相关知识简介1、信息安全标准NIST（National Institute of Standards and Technology）美国国家标准与技术研究院，制定了网络信息安全与保密的三个要素：（这三大要素被简称为：CIA） 保密性(confidentiality)：信息不泄露给非授权用户、实体或过程，或供其利用的特性。（一般包括数据保密性、隐私性。） 完整性(Integrity)：数据未经授权不能进行改变的特性。即信息在存储或传输过程中保持不被修改、不被破坏和丢失的特性。（一般包括数据完整性、系统完整性。） 可用性(Availability)：可被授权实体访问并按需求使用的特性。即当需要时能否存取所需的信息。例如网络环境下拒绝服务、破坏网络和有关系统的正常运行等都属于对可用性的攻击； 尽管三要素能保证网络信息安全和保密，但从很多从事网络安全的研究人员的反馈发现，除了CIA外，还有另外两个标准也被经常提醒： 真实性：一个实体是真实的，是可被验证的。要确保数据发送方的确是它所声称的那个人。 可追溯性：一旦受到攻击，能追溯攻击发生的原处在什么地方。 2、OSI组织定义的安全框架x.800安全攻击： 被动攻击：窃听、（常见报文捕获、监听流量） 主动攻击：伪装、重播、消息修改、拒绝服务 安全机制： 加密、数字签名、访问控制、数据完整性、认证交换、流量填充、路由控制、公证 安全服务： 认证 ：同等实体认证 访问控制 数据保密性：连接保密性、无连接保密性、选择域保密性、流量保密性 数据完整性 ：不允许插入、删除、修改、重播 不可否认性 3、加密方式和算法(1)、对称加密对称加密：采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密。 对称加密的算法： 12345678DES : 数据加密标准（56位密钥）3DESAES ：高级加密标准（128，192，256，384，512）BlowfishTwofishIDEARC6CAST5 对称加密的特性： 加密、解密使用同一口令； 将明文分隔成固定大小的块，逐个进行加密 对称加密的缺陷： 密钥过多； 密钥传输；密钥交换、身份验正、数据完整性 (2)、公钥加密公钥加密：由对应的一对唯一性密钥（即公开密钥和私有密钥）组成的加密方法。 密钥：public key, secret key （p/s）公钥是从私钥中提取出来的。公钥加密，只能私钥解密。私钥加密，也只能公钥解密。 常用加密算法： 123RSADSA:只能用于身份验证EIGamal (3)、单向加密单向加密：不可逆的加密单向加密特性： 定长输出: 无论原始数据是多大，结果大小都相同的 雪崩效应: 输入的微小改变，将会引起结果的巨大改变 单向加密算法： 1MD5（128位）、SHA1、SHA256、SHA384、SHA512 二、加密和解密的过程和原理首先问一个问题： 假设B与A通信，B向A发送报文，怎么才能保证B的报文安全、可靠地被A接收到，并且保证报文数据的完整性？ 接下来围绕着这个问题来说明一下。 加密和解密的过程和原理图 加密解密过程和原理详细说明：1、发送端B 为保证安全，要对报文加密。加密方法有三类：对称加密、公钥加密和单向加密。对称加密不安全，单向加密是不可逆的，因而使用公钥加密。 问题：公钥加密安全（一般为2048位），但是加密过程太慢了，不适用当前网络需求，该怎么办？ 为了解决上述问题，B可以用单向加密提取出报文的特征码（特征码能保证报文的数据完整性），再使用自身的私钥对特征码进行公钥加密（特征码数据小，对其进行公钥加密速度快），并把加密后的特征码附加到报文后。（使用私钥加密是为了验证身份） 问题：这种方式能实现数据完整性和身份验证的检验，但是却缺失了报文的数据保密性，又该怎么办？ 为了解决上述问题，B在把加密的特征码附加到报文后，把特征码和报文当做一个数据（假设为data），使用对称加密算法对该数据(data)加密得出一个密码，再把密码附加到该数据(data)后。为了使得在传输过程中密码不被其他人获取或篡改，使用A的公钥对密码进行加密（只有A的私钥能对其解密），把加密的密码附加到数据data后，再这些数据一并发送给A。 2、接收端A A接收到B传来的报文，利用自身的私钥对其解密，获得密码。因为只有A的私钥能对B传来的报文（使用A的公钥加密密码）解密，所以能防止其他人对该传输的报文进行解密而获得其中的信息，保证了数据的保密性。 A利用获得的密码解密其中对称加密的数据，获得经过加密的特征码和原报文。 A使用B的公钥对该特征码解密，能解密则说明该报文是B发送过来的，实现了身份验证。（假设解密后的特征码是fcode） A使用同等单向加密算法对接收到的原报文提取其特征码。使用该特征码和解密后获得的特征码(fcode)做比较，如果一样，则说明原报文的数据完整。 问题：以上这种方式能保证数据完整性、身份验证和数据的保密性，在加密和解密的过程中都要用到对方的公钥，如何在传输过程中安全可靠地获得对方的公钥就成了关键的一环，那该如何做呢？答：安全可靠地获取对方的公钥靠CA(Certificate Authority )证书授权中心来实现。 因而接下来，我们来说说CA。 三、CA（证书授权中心）1、CA证书标准：x.509x.509: 定义了证书结构和认证协议标准；（基于公钥和数字签名）用于：IP安全、TLS/SSL（传输层安全）和S/MIME（安全电子邮件通信） x.509证书标准详细说明： 1234567891011（1）版本号（默认为1，如果有多个扩展，可能为3）（2）证书序列号（是一个整数，在CA中唯一标识，表明发行了多少个证书）（3）算法参数 （标志用了那种算法）（4）发行者的名称（CA自己的名字）（5）有效期限（6）主体名称（证书拥有者名称）(很关键！！！)（个人用户使用的是个人用户名，主机使用的必须是主机名而不是ip地址）（7）公钥（最重要）（公钥由证书拥有者提供）（8）发行者的ID（CA的唯一编号）（9）主体的ID（CA生成的证书拥有者唯一编号）（10）扩展（11）CA的签名（用于验证CA的来源合法性） CA是相对于发送方B和接收方A的第三方，是具有公信力的机构。 2、验证数字证书的过程B在发送之前获得A的数字证书或A在接收之前获得B的数字证书，都会去验证该数字证书的真伪。以B在发送之前获得A的数字证书为例，说明验证数字证书的过程： 要用对应给A发数字证书的那个CA的公钥去解密CA的签名，如果能解密，则说明A的数字证书确实是那个信任的CA所颁发的证书。 解密出一段特征码，B再使用同样的单向加密算法提取A的数字证书的特征码，比较这两个特征码是否一样，如果一样，则表示获得的A的数字证书是完整的。 此后，还要去验证该数字证书中的持有者是不是A，如果验证通过，才可以确定该数字证书确实是A的数字证书。 确认该数字证书的拥有者是A后，还要去查看该数字证书是否在有效期限内和是否在CA的数字证书吊销列表中。 四、SSL层1、SSL层SSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。版本：sslv1, sslv2, sslv3 ssl是介于应用层和传输层之间的半层，一般被制作成公共共享库，要想使用ssl就要调用ssl共享库。 2、https通信过程HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL。 以https为例，进一步说明如何依靠CA来可靠的获得通信对方的公钥 https的主要实现过程说明： （1）在通信之前，服务器端通过加密算法生成一对密钥，并把其公钥发给CA申请数字证书（2）CA审核后，结合服务端发来的相关信息生成数字证书，并把该数字证书发回给服务器端。（3）客户端和服务器端经tcp三次握手，建立初步连接。（4）客户端发送http报文请求并协商使用哪种加密算法。（5）服务端响应报文并把自身的数字签名发给服务端。（6）客服端下载CA的公钥，验证其数字证书的拥有者是否是服务器端（这个过程可以得到服务器端的公钥）。（一般是客户端验证服务端的身份，服务端不用验证客户端的身份。）（7）如果验证通过，客户端生成一个随机对称密钥，用该密钥加密要发送的URL链接申请，再用服务器端的公钥加密该密钥（8）客户端把加密的密钥和加密的URL链接一起发送到服务器。（9）服务器端使用自身的私钥解密，获得一个对称密钥，再用该对称密钥解密经加密的URL链接，获得URL链接申请。（10）服务器端根据获得的URL链接取得该链接的网页内容，并用客户端发来的对称密钥把该网页内容加密后发给客户端。（11）客户端收到加密的网页内容，用自身的对称密钥解密，就能获得网页的内容了。（12）TCP四次挥手，通信结束。 五、openssl自建CA过程详解OpenSSL是套开放源代码的软件库包，实现了SSL与TLS协议。其主要库是以C语言所写成，实现了基本的加密功能。OpenSSL可以运行在绝大多数类Unix操作系统上（包括Solaris，Linux，Mac OS X与各种版本的开放源代码BSD操作系统），OpenVMS与Microsoft Windows。它也提供了一个移植版本，可以在IBM i（OS/400）上运作。此软件是以Eric Young以及Tim Hudson两人所写的SSLeay为基础所发展的，SSLeay随着两人前往RSA公司任职而停止开发。虽然此软件是开放源代码的，但其授权书条款与GPL有冲突之处，故GPL软件使用OpenSSL时（如Wget）必须对OpenSSL给予例外。 openssl建立私有CAopenssl创建私有CA的过程： 前提：安装openssl 1# yum install openssl 1、建立CA服务器（1）生成密钥1# (umask 077; openssl genrsa -out /etc/pki/CA/private/cakey.pem 2048) 命令解释： ( ) 表示将会在当前shell中新建一个子shell，将（）中的命令放到该子shell中执行，执行完毕后关闭子shell并回到当前shell。由于要对生成的cakey.pem文件设置合适权限，可使用umask修改文件的默认权限设置。为了不影响当前shell的默认权限设置，使用（）将这些命令放到子shell中执行就行了！ genrsa : 指定使用rsa算法生成私钥 -out ：指定生成的私钥的存放位置（注意：该存放位置是在配置文件中默认定义了的，路径和文件名不能随意修改！！！） 2048 ：指定生成一个2048位的私钥 （2）自签证书1# openssl req -new -x509 -key /etc/pki/CA/private/cakey.pem -out /etc/pki/CA/cacert.pem -days 3655 命令解释： req: 生成证书签署请求 -news: 新请求 -x509: 专门用于生成自签署证书 -key /path/to/keyfile: 指定私钥文件（req命令能根据私钥自动抽取出公钥） -out /path/to/somefile: （注意：路径和文件名不用随意修改！） -days n: 有效天数（一般和-x509一起使用才有意义。） （3）初始化工作环境只有第一次创建CA时，才需要初始化工作环境 12# touch /etc/pki/CA/&#123;index.txt,serial&#125;# echo 01 &gt; /etc/pki/CA/serial （指定序列号从那个数字开始） 2、节点申请证书(1) 节点生成请求 生成密钥对儿 1# (umask 077; openssl genrsa -out /etc/httpd/ssl/httpd.key 2048) 生成证书签署请求 1# openssl req -new -key /etc/httpd/ssl/httpd.key -out /etc/httpd/ssl/httpd.csr .csr ：证书签署请求，一般都是这样的后缀 红框中的信息，需要和CA自签证书中填写的保持一致，否则会出错。 把签署请求文件发送给CA服务器 (2) CA签署证书 验正证书中的信息 签署证书 格式：openssl ca -in /path/to/somefile.csr -out /path/to/somefile.crt -days N说明：-in 指定证书签署请求文件 ； -out CA根据请求文件生成的证书，一般为 .crt 后缀；N 指定证书生效时长，天为单位 1234567891011121314151617181920212223242526272829303132[root@localhost CA]# openssl ca -in /etc/httpd/ssl/httpd.csr -out /etc/httpd/ssl/httpd.crt -days 1000 Using configuration from /etc/pki/tls/openssl.cnf Check that the request matches the signature Signature ok Certificate Details: Serial Number: 1 (0x1) Validity Not Before: Jul 3 14:07:23 2014 GMT Not After : Mar 29 14:07:23 2017 GMT Subject: countryName = CN #国家名 stateOrProvinceName = GuangDong #省份名 organizationName = 51CTOblog #公司名 organizationalUnitName = Ops #部门名 commonName = www.hjqjk.com #主机名 emailAddress = hjqjk@163.com #邮箱 X509v3 extensions: X509v3 Basic Constraints: CA:FALSE Netscape Comment: OpenSSL Generated Certificate X509v3 Subject Key Identifier: F9:DB:00:04:8A:D7:17:C8:21:B7:2D:15:F2:E9:89:66:BB:6D:D5:F9 X509v3 Authority Key Identifier: keyid:98:56:B3:30:B0:9D:75:A1:69:AD:BF:2F:E4:0D:FE:3F:17:87:B0:A8Certificate is to be certified until Mar 29 14:07:23 2017 GMT (1000 days) Sign the certificate? [y/n]:y #询问是否签署证书1 out of 1 certificate requests certified, commit? [y/n]y Write out database with 1 new entries Data Base Updated [root@localhost CA]# ls /etc/httpd/ssl #证书已签署，自建CA到这里就成功了httpd.crt httpd.csr httpd.key 发送给请求者 之后，只要把签署的证书发回给申请者就行了！]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac上基于GitHub Page+Hexo 搭建个人博客]]></title>
    <url>%2F2017%2F06%2F16%2FMac%E4%B8%8A%E5%9F%BA%E4%BA%8EGitHub-Page-Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[之前一直在博客园写博客，但不太喜欢博客园的编辑器，而且博客园对markdown的支持不太好。之后找到个很好用的markdown编辑器 MWeb，本地编辑完，发布到博客园，经常出现格式混乱的情况，markdown的渲染效果也不好看。 由于本人很喜欢用markdown语法写博客，，一直寻求能很好支持markdown语法而且能方便使用MWeb编辑器的博客。 然后找到一种很方便地搭建私人博客的方案：hexo + next，而且后续想要自定义修改博客样式也是很方便的。 安装hexo + next 的搭建，网上有很多博文写得很详细，这里就不介绍。next 主题的基本配置，可以参照官方文档 这里主要说下，自己博客的自定义样式修改。 自定义修改修改包括两种方法： 直接修改源码 自定义样式 修改背景色1）修改源代码修改背景色，包括两部分：头部、脚部的颜色和主体的颜色。 在基本配置文件 themes/next/source/css/_variables/base.styl 中增加 $header-bgex 和 $body-bgex 两个颜色变量。 12$header-bgex = #f5f5d5$body-bgex = #f5f5d5 同时主体背景颜色的修改，在 base.styl 中修改 $body-bg-color 的值： 12// Background color for &lt;body&gt;$body-bg-color = $body-bgex 修改 themes/next/source/css/_schemes/Mist/sidebar/_header.styl 文件中头部的背景色为 base.styl 定义的背景色 1.header &#123; background: $header-bgex; &#125; 修改 themes/next/source/css/_schemes/Mist/index.styl 中footer相关定义，可以修改footer颜色值 12345678// Footer// --------------------------------------------------.footer &#123; margin-top: 80px; padding: 10px 0; background: $header-bgex; color: $grey-dim;&#125; 如果修改配置，发现没生效： 12# hexo clean# hexo g 2）自定义样式一般不推荐直接修改源码。next主题默认自带自定义的样式文件 custom.styl ，直接在这些文件修改就可以生效。 修改主体背景色，打开 themes/next/source/css/_variables/custom.styl ，加入： 123456//增加两种背景色$header-bgex = #f5f5d5$body-bgex = #f5f5d5// 修改主体背景色$body-bg-color = $body-bgex 修改头部和脚部的背景色，打开 themes/next/source/css/_custom/custom.styl，加入： 12345678910// 修改头部背景色.header &#123; background: $header-bgex; &#125;// 修改脚部背景色.footer &#123; margin-top: 80px; padding: 10px 0; background: $header-bgex; color: $grey-dim;&#125; 修改代码块的背景色next主题提供了五种代码高亮的配色方案：normal、night、night eighties、night blue、night bright 查看next主题的配置文件 themes/next/_config.yml ，可知当前使用的配色方案是 normal 1highlight_theme: normal 打开 themes/next/source/css/_common/components/highlight/theme.styl ，找到 $highlight_theme == &quot;normal&quot; 的那一项，修改： 12if $highlight_theme == &quot;normal&quot; $highlight-background = #F5F2F0 修改代码块圆角1）直接修改源码修改 themes/next/source/css/_common/components/highlight/highlight.styl 中highlight类选择器的 border-radius 变量 123.highlight &#123; border-radius: 20px&#125; 2）自定义样式修改代码块的圆角，打开 themes/next/source/css/_custom/custom.styl，加入： 1234// 修改代码块圆角.highlight &#123; border-radius: 12px&#125; 修改代码块边框自定义样式修改，打开 themes/next/source/css/_custom/custom.styl，加入： 修改长代码块边框 1234// 修改代码块的边框：大小、颜色.highlight, pre &#123; border: 5px solid #E0DFCC;&#125; 修改短代码块边框 1234// 修改代码块的边框：大小、颜色code &#123; border: 1px solid #E0DFCC;&#125; 头像变圆形并且鼠标放上去会旋转主要是修改 themes\next\source\css\_common\components\sidebar\sidebar-author.styl 文件，以下是我的配置文件内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ -webkit-animation: play 2s ease-out 1s 1; -moz-animation: play 2s ease-out 1s 1; animation: play 2s ease-out 1s 1; /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.5s ease-out; -moz-transition: -moz-transform 1.5s ease-out; transition: transform 1.5s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 */ -webkit-animation-play-state:paused; animation-play-state:paused; /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125;.site-author-name &#123; margin: $site-author-name-margin; text-align: $site-author-name-align; color: $site-author-name-color; font-weight: $site-author-name-weight;&#125;.site-description &#123; margin-top: $site-description-margin-top; text-align: $site-description-align; font-size: $site-description-font-size; color: $site-description-color;&#125; 主页文章添加阴影边框自定义样式修改，打开 themes/next/source/css/_custom/custom.styl，加入： 12345678// 主页文章添加阴影效果.post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 修改文章底部带#号的标签为图标文章底部带#号的标签，比如 #NexT，可以把#换成图标。修改模板 themes/next/layout/_macro/post.swig ，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成 &lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;，重启 hexo 服务生效。 取消文章末尾横线自定义样式修改，打开 themes/next/source/css/_custom/custom.styl，加入： 1234//取消文章末尾横线.post-nav &#123; border: none;&#125; 修改首页阅读全文按钮样式自定义样式修改，打开 themes/next/source/css/_custom/custom.styl，加入： 1234567891011121314151617181920//首页阅读全文按钮样式.post-button &#123; margin-top: 30px; text-align: center;&#125;.post-button .btn &#123; color: #fff; font-size: 15px; background: #686868; border-radius: 16px; line-height: 2; margin: 0 4px 8px 4px; padding: 0 20px;&#125;.post-button a&#123; border-bottom: 1px solid #666;&#125;.post-button a:hover &#123; color: #7784ba;&#125; 修改首页尾部样式自定义样式修改，打开 themes/next/source/css/_custom/custom.styl，加入： 12345678910//首页尾部样式.footer &#123; background: none; font-size: 16px;&#125;.footer-inner &#123; font-family: &apos;Comic Sans MS&apos;, sans-serif; text-align: center; color: #555555;&#125; 文字居中，文字颜色：#555555，字体大小：16px 修改侧边栏样式自定义样式修改，打开 themes/next/source/css/_custom/custom.styl，加入： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//侧边栏信息样式修改.site-author-name &#123; margin: 48px 0 0; color: #090909; font-family: &apos;Comic Sans MS&apos;, sans-serif;&#125;.links-of-blogroll &#123; font-size: 14px; margin-bottom: 42px;&#125;.links-of-author &#123; margin-top: 30px; margin-bottom: 58px;&#125;.sidebar-inner &#123; color: #649ab6;&#125;.sidebar &#123; box-shadow: inset 2px 2px 40px #bdb2b2; background: #F5F2F0;&#125;.sidebar a &#123; color: #649ab6; border-bottom-color: #649ab6; border-bottom: none;&#125;.sidebar a:hover &#123; color: #0c0b0b;&#125;.site-state-item &#123; display: inline-block; padding: 8px 28px; border-left: 1px solid #649ab6;&#125;.sidebar-nav .sidebar-nav-active &#123; color: #649ab6; border-bottom-color: #649ab6;&#125;.sidebar-nav li:hover &#123; color: #0c0b0b;&#125;/*.post-toc .nav .active &gt; a &#123; color: #4f7e96;&#125;*/.post-toc ol a &#123; color: #2B2B2B;&#125; 修改首页和归档分页文章篇数1per_page: 10 hexo 站点配置文件 _config.yml 中的这个配置，控制了所有的分页配置，包括首页、归档页、tag分类页面。如果我们想对这三个页面做独立的配置，需要安装插件进行功能支持。 hexo-generator-index hexo-generator-archive hexo-generator-tag 在hexo根目录下安装插件 123# npm install hexo-generator-archive --save# npm install hexo-generator-index --save# npm install hexo-generator-tag --save 在站点配置文件 _config.yml中添加： 12345678index_generator: per_page: 10 //首页分页数量archive_generator: per_page: 15 //归档页分页数量，为0时表示不分页全展示 yearly: true //按年生成归档 monthly: true //按月生成归档tag_generator: per_page: 10 添加LiveRe评论支持在 NexT 主题的最新版本中，支持多款评论系统： Disqus，Facebook Comments，HyperComments，网易云跟帖，LiveRe。 对于评论插件，能免费使用的： 多说：之前是最多用户使用的评论。可惜于2017年6月1日关闭了。 Disqus：国外使用较多的评论插件。但对于国内用户来说，时常加载不出来。 网易云跟帖：网易提供的评论差价，功能比较简单，性能优秀，可惜步多说后尘，于2017年8月1日停止服务了。 畅言：搜狐提供的评论插件，功能丰富，体验不错。但域名必须进行ICP备案。 友言：相对比较小众，功能比较简单，体验蛮不错的。 LiveRe：音译为来必力，是韩国的一款评论插件，拥有和多说类似的功能，非常美观，目前服务稳定。 本来想用友言的，但看了它的 谁在使用友言 ，好多都是死链接，担心不久也会挂掉，也就放弃了。况且它接入的社交平台很少，只有QQ、微博、人人、开心网。于是决定选用 LiveRe。 配置LiveRe评论插件进入 LiveRe，注册账号。安装City版，获取 uid。填写完成后，进入到 管理页面 -&gt; 代码管理 -&gt; 一般网站 代码中，data-uid 即为所需 uid。编辑主题配置文件 _config.yml，填写 livere_uid ： 1livere_uid: #your livere_uid Hexo新建文章时自动打开编辑器Hexo 新建博客： 12# cd hexo_blog# hexo new &quot;The title of your blog&quot; 此命令会在Hexo根目录的source/_posts/下自动创建相应的md文件。然后我们找到这个目录下的文件，用编辑器打开即可。但当博文比较多的时候，每次要从成堆md文件里找到刚刚自动生成的新md文件，是一件比较麻烦的事。 查看Hexo的Github项目时，发现有遇到类似问题的issue，Hexo作者也给出了解决方法： 在Hexo根目录的scripts目录（若没这目录，则新建一个）中创建一个JS脚本文件(文件名自定义，如：auto_open_editor.js)。 通过这个脚本，用其来监听hexo new这个动作，并在检测到hexo new之后，执行编辑器打开的命令。 由于用的是Mac系统，本地安装的Hexo版本是3.3.7，用的MarkDown编辑器是MWeb，绝对路径是/Applications/MWeb.app，根据Hexo作者给出的解决方法，应该将以下内容写入该JS脚本： 12345var exec = require(&apos;child_process&apos;).exec;// Hexo 3 用户复制这段hexo.on(&apos;new&apos;, function(data)&#123; exec(&apos;open -a &quot;/Applications/MWeb.app&quot; &apos; + data.path);&#125;); 这样，每当我们用hexo new命令新建文章时，MarkDown编辑器就会自动打开刚刚新建的md文件，很方便。 参考文档：Hexo搭建博客教程hexo之next主题优化整理hexo的next主题个性化教程:打造炫酷网站2017年最新基于hexo搭建个人免费博客——自定义页面样式一Hexo+NexT主题配置备忘基于Hexo搭建个人博客——进阶篇(从入门到入土)]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运维安全配置]]></title>
    <url>%2F2017%2F06%2F16%2F%E8%BF%90%E7%BB%B4%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Nginx安全1、隐藏Nginx版本号在 nginx.conf 的 http 段中加入： 1server_tokens off; 修改 fastcgi.conf: 1234找到：fastcgi_param SERVER_SOFTWARE nginx/$nginx_version;改为：fastcgi_param SERVER_SOFTWARE nginx; 2、禁用目录列出在 http 段中加入： 1autoindex off; 3、禁止不安全的HTTP方法（如DELETE、HEAD、TRACE、OPTIONS）在对应server段修改：( if 不能用于http段) 123if ($request_method !~ ^(GET|POST)$) &#123; return 403;&#125; 4、缩减权限缩减日志、配置文件的权限，不能让无关用户访问到指定普通用户作为Nginx服务的启动用户 5、禁止特定IP访问5.1、没有挂CDN在 conf 目录新建 blockips.conf： 12deny xxx.xxx.xxx.xxx;deny xxx.xxx.0.0/16; 在 http 段添加： 1include blockips.conf; 集中在 blockips.conf 禁止IP 5.2、挂上CDNhttp 段中添加： 12345# 获取用户真实IP(x_forwarded_for的第一个IP)，并赋值给变量$clientRealIPmap $http_x_forwarded_for $clientRealIp &#123; &quot;&quot; $remote_addr; ~^(?P&lt;firstAddr&gt;[0-9\.]+),?.*$ $firstAddr;&#125; 对应的 server 段中添加： 12345# 如果匹配了真实IP，那么返回403if ($clientRealIp ~* &quot;xxx.xxx.xxx.xxx&quot;) &#123; return 403; break;&#125; 6、限制蜘蛛抓取频率http 段配置： 1limit_req_zone $anti_spider zone=anti_spider:60m rate=200r/m; 某个server段： 12345limit_req zone=anti_spider burst=5 nodelay;if ($http_user_agent ~* &quot;baiduspider|bingbot|Yahoo! Slurp|msnbot&quot;) &#123; set $anti_spider $http_user_agent;&#125; 参数说明: 1234linit_req_zone 中的rate=200r/m 表示每分钟只能处理200个请求。limit_req 中的burst=5 表示允许超过频率限制的请求数不多于5个limit_req 中的nodelay 表示当已经达到burst值时，再来新请求时，直接返回503IF部分 用于匹配蜘蛛名。匹配上，则对变量$anti_spider赋值，使得限制规则生效。 7、禁止特定UA访问在 conf 目录中，新建 agent_deny.conf： 12345678910111213141516# 禁止特定UA访问# ~ &quot;Lua&quot; ：表示用户UA匹配&quot;Lua&quot;字符串，区分大小写# 当用户UA被匹配成功，则返回403错误，不给予访问。if ($http_user_agent ~ &quot;Lua&quot;)&#123; return 403;&#125;# 禁止Scrapy等工具的抓取if ($http_user_agent ~* (Scrapy|Curl|HttpClient)) &#123; return 403;&#125;# 禁止空agent访问if ($http_user_agent ~ ^$) &#123; return 403;&#125; 在相应的 server 或 location 段添加：( if 不能用于http段) 1include agent_deny.conf; 8、既禁止UA为空的访问，又要放行内网ip不做禁止nginx的配置中不支持if条件的 逻辑与、逻辑或 的运算 ，并且不支持if的嵌套语法，但我们可以使用变量达到想要的效果。 12345678910111213141516#白名单：192.168.1#禁止UA为空的访问set $flag 0;if ($remote_addr !~ &quot;^(192.168.1)&quot;)&#123; set $flag &quot;$&#123;flag&#125;1&quot;;&#125;if ($http_user_agent ~ &quot;^$&quot;)&#123; set $flag &quot;$&#123;flag&#125;2&quot;;&#125;if ($flag = &quot;012&quot;)&#123; return 403;&#125; 注意：以下的写法是错误的！ 123if ($remote_addr !~ &quot;^(192.168.1)&quot; &amp;&amp; $http_user_agent ~ &quot;^$&quot;) &#123; return 403; &#125; php-fpm安全1、隐藏php-fpm版本编辑php.ini，修改或加入： 1expose_php = Off 2、php 安全设置 禁用特定函数 编辑php.ini，修改： 1disable_functions=dl,eval,assert,exec,popen,system,passthru,shell_exec,escapeshellarg,escapeshellcmd,proc_close,proc_open 关闭错误信息输出 在生产环境中，应该关闭在网页上显示错误信息，改为用错误日志记录 1display_errors = Off]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iF.svnadmin 安装遇到的坑]]></title>
    <url>%2F2017%2F06%2F16%2FiF-svnadmin-%E5%AE%89%E8%A3%85%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[成功搭建了iF.svnadmin，但在使用过程中出现了莫名其妙的问题。 版本：iF.svnadmin 1.6.2配置文件：/etc/httpd/conf.d/subversion.conf 123456789101112LoadModule dav_svn_module modules/mod_dav_svn.soLoadModule authz_svn_module modules/mod_authz_svn.so &lt;Location /svn&gt; DAV svn SVNParentPath /home/svn AuthType Basic AuthName &quot;Restricted Access&quot; AuthUserFile /home/svnconfig/passwdfile AuthzSVNAccessFile /home/svnconfig/accessfile Require valid-user&lt;/Location&gt; /home/svn 目录及其子目录 的属主、属组 都改为了 apache 访问： http://192.168.1.35:8088/svn/test_svn 输入用户和密码，报403错误： 百思不得其解啊！！！ 后来，查apache的错误日志，有如下记录： 1[Tue May 31 18:09:10.413997 2016] [authz_svn:error] [pid 19001] [client 192.168.1.202:60352] Failed to load the AuthzSVNAccessFile: An authz rule refers to group &apos;@&apos;, which is undefined 查看/home/svnconfig/accessfile ： 123456[groups]web=test_svn [test_svn:/]@test_svn=rw@= 终于找到错误了。 /home/svnconfig/accessfile 本来是空文件，里边的配置都由iF.svnadmin 负责配置，结果发现它配置错了。“@=” 不能这么配置的，apapche会无法识别的，会认为有group没有定义。 解决方法： 12删除 @= 这一行重启httpd 如果你遇到这种奇怪的情况：已经将某用户加入了用户组，也设置了该用户组对某项目的管理权限，但是该用户还是没有权限访问。 可以去查下apache的错误日志和/home/svnconfig/accessfile 文件，看看是不是也是因为上述原因引起的。 参考文档：iF.svnadmin官网安装配置iF.svnadmin]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
      <tags>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php扩展模块安装过程]]></title>
    <url>%2F2017%2F06%2F16%2Fphp%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[简介安装php模块，不需要重新编译php，可以动态扩展php模块。 例子以安装msgpack模块为例：（此处php5.6是编译安装的） 1、下载msgpack模块源码包1wget http://pecl.php.net/get/msgpack-0.5.7.tgz 2、解压，进入源码目录12tar zxvf msgpack-0.5.7.tgzcd msgpack-0.5.7 3、源码包是没有configure文件的，需要运行phpize 来生成configure文件1/usr/local/php/bin/phpize 4、编译安装根据编译目录确定php-config的路径，不一定是在/usr/local/php目录下。 1234# ./configure --with-php-config=/usr/local/php/bin/php-config # make# make installInstalling shared extensions: /usr/local/php/lib/php/extensions/no-debug-non-zts-20131226/ 根据上边提示，可知扩展模块存放的目录：/usr/local/php/lib/php/extensions/no-debug-non-zts-20131226/ 5、让msgpack模块生效在php.ini中加入： 1extension=msgpack.so 重启php-fpm服务 6、查看msgpack模块是否生效php -m ：查看php安装了哪些模块 12# /usr/local/php/bin/php -m |grep msgpackmsgpack]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在centos6.5上升级php-libxml版本到2.9.0]]></title>
    <url>%2F2017%2F06%2F16%2F%E5%9C%A8centos6-5%E4%B8%8A%E5%8D%87%E7%BA%A7php-libxml%E7%89%88%E6%9C%AC%E5%88%B02-9-0%2F</url>
    <content type="text"><![CDATA[需求应开发的需求，线上环境，php-libxml版本升级到2.8以上。 软件版本说明当前系统，各软件版本： 12345php 5.6.15libxml 2.7.6glibc 2.12zlib 1.2.3xz-libs 4.999.9 升级步骤1、安装工具集12yum groupinstall -y &apos;development tools&apos;yum install kernel-headers -y 2、解决安装libxml2-1.9.0版本时，遇到的依赖关系1）升级glibc版本 （ 版本 &gt; glibc-2.12 ）centos6系统，官方支持升级的最高版本是glibc-2.12（即yum升级支持的最高版本）。 123456wget http://ftp.redsleeve.org/pub/steam/glibc-2.15-60.el6.x86_64.rpmwget http://ftp.redsleeve.org/pub/steam/glibc-devel-2.15-60.el6.x86_64.rpmwget http://ftp.redsleeve.org/pub/steam/glibc-common-2.15-60.el6.x86_64.rpmwget http://ftp.redsleeve.org/pub/steam/glibc-headers-2.15-60.el6.x86_64.rpmrpm -Uvh glibc-2.15-60.el6.x86_64.rpm glibc-devel-2.15-60.el6.x86_64.rpm glibc-common-2.15-60.el6.x86_64.rpm glibc-headers-2.15-60.el6.x86_64.rpm 查看当前系统安装了glibc哪些包，以及最高支持版本： 12345678910111213141516171819202122232425# rpm -qa |grep glibcglibc-2.15-60.el6.x86_64glibc-common-2.15-60.el6.x86_64glibc-devel-2.15-60.el6.x86_64glibc-headers-2.15-60.el6.x86_64# strings /lib64/libc.so.6 | grep GLIBCGLIBC_2.2.5GLIBC_2.2.6GLIBC_2.3GLIBC_2.3.2GLIBC_2.3.3GLIBC_2.3.4GLIBC_2.4GLIBC_2.5GLIBC_2.6GLIBC_2.7GLIBC_2.8GLIBC_2.9GLIBC_2.10GLIBC_2.11GLIBC_2.12GLIBC_2.13GLIBC_2.14GLIBC_2.15GLIBC_PRIVATE 2）升级zlib版本 ( 版本 &gt;= zlib-1.2.5 )centos6系统，官方支持升级的最高版本是zlib-1.2.5。（即yum升级支持的最高版本） 12345wget http://ftp5.gwdg.de/pub/opensuse/repositories/home:/codice:/mono-redhat/CentOS_CentOS-6/x86_64/zlib-1.2.5-codice.4.1.x86_64.rpmwget http://ftp5.gwdg.de/pub/opensuse/repositories/home:/codice:/mono-redhat/CentOS_CentOS-6/x86_64/zlib-devel-1.2.5-codice.4.1.x86_64.rpmwget http://ftp5.gwdg.de/pub/opensuse/repositories/home:/codice:/mono-redhat/CentOS_CentOS-6/x86_64/zlib-static-1.2.5-codice.4.1.x86_64.rpmrpm -Uvh zlib-1.2.5-codice.4.1.x86_64.rpm zlib-devel-1.2.5-codice.4.1.x86_64.rpm zlib-static-1.2.5-codice.4.1.x86_64.rpm 3）python2.7支持centos6.5中，官方默认的Python版本为2.6。要装2.7版本，需要修改yum源。 12345yum install epel-release -y wget https://centos6.iuscommunity.org/ius-release.rpmrpm -ivh ius-release.rpmyum clean all yum install python27 -y 4）升级xz-libs版本 ( 版本 &gt; xz-libs-4.9 )centos6.5，官方yum升级的最高版本是4.999.9 1234567wget http://ftp.redsleeve.org/pub/steam/xz-libs-5.0.5-1.el6.x86_64.rpmwget http://ftp.redsleeve.org/pub/steam/xz-devel-5.0.5-1.el6.x86_64.rpmwget http://ftp.redsleeve.org/pub/steam/xz-5.0.5-1.el6.x86_64.rpmwget http://ftp.redsleeve.org/pub/steam/xz-lzma-compat-5.0.5-1.el6.x86_64.rpmwget http://ftp.redsleeve.org/pub/steam/xz-compat-libs-5.0.5-1.el6.x86_64.rpmrpm -Uvh xz-libs-5.0.5-1.el6.x86_64.rpm xz-devel-5.0.5-1.el6.x86_64.rpm xz-5.0.5-1.el6.x86_64.rpm xz-lzma-compat-5.0.5-1.el6.x86_64.rpm xz-compat-libs-5.0.5-1.el6.x86_64.rpm 3、升级libxml212345wget http://xmlsoft.org/sources/libxml2-devel-2.9.0-0rc0.x86_64.rpmwget http://xmlsoft.org/sources/libxml2-2.9.0-0rc0.x86_64.rpmwget http://xmlsoft.org/sources/libxml2-python-2.9.0-0rc0.x86_64.rpmrpm -Uvh libxml2-2.9.0-0rc0.x86_64.rpm libxml2-devel-2.9.0-0rc0.x86_64.rpm libxml2-python-2.9.0-0rc0.x86_64.rpm 4、重新编译php需要重新编译php，使升级的php-libxml生效。 进入php5.6.15的源码目录，重新编译php： 123# cd php-5.6.15# ./configure --prefix=/usr/local/php --with-config-file-path=/usr/local/php/etc --enable-fpm --enable-bcmath=shared --with-pdo_sqlite --with-gettext=shared --with-iconv --enable-ftp=shared --with-sqlite --with-sqlite3 --enable-mbstring=shared --enable-sockets=shared --enable-zip --enable-soap=shared --with-openssl --with-zlib --with-curl=shared --with-gd=shared --with-jpeg-dir --with-png-dir --with-freetype-dir --with-mcrypt=shared --with-mhash=shared --enable-opcache --with-mysql=mysqlnd --with-mysqli=shared,mysqlnd --with-pdo-mysql=shared,mysqlnd --without-pear --with-libdir=lib64 --disable-fileinfo # make 替换生成的php、php-cgi程序文件: 123456# /etc/init.d/php-fpm stop# mv /usr/local/php/bin/php /usr/local/php/bin/php.bak# mv /usr/local/php/bin/php-cgi /usr/local/php/bin/php-cgi.bak# cp -a sapi/cli/php /usr/local/php/bin/# cp -a sapi/cgi/php-cgi /usr/local/php/bin/# /etc/init.d/php-fpm start 查看php-libxml版本升级是否生效： 1234# /usr/local/php/bin/php -i|grep libxmllibxml Version =&gt; 2.9.0libxmllibxml2 Version =&gt; 2.9.0 后续补充 开启phpinfo访问，发现libxml版本仍是2.7.6。上述替换php、php-cgi程序的方法，是不能使得php-libxml版本升级生效的。 需要重新编译安装php（不同安装目录），才会生效。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于docker搭建mycat读写分离架构]]></title>
    <url>%2F2017%2F06%2F15%2F%E5%9F%BA%E4%BA%8Edocker%E6%90%AD%E5%BB%BAmycat%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[前言最近在学docker，应业务需求，要研究mycat的使用，为了方便学习测试，就想着用docker的镜像和容器来构造所有的组件。 mysql主从架构搭建创建总目录： 12mkidr mycat-mscd mycat-ms 在宿主机创建本地目录，印射为容器的数据目录，方便以后查看数据内容。 1mkdir mysql-ms/data/&#123;master,slave&#125; -p 在宿主机创建配置文件，印射为容器的配置文件。可通过本地修改配置文件，达到修改容器配置文件的效果。 master配置文件： mysql-ms/etc/master.cnf 123456789[mysqld]# 开启logbinlog-bin = mysql-binbinlog_format = mixed# 设置唯一服务ID,要跟slave不同server-id=1datadir = /var/lib/mysql slave 配置文件： mysql-ms/etc/slave.cnf 123456789101112[mysqld]# 开启log-binlog-bin = mysql-binbinlog_format = mixed# 开启relay-logrelay-log = mysql-relay# 设置唯一服务ID,要跟master不同server-id = 3datadir = /var/lib/mysql 创建网络mscat，用于各容器之间通信 1docker network create mscat 分别启动master、slave容器(用的是docker官方提供的 mysql5.6.36 的镜像) 12docker run --name mysql-master -v $PWD/mysql-ms/etc/master.cnf:/etc/mysql/my.cnf -v $PWD/mysql-ms/data/master:/var/lib/mysql --net=mscat -e MYSQL_ROOT_PASSWORD=&apos;yueioe123&apos; -d mysql:5.6.36docker run --name mysql-slave -v $PWD/mysql-ms/etc/slave.cnf:/etc/mysql/my.cnf -v $PWD/mysql-ms/data/slave:/var/lib/mysql --net=mscat -e MYSQL_ROOT_PASSWORD=&apos;yueioe123&apos; -d mysql:5.6.36 master上，创建主从复制账号： 1docker exec -ti mysql-master mysql -uroot -p&apos;yueioe123&apos; -e &quot;CREATE USER &apos;repl&apos;@&apos;%&apos; IDENTIFIED BY &apos;repl123&apos;;GRANT REPLICATION SLAVE ON *.* TO &apos;repl&apos;@&apos;%&apos;;&quot; 在master上，获取复制开始的二进制文件和位置(File和Position) 1234567# docker exec -ti mysql-master mysql -uroot -p&apos;yueioe123&apos; -e &quot;show master status\G&quot; *************************** 1. row *************************** File: mysql-bin.000005 Position: 441 Binlog_Do_DB: Binlog_Ignore_DB:Executed_Gtid_Set: 在slave上，连接master: 1234# 连接masterdocker exec -it mysql-slave mysql -uroot -p&apos;&apos; -e &quot;CHANGE MASTER TO MASTER_HOST=&apos;mysql-master&apos;,MASTER_USER=&apos;repl&apos;,MASTER_PASSWORD=&apos;repl123&apos;,MASTER_LOG_FILE=&apos;mysql-bin.000005&apos;,MASTER_LOG_POS=441;&quot;# 启动 slave 线程docker exec -it mysql-slave mysql -uroot -pyueioe123 -e &quot;start slave;&quot; 查看主从是否成功: 123456789101112# docker exec -it mysql-slave mysql -uroot -pyueioe123 -e &quot;show slave status\G&quot;Slave_IO_Running: YesSlave_SQL_Running: Yes# docker exec -ti mysql-master mysql -uroot -pyueioe123 -e &quot;create database test;&quot;# docker exec -ti mysql-slave mysql -uroot -pyueioe123 -e &quot;show databases;&quot;+--------------------+| Database |+--------------------+| information_schema || test |+--------------------+ mycat读写分离mycat是用java语言编写的，需要jdk的支持，这次将安装mycat1.6，jdk版本需要1.7以上]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>mycat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 6.5下部署日志服务器 Rsyslog+LogAnalyzer+MySQL]]></title>
    <url>%2F2017%2F06%2F15%2FCentOS-6-5%E4%B8%8B%E9%83%A8%E7%BD%B2%E6%97%A5%E5%BF%97%E6%9C%8D%E5%8A%A1%E5%99%A8-Rsyslog-LogAnalyzer-MySQL%2F</url>
    <content type="text"><![CDATA[简介LogAnalyzer 是一款syslog日志和其他网络事件数据的Web前端。它提供了对日志的简单浏览、搜索、基本分析和一些图表报告的功能。数据可以从数据库或一般的syslog文本文件中获取，所以LogAnalyzer不需要改变现有的记录架构。基于当前的日志数据，它可以处理syslog日志消息，Windows事件日志记录，支持故障排除，使用户能够快速查找日志数据中看出问题的解决方案。 LogAnalyzer 获取客户端日志会有两种保存模式，一种是直接读取客户端/var/log/目录下的日志并保存到服务端该目录下，一种是读取后保存到日志服务器数据库中，推荐使用后者。 LogAnalyzer 采用php开发，日志服务器需要php的运行环境，本文采用LNMP。 系统环境服务端： 1234567Rsyslog Server OS: CentOS6.5Rsyslog Server OS: 192.168.1.200Rsyslog 版本：rsyslog-5.8.10-10.el6_6.x86_64LogAnalyzer 版本: loganalyzer-4.1.5LNMP 版本：nginx1.8.0 + php5.6.29 + mysql 5.7.17SELinux 关闭iptables 打开 客户端： 12Rsyslog Client OS: CentOS6.5Rsyslog Client OS: 192.168.1.201 安装LNMP环境此处省略 服务端软件安装和配置软件安装：rsyslog和rsyslog-mysql检查是否按照rsyslog软件（系统会默认安装） 1# rpm -qa|grep rsyslog 安装模块rsyslog-mysql(负责将日志传送到MySQL)： 1# yum install rsyslog-mysql -y rsyslog配置1、导入rsyslog-mysql自带的sql文件 1# mysql -uroot -p &lt; /usr/share/doc/rsyslog-mysql-5.8.10/createDB.sql createDB.sql文件的内容：(创建Syslog数据库，并创建空表SystemEvents和SystemEventsProperties) 12345678910111213141516171819202122232425262728293031323334353637CREATE DATABASE Syslog;USE Syslog;CREATE TABLE SystemEvents( ID int unsigned not null auto_increment primary key, CustomerID bigint, ReceivedAt datetime NULL, DeviceReportedTime datetime NULL, Facility smallint NULL, Priority smallint NULL, FromHost varchar(60) NULL, Message text, NTSeverity int NULL, Importance int NULL, EventSource varchar(60), EventUser varchar(60) NULL, EventCategory int NULL, EventID int NULL, EventBinaryData text NULL, MaxAvailable int NULL, CurrUsage int NULL, MinUsage int NULL, MaxUsage int NULL, InfoUnitID int NULL , SysLogTag varchar(60), EventLogType varchar(60), GenericFileName VarChar(60), SystemID int NULL);CREATE TABLE SystemEventsProperties( ID int unsigned not null auto_increment primary key, SystemEventID int NULL , ParamName varchar(255) NULL , ParamValue text NULL); 2、创建访问Syslog数据库的账号并分配权限 12mysql&gt; grant all privileges on `Syslog`.* to &apos;rsyslog&apos;@&apos;localhost&apos; identified by &apos;abc123456&apos;;mysql&gt; flush privileges; 3、配置服务端支持rsyslog-mysql模块 123# vim /etc/rsyslog.conf$ModLoad ommysql*.* :ommysql:localhost,Syslog,rsyslog,abc123456 说明：ommysql表示装载的模块名，Syslog表示数据库名，rsyslog表示用户，abc123456是密码配置支持rsyslog-mysql模块，rsyslog会将新产生的日志信息自动传到MySQL中保存4、开启相关日志模块，并开启UDP服务端口获取内网内其他linux系统日志 1234# vim /etc/rsyslog.conf$ModLoad immark #immark是模块名，支持日志标记$ModLoad imudp #imupd是模块名，支持udp协议$UDPServerRun 514 #允许514端口接收使用UDP和TCP协议转发过来的日志 5、重启rsyslog服务，让配置生效 1# /etc/init.d/rsyslog restart 6、开启iptables规则开放514端口，仅限内网访问 1234# vim /etc/sysconfig/iptables-A INPUT -s 192.168.1.0/24 -p tcp -m tcp --dport 514 -j ACCEPT-A INPUT -s 192.168.1.0/24 -p udp -m udp --dport 514 -j ACCEPT# /etc/init.d/iptables restart 客户端配置1、检查rsyslog是否安装 1# rpm -qa|grep rsyslog 2、配置rsyslog客户端发送本地日志到服务端 12# vim /etc/rsyslog.conf*.* @192.168.1.200 服务端地址：192.168.1.2003、重启服务 1# /etc/init.d/rsyslog restart 4、将客户端用户的history写入到系统日志，用于审计用户登录操作用户登录操作被写入系统日志/var/log/messages中 123# vim /etc/bashrcexport PROMPT_COMMAND=&apos;&#123; msg=$(history 1 | &#123; read x y; echo $y; &#125;);logger &quot;[euid=$(whoami)]&quot;:$(who am i):[`pwd`]&quot;$msg&quot;; &#125;&apos;# source /etc/bashrc 说明： 1、PROMPT_COMMAND 是bash的环境变量，变量值会作为普通bash命令执行，执行时间是在bash显示prompt之前。2、” msg=\$(history 1 | { read x y; echo $y; }) “ 。在prompt显示之前，执行history 1 ，总会获取最后一次执行的命令，通过read命令过滤掉历史ID。msg变量的值就是执行的命令。3、logger 是一个shell 命令接口，可以通过该接口使用Rsyslog的系统日志模块，还可以从命令行直接向系统日志文件写入一行信息。 测试server端是否正常接收client端的日志client 端测试： 1234[test@server ~]$ pwd[test@server ~]$ whoami[test@server ~]$ id[test@server ~]$ ls 查看server端的messages日志： 12345# tail -f /var/log/messagesJun 9 17:57:52 server test: [euid=test]:test pts/1 2017-06-09 17:43 (217.11.57.227):[/home/test]pwdJun 9 17:57:53 server test: [euid=test]:test pts/1 2017-06-09 17:43 (217.11.57.227):[/home/test]whoamiJun 9 17:57:54 server test: [euid=test]:test pts/1 2017-06-09 17:43 (217.11.57.227):[/home/test]idJun 9 17:58:02 server test: [euid=test]:test pts/1 2017-06-09 17:43 (217.11.57.227):[/home/test]ls 安装配置LogAnalyzer1、软件安装 123456789# wget http://download.adiscon.com/loganalyzer/loganalyzer-4.1.5.tar.gz# tar zxvf loganalyzer-4.1.5.tar.gz# cd loganalyzer-4.1.5# mkdir /home/www/loganalyzer# mv src/* /home/www/loganalyzer # chmod +x contrb/configure.sh# cp -a contrb/configure.sh /home/www/loganalyzer/# cd /home/www/loganalyzer/# ./configure.sh; rm -f configure.sh 在Nginx上配置域名访问，根目录为/home/www/loganalyzer2、在浏览器安装向导中安装LogAnalyzer 测试LogAnalyzer的使用]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>rsyslog</tag>
        <tag>审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F06%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>