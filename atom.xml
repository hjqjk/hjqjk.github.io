<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hjqjk&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-09-30T02:45:35.234Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>hjqjk</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>日常记错</title>
    <link href="http://yoursite.com/2017/Record-the-error-daily.html"/>
    <id>http://yoursite.com/2017/Record-the-error-daily.html</id>
    <published>2017-09-29T03:21:36.000Z</published>
    <updated>2017-09-30T02:45:35.234Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SSH连接报错"><a href="#SSH连接报错" class="headerlink" title="SSH连接报错"></a>SSH连接报错</h2><p>SSH连接服务器，出现报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># ssh root@xxx.xxx.xxx.xxx </div><div class="line">setsockopt SO_KEEPALIVE: Invalid argument</div><div class="line">write: Broken pipe</div></pre></td></tr></table></figure><p>经过检查，发现是自己的Mac电脑更新系统（MacOS High Sierra），导致电脑中的 SSH 客户端程序坏了，需要重新安装 SSH 客户端。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;SSH连接报错&quot;&gt;&lt;a href=&quot;#SSH连接报错&quot; class=&quot;headerlink&quot; title=&quot;SSH连接报错&quot;&gt;&lt;/a&gt;SSH连接报错&lt;/h2&gt;&lt;p&gt;SSH连接服务器，出现报错：&lt;/p&gt;
&lt;figure class=&quot;highlight
        
      
    
    </summary>
    
      <category term="技术杂项" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="ssh" scheme="http://yoursite.com/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>Docker下快速部署ownCloud</title>
    <link href="http://yoursite.com/2017/Docker-deploy-ownCloud.html"/>
    <id>http://yoursite.com/2017/Docker-deploy-ownCloud.html</id>
    <published>2017-09-15T09:23:27.000Z</published>
    <updated>2017-09-27T09:38:05.892Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>相信大家都用过网盘，比如国外有 <a href="https://www.google.com/drive/" target="_blank" rel="external"><strong>Google Drive</strong></a>、<a href="https://www.dropbox.com/" target="_blank" rel="external"><strong>Dropbx</strong></a>、<a href="https://onedrive.live.com/about/zh-cn/" target="_blank" rel="external"><strong>OneDrive</strong></a>等，国内有 <a href="https://pan.baidu.com/" target="_blank" rel="external"><strong>百度云盘</strong></a>、<a href="https://www.jianguoyun.com/" target="_blank" rel="external"><strong>坚果云</strong></a>等，这些都是公共网盘，由于公司业务需要，想架设公司自己用的私有网盘。</p><p>目前市面上，稳定、成熟的私有云存储方案有：</p><blockquote><p><a href="https://www.seafile.com/home/" target="_blank" rel="external"><strong>Seafile</strong></a>：国内团队开发的一个国际化开源云存储项目<br><a href="https://owncloud.org/" target="_blank" rel="external"><strong>ownCloud</strong></a>：开源专业的私有云存储项目</p></blockquote><p>另外，可以多去关注下 <a href="https://nextcloud.com/" target="_blank" rel="external"><strong>nextcloud</strong></a> 项目，据说 <code>ownCloud</code> 母公司破产后，原项目组的骨干出走并以 <code>ownCloud</code> 项目 <code>folk</code> 出新项目 <code>nextcloud</code> 继续开发。需要说明的是，<code>ownCloud</code> 母公司后来被一家德国公司收购了，<code>ownCloud</code> 项目还在继续开发。</p><p>这里主要介绍 <code>ownCloud</code> 的搭建。</p><a id="more"></a><h2 id="ownCloud介绍"><a href="#ownCloud介绍" class="headerlink" title="ownCloud介绍"></a>ownCloud介绍</h2><p><a href="https://owncloud.org/" target="_blank" rel="external"><strong>ownCloud</strong></a> 是开源的、免费的、专业的私有云存储解决方案，以 <code>AGPL</code> 许可发布，它能帮你快速地在服务器上架设一套专属的私有云文件同步网盘，可以像 <code>Dropbox</code> 那样实现文件跨平台同步、共享与团队协作等。</p><p>ownCloud 支持 Windows/Mac桌面端，IOS/Android手机端。基本可以替代在线网盘如百度网盘等。</p><h2 id="docker下安装ownCloud"><a href="#docker下安装ownCloud" class="headerlink" title="docker下安装ownCloud"></a>docker下安装ownCloud</h2><p>ownCloud项目的内核是使用PHP5编写的，环境基于LAMP，支持SQLite、MySQL、Oracle、PostgreSQL等数据库。<br>要是在服务器中，先搭建LAMP环境，再去安装ownCloud，调试环境会很麻烦，耗时也长。可以通过Docker来快速部署ownCloud。</p><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><p>服务器系统是：CentOS6.5，在此系统中安装docker，请参考前面的文章：<a href="http://www.hjqjk.com/2017/CentOS-6-5-install-docker.html" target="_blank" rel="external"><strong>CentOS 6.x 上搭建docker</strong></a></p><h3 id="拉取ownCloud官方镜像"><a href="#拉取ownCloud官方镜像" class="headerlink" title="拉取ownCloud官方镜像"></a>拉取ownCloud官方镜像</h3><p><a href="https://hub.docker.com/_/owncloud/" target="_blank" rel="external"><strong>ownCloud的官方docker镜像页面</strong></a><br>这个镜像，已经集成了 <code>Apache + PHP</code> 的环境。目前版本是：<code>10.0.1</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># docker pull owncloud</div></pre></td></tr></table></figure><p>需要用root用户拉取，否则会有警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Warning: failed to get default registry endpoint from daemon (Cannot connect to the Docker daemon. Is the docker daemon running on this host?). Using system default: https://index.docker.io/v1/</div><div class="line">Cannot connect to the Docker daemon. Is the docker daemon running on this host?</div></pre></td></tr></table></figure><h3 id="改用MySQL数据库"><a href="#改用MySQL数据库" class="headerlink" title="改用MySQL数据库"></a>改用MySQL数据库</h3><p><code>owncloud</code> 默认使用 <code>SQLite</code> 数据库，但对于更大的安装，官方建议选择另外一个不同的数据库，特别当使用桌面客户端同步文件时，不鼓励使用 <code>SQLite</code>。</p><p>拉取 <code>mysql</code> 官方docker镜像（目前最新是： <code>5.7.19</code> ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># docker pull mysql</div></pre></td></tr></table></figure><p>启动 MySQL 容器，用作 owncloud 容器的数据库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># docker run --name my-mysql -e MYSQL_ROOT_PASSWORD=&quot;Dwwe+=32H&quot; -d mysql</div></pre></td></tr></table></figure><h3 id="启动-owncloud-容器"><a href="#启动-owncloud-容器" class="headerlink" title="启动 owncloud 容器"></a>启动 owncloud 容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># docker run --name owncloud -p 5679:80   -v /data/db/owncloud:/var/www/html/data --link my-mysql:mysql -d owncloud</div></pre></td></tr></table></figure><p><code>-p 5679:80</code> ：由于宿主机已开通80端口，为了避免冲突，将容器的80端口映射到宿主机的5679端口。<br><code>--link my-mysql:mysql</code> ：将 <code>owncloud容器(客户)</code> 链接到 <code>my-mysql容器(服务)</code>，链接别名：<code>mysql</code>。</p><h3 id="配置nginx反向代理"><a href="#配置nginx反向代理" class="headerlink" title="配置nginx反向代理"></a>配置nginx反向代理</h3><p>配置文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">upstream pan_server&#123;</div><div class="line">server127.0.0.1:5679;</div><div class="line">&#125;</div><div class="line"></div><div class="line">server &#123;</div><div class="line">    listen   80;</div><div class="line">    server_name pan.xxx.com;</div><div class="line">    access_log /data/logs/nginx/pan.xxx.com.access.log;</div><div class="line">    error_log /data/logs/nginx/pan.xxx.com.error.log;</div><div class="line"></div><div class="line">    proxy_set_header X-Forwarded-For $remote_addr;</div><div class="line"></div><div class="line">    location / &#123;</div><div class="line">        proxy_set_header Host $host;</div><div class="line">        proxy_set_header X-Real-IP $remote_addr;</div><div class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</div><div class="line">        add_header Cache-Control  &quot;no-cache&quot;;</div><div class="line">    </div><div class="line">        proxy_pass http://pan_server;</div><div class="line">        limit_rate 256m;</div><div class="line">        client_max_body_size 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>配好域名解析。</p><h3 id="安装owncloud"><a href="#安装owncloud" class="headerlink" title="安装owncloud"></a>安装owncloud</h3><p>在浏览器上访问 <code>pan.xxx.com</code>，进入 owncloud 安装步骤：</p><p><img src="http://orku2pa7o.bkt.clouddn.com/2017-09-25-15063104057578.jpg" alt=""></p><p>MySQL数据库配置：</p><blockquote><p>数据库用户：root<br>数据库密码：Dwwe+=32H<br>数据库名：owncloud<br>数据库主机：mysql 或 my-mysql</p></blockquote><h3 id="docker-compose-方式安装"><a href="#docker-compose-方式安装" class="headerlink" title="docker-compose 方式安装"></a>docker-compose 方式安装</h3><p>也可以将上面启动 owncloud 和 mysql 容器的两个步骤合成一步完成，这里介绍 <code>docker-compose</code> 的使用。</p><h4 id="docker版本要求"><a href="#docker版本要求" class="headerlink" title="docker版本要求"></a>docker版本要求</h4><p>想要用 <code>docker-compose</code>，docker版本必须大于等于 <code>1.10.0</code>，否则会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ERROR: The Docker Engine version is less than the minimum required by Compose. Your current project requires a Docker Engine of version 1.10.0 or greater.</div></pre></td></tr></table></figure><h4 id="docker-compose-安装"><a href="#docker-compose-安装" class="headerlink" title="docker-compose 安装"></a>docker-compose 安装</h4><p>compose 可以通过 Python 的 pip 工具进行安装，可以直接下载编辑好的二进制文件使用，甚至直接运行在 Docker 容器中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># pip install -U docker-compose</div></pre></td></tr></table></figure><h4 id="docker-compose-yml-文件编写"><a href="#docker-compose-yml-文件编写" class="headerlink" title="docker-compose.yml 文件编写"></a>docker-compose.yml 文件编写</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="attr">version:</span> <span class="string">'2'</span></div><div class="line"><span class="attr">services:</span></div><div class="line"><span class="attr">  owncloud:</span></div><div class="line"><span class="attr">    image:</span> <span class="string">owncloud</span></div><div class="line"><span class="attr">    links:</span> </div><div class="line"><span class="attr">      - mysql:</span><span class="string">mysql</span></div><div class="line"><span class="attr">    volumes:</span></div><div class="line"><span class="bullet">      -</span> <span class="string">"/data/db/owncloud:/var/www/html/data"</span></div><div class="line"><span class="attr">    ports:</span></div><div class="line"><span class="bullet">      -</span> <span class="number">5679</span><span class="string">:80</span></div><div class="line"><span class="attr">  mysql:</span></div><div class="line"><span class="attr">    image:</span> <span class="string">mysql</span></div><div class="line"><span class="attr">    volumes:</span></div><div class="line"><span class="bullet">      -</span> <span class="string">"/data/db/mysql:/var/lib/mysql"</span></div><div class="line"><span class="attr">    ports:</span></div><div class="line"><span class="bullet">      -</span> <span class="number">3306</span><span class="string">:3306</span></div><div class="line"><span class="attr">    environment:</span></div><div class="line"><span class="attr">      MYSQL_ROOT_PASSWORD:</span> <span class="string">"Dwwe+=32H"</span></div><div class="line"><span class="attr">      MYSQL_DATABASE:</span> <span class="string">ownCloud</span></div></pre></td></tr></table></figure><h4 id="docker-compose-运行和停止"><a href="#docker-compose-运行和停止" class="headerlink" title="docker-compose 运行和停止"></a>docker-compose 运行和停止</h4><p>注意：<code>docker-compose</code> 必须在 <code>docker-compose.yml</code> 文件所在目录中执行，否则会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ERROR:</div><div class="line">    Can&apos;t find a suitable configuration file in this directory or any</div><div class="line">    parent. Are you in the right directory?</div><div class="line"></div><div class="line">    Supported filenames: docker-compose.yml, docker-compose.yaml</div></pre></td></tr></table></figure><p>docker-compose 后台启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># docker-compose up -d</div></pre></td></tr></table></figure><p>docker-compose 查看状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># docker-compose ps</div></pre></td></tr></table></figure><p>docker-compose 停止和删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># docker-compose stop</div><div class="line"># dcoker-compose rm</div><div class="line"></div><div class="line">相当上面两条命令</div><div class="line"># dcoker-compose down</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h2&gt;&lt;p&gt;相信大家都用过网盘，比如国外有 &lt;a href=&quot;https://www.google.com/drive/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;strong&gt;Google Drive&lt;/strong&gt;&lt;/a&gt;、&lt;a href=&quot;https://www.dropbox.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;strong&gt;Dropbx&lt;/strong&gt;&lt;/a&gt;、&lt;a href=&quot;https://onedrive.live.com/about/zh-cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;strong&gt;OneDrive&lt;/strong&gt;&lt;/a&gt;等，国内有 &lt;a href=&quot;https://pan.baidu.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;strong&gt;百度云盘&lt;/strong&gt;&lt;/a&gt;、&lt;a href=&quot;https://www.jianguoyun.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;strong&gt;坚果云&lt;/strong&gt;&lt;/a&gt;等，这些都是公共网盘，由于公司业务需要，想架设公司自己用的私有网盘。&lt;/p&gt;
&lt;p&gt;目前市面上，稳定、成熟的私有云存储方案有：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.seafile.com/home/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;strong&gt;Seafile&lt;/strong&gt;&lt;/a&gt;：国内团队开发的一个国际化开源云存储项目&lt;br&gt;&lt;a href=&quot;https://owncloud.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;strong&gt;ownCloud&lt;/strong&gt;&lt;/a&gt;：开源专业的私有云存储项目&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外，可以多去关注下 &lt;a href=&quot;https://nextcloud.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;strong&gt;nextcloud&lt;/strong&gt;&lt;/a&gt; 项目，据说 &lt;code&gt;ownCloud&lt;/code&gt; 母公司破产后，原项目组的骨干出走并以 &lt;code&gt;ownCloud&lt;/code&gt; 项目 &lt;code&gt;folk&lt;/code&gt; 出新项目 &lt;code&gt;nextcloud&lt;/code&gt; 继续开发。需要说明的是，&lt;code&gt;ownCloud&lt;/code&gt; 母公司后来被一家德国公司收购了，&lt;code&gt;ownCloud&lt;/code&gt; 项目还在继续开发。&lt;/p&gt;
&lt;p&gt;这里主要介绍 &lt;code&gt;ownCloud&lt;/code&gt; 的搭建。&lt;/p&gt;
    
    </summary>
    
      <category term="docker" scheme="http://yoursite.com/categories/docker/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="ownCloud" scheme="http://yoursite.com/tags/ownCloud/"/>
    
  </entry>
  
  <entry>
    <title>ELK搭建过程</title>
    <link href="http://yoursite.com/2017/ELK-install.html"/>
    <id>http://yoursite.com/2017/ELK-install.html</id>
    <published>2017-09-12T10:27:10.000Z</published>
    <updated>2017-09-14T07:20:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p>系统版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">centos-6.5</div></pre></td></tr></table></figure><p>软件版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">elasticsearch-5.2.2</div><div class="line">logstash-5.2.2</div><div class="line">kibana-5.2.2</div><div class="line">jdk : 1.8.0</div></pre></td></tr></table></figure><p>主机环境：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">主机1（192.168.10.197）：安装 jdk、logstash agent </div><div class="line">主机2（192.168.10.198）:  安装 jdk、redis 、logstash  index、elasticsearch、kibana</div></pre></td></tr></table></figure><a id="more"></a><h2 id="安装-jdk1-8-0-（197-主机、198-主机）"><a href="#安装-jdk1-8-0-（197-主机、198-主机）" class="headerlink" title="安装 jdk1.8.0 （197 主机、198 主机）"></a>安装 jdk1.8.0 （197 主机、198 主机）</h2><p>验证服务器已经安装的java版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># rpm -qa | grep java</div></pre></td></tr></table></figure><p>如果有老旧的java版本，可选择删掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># rpm -e --nodeps [相关软件名]</div></pre></td></tr></table></figure><p>下载并安装 jdk1.8.0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># wget --no-cookies --no-check-certificate --header &quot;Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie&quot; &quot;https://edelivery.oracle.com/otn-pub/java/jdk/8u121-b13/e9e7ea248e2c4826b92b3f075a80e441/jdk-8u121-linux-x64.rpm&quot;</div><div class="line"># rpm -ivh jdk-8u121-linux-x64.rpm</div></pre></td></tr></table></figure><p>验证版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># java -version</div></pre></td></tr></table></figure><p>设置环境变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># vim ~/.bash_profile  # 添加以下内容</div><div class="line">#set java environment</div><div class="line">JAVA_HOME=/usr/java/jdk1.8.0_121/</div><div class="line">JAVA_BIN=/usr/java/jdk1.8.0_121//bin</div><div class="line">CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</div><div class="line">PATH=$JAVA_BIN:$PATH</div><div class="line">export PATH JAVA_HOME CLASSPATH</div></pre></td></tr></table></figure><p>手动加载生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># source ~/.bash_profile</div></pre></td></tr></table></figure><h2 id="安装-redis（198-主机）"><a href="#安装-redis（198-主机）" class="headerlink" title="安装 redis（198 主机）"></a>安装 redis（198 主机）</h2><p>下载并安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># cd /usr/local/src</div><div class="line"># wget http://download.redis.io/releases/redis-3.2.8.tar.gz</div><div class="line"># tar zxvf redis-3.2.8.tar.gz</div><div class="line"># cd redis-3.2.8</div><div class="line"># make &amp;&amp; make install</div></pre></td></tr></table></figure><p>另外创建redis的配置、日志、数据等目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># mkdir /usr/local/redis/&#123;bin,etc,logs,db&#125; -p</div><div class="line"># cp redis-3.2.8/redis.conf /usr/local/redis/etc/</div><div class="line"># cp redis-3.2.8/src/&#123;redis-benchmark,redis-check-aof,redis-cli,redis-server,mkreleasehdr.sh&#125; /usr/local/redis/bin/</div></pre></td></tr></table></figure><p>修改redis配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># vim /usr/local/redis/etc/redis.conf</div><div class="line">pidfile /usr/local/redis/logs/redis_6379.pid</div><div class="line">logfile /usr/local/redis/logs/redis.log</div><div class="line">dir /usr/local/redis/db/</div><div class="line">#bind 127.0.0.1  #注释这行</div></pre></td></tr></table></figure><p>启动redis服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># /usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf &amp;</div></pre></td></tr></table></figure><p>开启防火墙</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># iptables -A INPUT -s 192.168.10.0/24 -m tcp -p tcp --dport 6379 -j ACCEPT</div><div class="line"># iptables-save &gt; /etc/sysconfig/iptables</div></pre></td></tr></table></figure><h2 id="安装-Logstash-（197-主机，logstash-agent-采集日志）"><a href="#安装-Logstash-（197-主机，logstash-agent-采集日志）" class="headerlink" title="安装 Logstash （197 主机，logstash agent 采集日志）"></a>安装 Logstash （197 主机，logstash agent 采集日志）</h2><p>下载并安装：(只要将安装包解压到指定目录就行)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># wget https://artifacts.elastic.co/downloads/logstash/logstash-5.2.2.tar.gz</div><div class="line"># tar zxvf logstash-5.2.2.tar.gz -C /usr/local</div></pre></td></tr></table></figure><p>创建配置目录conf，并编辑配置文件：(将采集的日志传送到198主机上的redis队列上)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># mkdir /usr/local/logstash-5.2.2/conf</div><div class="line"># cat /usr/local/logstash-5.2.2/conf/logstash_agent.conf</div><div class="line">input&#123;</div><div class="line">file&#123;</div><div class="line">type=&gt;&quot;msg&quot;</div><div class="line">path=&gt;[&quot;/var/log/messages&quot;]</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">output&#123;</div><div class="line">redis&#123;</div><div class="line">host=&gt;[&quot;192.168.10.198&quot;]</div><div class="line">port=&gt;&quot;6379&quot;</div><div class="line">data_type=&gt;&quot;list&quot;</div><div class="line">key=&gt;&quot;logstash&quot;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>创建logstash日志目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># mkdir /usr/local/ogstash-5.2.2/logs</div></pre></td></tr></table></figure><p>启动服务，将日志写到指定的日志文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># cd /usr/local/logstash-5.2.2</div><div class="line"># ./bin/logstash -f conf/logstash_agent.conf  -l logs &amp;</div></pre></td></tr></table></figure><h2 id="安装-Logstash-（198-主机，logstash-indexer）"><a href="#安装-Logstash-（198-主机，logstash-indexer）" class="headerlink" title="安装 Logstash （198 主机，logstash indexer）"></a>安装 Logstash （198 主机，logstash indexer）</h2><p>下载并安装：(只要将安装包解压到指定目录就行)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># wget https://artifacts.elastic.co/downloads/logstash/logstash-5.2.2.tar.gz</div><div class="line"># tar zxvf logstash-5.2.2.tar.gz -C /usr/local</div></pre></td></tr></table></figure><p>创建配置目录conf，并编辑配置文件：(将采集的日志传送到198主机上的redis队列上)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># mkdir /usr/local/logstash-5.2.2/conf</div><div class="line"># cat /usr/local/logstash-5.2.2/conf/logstash_indexer.conf</div><div class="line">input &#123;</div><div class="line">  redis &#123;</div><div class="line">    host =&gt;[&quot;192.168.10.198&quot;]</div><div class="line">    port =&gt; &quot;6379&quot;</div><div class="line">    data_type =&gt; &quot;list&quot;</div><div class="line">    key =&gt; &quot;logstash&quot;</div><div class="line">    type =&gt;&quot;msg&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">output &#123;</div><div class="line">  elasticsearch &#123;</div><div class="line">    hosts =&gt; &quot;192.168.10.198:9200&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>创建logstash日志目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># mkdir /usr/local/ogstash-5.2.2/logs</div></pre></td></tr></table></figure><p>启动服务，将日志写到指定的日志文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># cd /usr/local/logstash-5.2.2</div><div class="line"># ./bin/logstash -f conf/logstash_indexer.conf  -l logs &amp;</div></pre></td></tr></table></figure><h2 id="安装-elasticsearch-（198主机）"><a href="#安装-elasticsearch-（198主机）" class="headerlink" title="安装 elasticsearch （198主机）"></a>安装 elasticsearch （198主机）</h2><p>下载并安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.2.2.tar.gz</div><div class="line"># tar zxvf elasticsearch-5.2.2.tar.gz -C /usr/local/</div></pre></td></tr></table></figure><p>修改配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># cd /usr/local/elasticsearch-5.2.2/</div><div class="line"># vim config/elasticsearch.yml  </div><div class="line">cluster.name: chw</div><div class="line">node.name: chw_rpc</div><div class="line">node.master: true</div><div class="line">node.data: true</div><div class="line">network.host: 192.168.10.198</div><div class="line">path.data: /home/data/elasticsearch/data</div><div class="line">path.logs: /home/data/elasticsearch/logs</div></pre></td></tr></table></figure><p>创建目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir /home/data/elasticsearch/&#123;data,logs&#125; -p</div></pre></td></tr></table></figure><p>Elasticsearch不允许以root用户启动，否则会报错：can not run elasticsearch as root。需要创建普通用户，并切换到普通用户启动。<br>注意，elasticsearch-5.2.2目录的属主和属组也要修改，否则会报权限错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># groupadd elasticsearch</div><div class="line"># useradd elasticsearch -g elasticsearch</div><div class="line"># chown elasticsearch.elasticsearch /usr/local/elasticsearch-5.2.2/ -R</div><div class="line"># chown elasticsearch.elasticsearch /home/data/elasticsearch/ -R</div></pre></td></tr></table></figure><p>打开tcp端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># iptables -A INPUT -s 192.168.10.0/24 -m tcp -p tcp --dport 9300-j ACCEPT</div><div class="line"># iptables-save &gt; /etc/sysconfig/iptables</div></pre></td></tr></table></figure><p>启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># su elasticsearch</div><div class="line">$ ./bin/elasticsearch -d</div></pre></td></tr></table></figure><p>验证是否成功：(返回的状态码为200，则表示成功了)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># curl -X GET http://192.168.10.198:9200</div></pre></td></tr></table></figure><h3 id="相关报错及其解决方法"><a href="#相关报错及其解决方法" class="headerlink" title="相关报错及其解决方法"></a>相关报错及其解决方法</h3><p>（1）、报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ERROR: bootstrap checks failed</div><div class="line">system call filters failed to install; check the logs and fix your configuration or disable system call filters at your own risk</div></pre></td></tr></table></figure><p>原因和解决：<br>   这是在因为Centos6不支持SecComp，而ES5.2.0默认bootstrap.system_call_filter为true进行检测，所以导致检测失败，失败后直接导致ES不能启动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 修改 elasticsearch.yml </div><div class="line">bootstrap.memory_lock: false</div><div class="line">bootstrap.system_call_filter: false</div></pre></td></tr></table></figure><p>（2）、报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">node settings must not contain any index level settings</div></pre></td></tr></table></figure><p>原因和解决：<br>   在5.0+的版本中，所有index配置（例如 index.mapper.dynamic）都不能再配置文件中写定，需要在ES启动之后通过接口来改。<br>   删除elasticsearch.yml 中，index.* 开头的所有配置项。</p><p>（3）、报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">max virtual memory areas  vm.max_map_count [65530] is too low, increase to at least [262144]</div></pre></td></tr></table></figure><p>解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># vim /etc/sysctl.conf # 修改系统配置</div><div class="line">vm.max_map_count=262144</div><div class="line"># sysctl -p  # 使其生效</div></pre></td></tr></table></figure><p>（4）、报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">max number of threads [1024] for user [elsearch] likely too low, increase to at least [2048]</div></pre></td></tr></table></figure><p>解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># vim /etc/security/limits.conf  #修改为以下配置</div><div class="line">* soft nproc 2048</div><div class="line">* hard nproc 4096</div><div class="line"># vim  /etc/security/limits.d/90-nproc.conf   #修改为以下配置</div><div class="line">* soft nproc 2048</div></pre></td></tr></table></figure><h2 id="为-Elasticsearch5-2-2-安装head插件-（198-主机）"><a href="#为-Elasticsearch5-2-2-安装head插件-（198-主机）" class="headerlink" title="为 Elasticsearch5.2.2 安装head插件 （198 主机）"></a>为 Elasticsearch5.2.2 安装head插件 （198 主机）</h2><p>下载地址：<a href="https://github.com/mobz/elasticsearch-head" target="_blank" rel="external">https://github.com/mobz/elasticsearch-head</a><br>自从Elasticsearch5.0开始就不再支持site plugins，需要将Elasticsearch-head以独立服务的形式安装使用。</p><p>首先安装nodejs和npm：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># yum install nodejs npm -y</div><div class="line"># yum install git -y</div></pre></td></tr></table></figure><p>注意：5.0+版本，elasticsearch-head 不能放在elasticsearch的 plugins、modules 目录下，否则启动会报错： Property [elasticsearch.version] is missing for plugin [head]</p><p>将elasticsearch-head放到 /usr/local/src 目录并安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># cd /usr/local/src/ </div><div class="line"># git clone git://github.com/mobz/elasticsearch-head.git</div><div class="line"># cd elasticsearch-head/</div><div class="line"># npm install</div></pre></td></tr></table></figure><p>elasticsearch配置允许跨域访问，这样head插件可以访问es：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># vim elasticsearch-5.2.2/config/elasticsearch.yml  # 添加如下两行代码（&quot;:&quot; 后边要有个空格）</div><div class="line">http.cors.enabled: true</div><div class="line">http.cors.allow-origin: &quot;*&quot;</div><div class="line"># 重启elasticsearch服务，使其配置生效。</div></pre></td></tr></table></figure><h3 id="修改head源码"><a href="#修改head源码" class="headerlink" title="修改head源码"></a>修改head源码</h3><p>   由于head的代码还是老版本的，直接执行有很多限制，比如无法跨机器访问。因此需要用户修改两个地方：<br>1）修改服务器监听地址:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># vim elasticsearch-head/Gruntfile.js  # 增加hostname属性，设置为*</div><div class="line">connect: &#123;</div><div class="line">    server: &#123;</div><div class="line">        options: &#123;</div><div class="line">            port: 9100,</div><div class="line">            hostname: &apos;*&apos;,   </div><div class="line">            base: &apos;.&apos;,</div><div class="line">            keepalive: true</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>2）修改连接es服务的地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># vim elasticsearch-head/_site/app.js  # 修改为es的服务器IP</div><div class="line">this.base_uri = this.config.base_uri || this.prefs.get(&quot;app-base_uri&quot;) || &quot;http://192.168.10.198:9200&quot;;</div></pre></td></tr></table></figure><p>启动head服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cd /usr/local/src/elasticsearch-head </div><div class="line">$ ./node_modules/grunt/bin/grunt server &amp;</div></pre></td></tr></table></figure><p>验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># curl -I http://localhost:9100</div></pre></td></tr></table></figure><h2 id="安装-kibana-（198主机）"><a href="#安装-kibana-（198主机）" class="headerlink" title="安装 kibana （198主机）"></a>安装 kibana （198主机）</h2><p>下载并安装：(kibana安装很简单，解压到对应目录就行了)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># wget https://artifacts.elastic.co/downloads/kibana/kibana-5.2.2-linux-x86_64.tar.gz</div><div class="line"># tar zxvf kibana-5.2.2-linux-x86_64.tar.gz  -C /usr/local/</div><div class="line"># mv /usr/local/kibana-5.2.2-linux-x86_64/ /usr/local/kibana-5.2.2</div></pre></td></tr></table></figure><p>修改默认配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># cd /usr/local/kibana-5.2.2/config/</div><div class="line"># vim kibana.yml  # 改为以下配置</div><div class="line">elasticsearch_url: &quot;http://192.168.10.198:9200&quot;</div><div class="line">server.host: &quot;192.168.10.198&quot;</div></pre></td></tr></table></figure><p>启动服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># cd /usr/local/kibana-5.2.2/</div><div class="line"># ./bin/kibana &amp;</div></pre></td></tr></table></figure><p>验证：（返回200响应码，则成功）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># curl -I http://192.168.10.198:5601</div></pre></td></tr></table></figure><p>为了提供外网访问，利用Nginx做反向代理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">upstream kibana&#123;</div><div class="line">    server 192.168.10.198:5601 fail_timeout=0;</div><div class="line">&#125;</div><div class="line">server &#123;</div><div class="line">    listen 80;</div><div class="line">    server_name elk.xxx.com;</div><div class="line"></div><div class="line">    location / &#123;</div><div class="line">        proxy_pass http://kibana;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前提条件&quot;&gt;&lt;a href=&quot;#前提条件&quot; class=&quot;headerlink&quot; title=&quot;前提条件&quot;&gt;&lt;/a&gt;前提条件&lt;/h2&gt;&lt;p&gt;系统版本：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;centos-6.5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;软件版本：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;elasticsearch-5.2.2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;logstash-5.2.2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;kibana-5.2.2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;jdk : 1.8.0&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;主机环境：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;主机1（192.168.10.197）：安装 jdk、logstash agent &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;主机2（192.168.10.198）:  安装 jdk、redis 、logstash  index、elasticsearch、kibana&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术杂项" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="elk" scheme="http://yoursite.com/tags/elk/"/>
    
      <category term="elasticsearch" scheme="http://yoursite.com/tags/elasticsearch/"/>
    
      <category term="logstash" scheme="http://yoursite.com/tags/logstash/"/>
    
      <category term="kibana" scheme="http://yoursite.com/tags/kibana/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 6.5安装NodeJS</title>
    <link href="http://yoursite.com/2017/CentOS-6-5-install-NodeJS.html"/>
    <id>http://yoursite.com/2017/CentOS-6-5-install-NodeJS.html</id>
    <published>2017-09-05T08:14:18.000Z</published>
    <updated>2017-09-06T02:54:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>NodeJS 需要 <code>gcc4.8+</code> 版本（ <code>gcc 4.8</code> 开始全面支持 <code>C 11</code> 和 <code>C++ 11</code> 的新特性）的支持。然而 CentOS6.5 系统默认版本是 <code>4.4.7</code> ，需要升级 gcc 版本，否则在编译 NodeJS 时，会出现如下警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WARNING: C++ compiler too old, need g++ 4.8 or clang++ 3.4 (CXX=g++)</div></pre></td></tr></table></figure><a id="more"></a><h2 id="升级-gcc-版本"><a href="#升级-gcc-版本" class="headerlink" title="升级 gcc 版本"></a>升级 gcc 版本</h2><p>查看gcc版本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># gcc -v </div><div class="line">使用内建 specs。</div><div class="line">目标：x86_64-redhat-linux</div><div class="line">配置为：../configure --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-bootstrap --enable-shared --enable-threads=posix --enable-checking=release --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-languages=c,c++,objc,obj-c++,java,fortran,ada --enable-java-awt=gtk --disable-dssi --with-java-home=/usr/lib/jvm/java-1.5.0-gcj-1.5.0.0/jre --enable-libgcj-multifile --enable-java-maintainer-mode --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --disable-libjava-multilib --with-ppl --with-cloog --with-tune=generic --with-arch_32=i686 --build=x86_64-redhat-linux</div><div class="line">线程模型：posix</div><div class="line">gcc 版本 4.4.7 20120313 (Red Hat 4.4.7-17) (GCC)</div></pre></td></tr></table></figure><p>CentOS6.5 的系统源提供的 gcc 最新版本是 <code>4.4.7</code>，不能通过 <code>yum</code> 来更新 gcc，这里用编译安装。<br><a href="https://ftp.gnu.org/gnu/gcc/" target="_blank" rel="external"><strong>gcc下载点</strong></a> 有所有的 gcc 版本下载，最新版本是 <code>7.2.0</code>。</p><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">安装C和C++的静态库</div><div class="line"># yum install libgcc.i686 glibc-devel.i686</div><div class="line"></div><div class="line">安装旧版本的gcc、c++编辑器</div><div class="line"># yum install gcc gcc-c++ </div><div class="line"></div><div class="line"># yum install texinfo-tex flex zip</div></pre></td></tr></table></figure><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><p>下载解压安装包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># cd /usr/local/src</div><div class="line"># wget https://ftp.gnu.org/gnu/gcc/gcc-4.8.2/gcc-4.8.2.tar.gz</div><div class="line"># tar zxvf gcc-4.8.2.tar.gz</div></pre></td></tr></table></figure><p>官方推荐，用 <code>download_prerequisites</code> 脚本下载编译必备的一些依赖包（如gmp、mpfr、mpc、cloog、isl等依赖库），自动解压当前目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># cd gcc-4.8.2</div><div class="line"># ./contrib/download_prerequisites</div></pre></td></tr></table></figure><p>编译安装的路径是 <code>/usr/src/gcc-4.8.2/</code>，生成编译文件<code>Makefile</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># mkdir /usr/src/gcc-4.8.2</div><div class="line"># cd /usr/src/gcc-4.8.2/</div><div class="line"># /usr/local/src/gcc-4.8.2/configure --enable-checking=release --enable-languages=c,c++ --disable-multilib</div></pre></td></tr></table></figure><p>执行编译（ ORZ，这过程会很久，大概两小时吧，基本把CPU和内存占光）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># make</div></pre></td></tr></table></figure><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># make install</div></pre></td></tr></table></figure><h3 id="替换系统低版本gcc程序"><a href="#替换系统低版本gcc程序" class="headerlink" title="替换系统低版本gcc程序"></a>替换系统低版本gcc程序</h3><p>系统自带低版本 <code>gcc 4.4.7</code> 的文件位置是 <code>/usr/bin/gcc</code> 和 <code>/usr/bin/lib</code> ，这时需要将这些文件替换为最新安装的 gcc 文件，这里通过建立软链接替换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># mv /usr/bin/c++ /usr/bin/c++.bak</div><div class="line"># ln -s /usr/local/bin/c++ /usr/bin/c++</div><div class="line"># mv /usr/bin/g++ /usr/bin/g++.bak</div><div class="line"># ln -s /usr/local/bin/g++ /usr/bin/g++</div><div class="line"># mv /usr/bin/gcc /usr/bin/gcc.bak </div><div class="line"># ln -s /usr/local/bin/gcc /usr/bin/gcc</div></pre></td></tr></table></figure><p>查看gcc版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># gcc -v</div><div class="line">使用内建 specs。</div><div class="line">COLLECT_GCC=gcc</div><div class="line">COLLECT_LTO_WRAPPER=/usr/local/libexec/gcc/x86_64-unknown-linux-gnu/4.8.2/lto-wrapper</div><div class="line">目标：x86_64-unknown-linux-gnu</div><div class="line">配置为：/usr/local/src/gcc-4.8.2/configure --enable-checking=release --enable-languages=c,c++ --disable-multilib</div><div class="line">线程模型：posix</div><div class="line">gcc 版本 4.8.2 (GCC)</div></pre></td></tr></table></figure><h3 id="替换系统gcc动态链接库"><a href="#替换系统gcc动态链接库" class="headerlink" title="替换系统gcc动态链接库"></a>替换系统gcc动态链接库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"># strings /usr/lib64/libstdc++.so.6 | grep GLIBC</div><div class="line">GLIBCXX_3.4</div><div class="line">GLIBCXX_3.4.1</div><div class="line">GLIBCXX_3.4.2</div><div class="line">GLIBCXX_3.4.3</div><div class="line">GLIBCXX_3.4.4</div><div class="line">GLIBCXX_3.4.5</div><div class="line">GLIBCXX_3.4.6</div><div class="line">GLIBCXX_3.4.7</div><div class="line">GLIBCXX_3.4.8</div><div class="line">GLIBCXX_3.4.9</div><div class="line">GLIBCXX_3.4.10</div><div class="line">GLIBCXX_3.4.11</div><div class="line">GLIBCXX_3.4.12</div><div class="line">GLIBCXX_3.4.13</div><div class="line">GLIBC_2.2.5</div><div class="line">GLIBC_2.3</div><div class="line">GLIBC_2.4</div><div class="line">GLIBC_2.3.2</div><div class="line">GLIBCXX_FORCE_NEW</div><div class="line">GLIBCXX_DEBUG_MESSAGE_LENGTH</div></pre></td></tr></table></figure><p>可看出，gcc的动态链接库还是处于旧版本，说明生成的动态库没有替换旧版本 gcc 的动态库。</p><p>新版的gcc动态链接库位置是 <code>/usr/local/lib64/libstdc++.so.6.0.18</code>，替换gcc的动态链接库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># cp /usr/local/lib64/libstdc++.so.6.0.18 /usr/lib64 </div><div class="line"># cd /usr/lib64/</div><div class="line"># rm -f ./libstdc++.so.6</div><div class="line"># ln -s libstdc++.so.6.0.18 libstdc++.so.6</div></pre></td></tr></table></figure><p>查看gcc动态链接库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"># strings /usr/lib64/libstdc++.so.6 | grep GLIBC</div><div class="line">GLIBCXX_3.4</div><div class="line">GLIBCXX_3.4.1</div><div class="line">GLIBCXX_3.4.2</div><div class="line">GLIBCXX_3.4.3</div><div class="line">GLIBCXX_3.4.4</div><div class="line">GLIBCXX_3.4.5</div><div class="line">GLIBCXX_3.4.6</div><div class="line">GLIBCXX_3.4.7</div><div class="line">GLIBCXX_3.4.8</div><div class="line">GLIBCXX_3.4.9</div><div class="line">GLIBCXX_3.4.10</div><div class="line">GLIBCXX_3.4.11</div><div class="line">GLIBCXX_3.4.12</div><div class="line">GLIBCXX_3.4.13</div><div class="line">GLIBCXX_3.4.14</div><div class="line">GLIBCXX_3.4.15</div><div class="line">GLIBCXX_3.4.16</div><div class="line">GLIBCXX_3.4.17</div><div class="line">GLIBCXX_3.4.18</div><div class="line">GLIBCXX_3.4.19</div><div class="line">GLIBC_2.3</div><div class="line">GLIBC_2.2.5</div><div class="line">GLIBC_2.14</div><div class="line">GLIBC_2.3.2</div><div class="line">GLIBCXX_FORCE_NEW</div><div class="line">GLIBCXX_DEBUG_MESSAGE_LENGTH</div></pre></td></tr></table></figure><p>结果表明，gcc动态链接库升级成功。</p><h2 id="编译安装-NodeJS"><a href="#编译安装-NodeJS" class="headerlink" title="编译安装 NodeJS"></a>编译安装 NodeJS</h2><h3 id="下载并解压"><a href="#下载并解压" class="headerlink" title="下载并解压"></a>下载并解压</h3><p>从 <a href="https://nodejs.org/dist/" target="_blank" rel="external"><strong>NodeJS官网</strong></a> 下载想要的版本，这里安装的版本是 <code>v7.10.0</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># cd /usr/local/src/</div><div class="line"># wget https://nodejs.org/dist/v7.10.0/node-v7.10.0.tar.gz</div><div class="line"># tar zxvf node-v7.10.0.tar.gz</div></pre></td></tr></table></figure><h3 id="编译安装-1"><a href="#编译安装-1" class="headerlink" title="编译安装"></a>编译安装</h3><p>安装路径 <code>/usr/local/node</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># cd node-v7.10.0</div><div class="line"># mkdir /usr/local/node</div><div class="line"># ./configure --prefix=/usr/local/node</div><div class="line"># make &amp;&amp; make install</div></pre></td></tr></table></figure><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>配置系统的环境变量，打开 <code>/etc/profile</code> ，加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NODE_HOME=/usr/local/node</div><div class="line">PATH=$NODE_HOME/bin:$PATH</div><div class="line">export NODE_HOME PATH</div></pre></td></tr></table></figure><p>手动加载生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># source /etc/profile</div></pre></td></tr></table></figure><h3 id="查看版本号"><a href="#查看版本号" class="headerlink" title="查看版本号"></a>查看版本号</h3><p>查看NodeJS的版本号，检查是否安装成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># node -v</div><div class="line">v7.10.0</div></pre></td></tr></table></figure><p>参考资料：<br><a href="https://www.fanhaobai.com/2016/12/upgrade-gcc.html" target="_blank" rel="external">CentOS6.5升级gcc-4.8</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NodeJS 需要 &lt;code&gt;gcc4.8+&lt;/code&gt; 版本（ &lt;code&gt;gcc 4.8&lt;/code&gt; 开始全面支持 &lt;code&gt;C 11&lt;/code&gt; 和 &lt;code&gt;C++ 11&lt;/code&gt; 的新特性）的支持。然而 CentOS6.5 系统默认版本是 &lt;code&gt;4.4.7&lt;/code&gt; ，需要升级 gcc 版本，否则在编译 NodeJS 时，会出现如下警告：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;WARNING: C++ compiler too old, need g++ 4.8 or clang++ 3.4 (CXX=g++)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术杂项" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="nodejs" scheme="http://yoursite.com/tags/nodejs/"/>
    
      <category term="gcc" scheme="http://yoursite.com/tags/gcc/"/>
    
  </entry>
  
  <entry>
    <title>Git仓库迁移</title>
    <link href="http://yoursite.com/2017/Git-repository-move.html"/>
    <id>http://yoursite.com/2017/Git-repository-move.html</id>
    <published>2017-09-04T09:18:25.000Z</published>
    <updated>2017-09-04T10:39:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>在运维工作中，常遇到Git仓库迁移的问题，如合并多个Git服务器，更换Git托管商等。这篇文章主要记录Git仓库迁移的几种方案。</p><a id="more"></a><h3 id="单个库导入"><a href="#单个库导入" class="headerlink" title="单个库导入"></a>单个库导入</h3><p>迁移步骤：</p><ul><li>使用 <code>--mirror</code> 参数，从当前Git服务器 <code>clone</code> 仓库代码</li><li>在目标Git服务器新建一个同名的空仓库</li><li>使用 <code>--mirror</code> 参数，将代码 <code>push</code> 到目标Git服务器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">使用mirror参数，克隆裸仓库</div><div class="line"># git clone --mirror git@git.XXX.com/test/test_api.git</div><div class="line"></div><div class="line">进入仓库目录</div><div class="line"># cd test_api.git</div><div class="line"></div><div class="line">使用mirror参数，再次push仓库代码到另外一个Git服务器</div><div class="line"># git push --no-verify --mirror git@git.NNN.com/dev/test_api.git</div></pre></td></tr></table></figure><p>有三种clone的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># git clone &lt;repository&gt; &lt;directory&gt;</div><div class="line"># git clone --bare &lt;repository&gt; &lt;directory.git&gt;</div><div class="line"># git clone --mirror &lt;repository&gt; &lt;directory.git&gt;</div></pre></td></tr></table></figure><ul><li>方法1，指向的版本库创建一个克隆到目录。目录相当于克隆版本库的工作区，文件都会检出，版本库位于工作区下的 <code>.git</code> 目录中。</li><li>方法2和方法3创建的克隆版本库都不含工作区，直接就是版本库的内容，这样的版本库称为裸版本库。一般约定俗成裸版本库的目录名以.git为后缀。</li><li>方法3区别于方法2之处在于，方法3克隆出来的裸版本对上游版本库进行了注册，这样可以在裸版本库中使用 <code>git fetch</code> 命令和上游版本库进行持续同步。</li></ul><p>这种方法的缺点是，单个仓库迁移，麻烦而且效率很慢。</p><h3 id="GitLab同版本间进行数据迁移"><a href="#GitLab同版本间进行数据迁移" class="headerlink" title="GitLab同版本间进行数据迁移"></a>GitLab同版本间进行数据迁移</h3><p>Gitlab数据迁移需在同版本之间进行。因为不同版本的Gitlab之间，数据库的库表结构与程序的实现方式是有差异的。若需从<code>服务器A</code> 把Gitlab的数据迁移至 <code>服务器B</code>，则 <code>服务器B</code> 需部署与<code>服务器A</code> 同样版本的Gitlab才可。</p><h4 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h4><p>这里的GitLab是 <code>omnibus</code> 安装包安装的，默认备份目录是 <code>/var/opt/gitlab/backups</code>。</p><p>备份命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gitlab-rake gitlab:backup:create</div></pre></td></tr></table></figure><p>该命令会在备份目录（默认：/var/opt/gitlab/backups/）下创建一个tar压缩包xxxxxxxx_gitlab_backup.tar，其中开头的xxxxxx是备份创建的时间戳，这个压缩包包括GitLab整个的完整部分。</p><h4 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h4><p>从源GitLab服务器的备份目录中，拷贝备份文件到目标GitLab服务器的备份目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/var/opt/gitlab/backups/1499244722_2017_07_05_9.2.6_gitlab_backup.tar</div></pre></td></tr></table></figure><p>停止 unicorn 和 sidekiq ，保证数据库没有新的连接，不会有写数据情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">停止相关数据连接服务</div><div class="line"># gitlab-ctl stop unicorn</div><div class="line"># gitlab-ctl stop sidekiq</div><div class="line"></div><div class="line">备份恢复，完成数据迁移</div><div class="line"># gitlab-rake gitlab:import:restore BACKUP=1499242399_2017_07_05_9.2.6</div><div class="line"></div><div class="line">重启GitLab服务</div><div class="line"># gitlab-ctl start</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在运维工作中，常遇到Git仓库迁移的问题，如合并多个Git服务器，更换Git托管商等。这篇文章主要记录Git仓库迁移的几种方案。&lt;/p&gt;
    
    </summary>
    
      <category term="版本控制" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 6.x 上搭建docker</title>
    <link href="http://yoursite.com/2017/CentOS-6-5-install-docker.html"/>
    <id>http://yoursite.com/2017/CentOS-6-5-install-docker.html</id>
    <published>2017-08-31T09:09:28.000Z</published>
    <updated>2017-09-25T10:11:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.docker.com/" target="_blank" rel="external">Docker</a>是一个能够把开发应用程序自动部署到容器的开源引擎。它由Docker公司的团队编写，基于Apache 2.0开源协议授权。它提供了一个简单、轻量的建模方式，使开发生命周期更高效快速，鼓励了面向服务的架构设计。</p><a id="more"></a><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><h3 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h3><p>Docker 运行环境对内核要求比较高，一般建议直接在Ubuntu这样的平台上运行。但作为一个容器标准，Docker也支持其他如 CentOS，Mac OS X，Windows等其他平台。<br>目前Docker支持以下Red Hat和Red Hat系发行版：(不支持32位)</p><blockquote><p>(RHEL|CentOS) 6.5及以上版本（64位）<br>Fedora 19及以上版本（64位）</p></blockquote><p>在运行于这些系统时，需要 <code>内核版本 &gt;= 3.8</code> ，因为这些内核包含了运行Docker的一些特定修改。<br>查看内核版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># uname -r</div><div class="line">2.6.32-431.el6.x86_64</div></pre></td></tr></table></figure><p>注意：<code>3.8 &gt; 内核版本 &gt;= 2.6.32-431</code> 这些内核版本虽然也能支持Docker运行，但是支持得不好，仍会在运行时出现很多bug。推荐 <code>内核版本 &gt;= 3.8</code> 。</p><h3 id="检查Device-Mapper"><a href="#检查Device-Mapper" class="headerlink" title="检查Device Mapper"></a>检查Device Mapper</h3><p>Docker默认使用AUFS作为存储驱动，但是AUFS并没有被包括在Linux的主线内核中。CentOS中可以使用Device Mapper作为存储驱动，这是在2.6.9内核版本引入的新功能。<br>需要先确认是否启用该功能:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ls -l /sys/class/misc/device-mapper</span></div><div class="line">lrwxrwxrwx 1 root root 0 8月  31 17:33 /sys/class/misc/device-mapper -&gt; ../../devices/virtual/misc/device-mapper</div></pre></td></tr></table></figure><p>如果没有检测到Device Mapper，需要安装其软件包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># yum install device-mapper -y</div></pre></td></tr></table></figure><p>然后重新加载 <code>dm_mod</code> 内核模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># modprobe dm_mod</div></pre></td></tr></table></figure><h2 id="升级内核版本"><a href="#升级内核版本" class="headerlink" title="升级内核版本"></a>升级内核版本</h2><h3 id="查看当前内核版本"><a href="#查看当前内核版本" class="headerlink" title="查看当前内核版本"></a>查看当前内核版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># cat /etc/redhat-release</div><div class="line">CentOS release 6.5 (Final)</div><div class="line"># uname -r</div><div class="line">2.6.32-431.el6.x86_64</div></pre></td></tr></table></figure><p>CentOS 6.5 系统默认的内核版本是 <code>2.6.32-431.el6.x86_64</code>，不符合Docker的安装条件，需要升级内核版本。</p><h3 id="升级内核版本至3-10-0"><a href="#升级内核版本至3-10-0" class="headerlink" title="升级内核版本至3.10.0"></a>升级内核版本至3.10.0</h3><p>在yum的 <code>ELRepo</code> 源中,有 mainline（3.13.x）、long-term（3.10.x）这2个内核版本，考虑到long-term更稳定，会长期更新，所以选择这个版本。</p><p>导入 Public key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</div></pre></td></tr></table></figure><p>安装ELRepo源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># rpm -ivh http://www.elrepo.org/elrepo-release-6-8.el6.elrepo.noarch.rpm</div></pre></td></tr></table></figure><p>安装kernel-lt 或 kernel-ml（任选一个）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># kernel-lt，内核版本：3.10.x</span></div><div class="line"><span class="comment"># yum --enablerepo=elrepo-kernel install kernel-lt -y</span></div><div class="line"></div><div class="line"><span class="comment"># 或者kernel-ml，内核版本：3.13.x</span></div><div class="line"><span class="comment"># yum --enablerepo=elrepo-kernel install kernel-ml -y</span></div></pre></td></tr></table></figure><p>编辑 <code>grub.conf</code> 文件，修改 Grub 引导顺序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># cat /etc/grub.conf</div><div class="line">device (hd0) HD(1,800,64000,ab0fd74d-ecf9-42ff-8c69-0fa5d3af4fd2)</div><div class="line">default=1</div><div class="line">timeout=5</div><div class="line">splashimage=(hd0,1)/grub/splash.xpm.gz</div><div class="line">hiddenmenu</div><div class="line">title CentOS (3.10.107-1.el6.elrepo.x86_64)</div><div class="line">root (hd0,1)</div><div class="line">kernel /vmlinuz-3.10.107-1.el6.elrepo.x86_64 ro root=/dev/mapper/vg_localhost-lv_root rd_NO_LUKS rd_NO_MD rd_LVM_LV=vg_localhost/lv_swap crashkernel=128M LANG=zh_CN.UTF-8 rd_LVM_LV=vg_localhost/lv_root  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet</div><div class="line">initrd /initramfs-3.10.107-1.el6.elrepo.x86_64.img</div><div class="line">title CentOS (2.6.32-431.el6.x86_64)</div><div class="line">root (hd0,1)</div><div class="line">kernel /vmlinuz-2.6.32-431.el6.x86_64 ro root=/dev/mapper/vg_localhost-lv_root rd_NO_LUKS rd_NO_MD rd_LVM_LV=vg_localhost/lv_swap crashkernel=128M LANG=zh_CN.UTF-8 rd_LVM_LV=vg_localhost/lv_root  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet</div><div class="line">initrd /initramfs-2.6.32-431.el6.x86_64.img</div></pre></td></tr></table></figure><p>确认刚安装的内核在哪个位置，然后设置default值(从0开始)。一般新安装的内核会在第一个位置，所以设置 <code>default=0</code>。</p><p>重启服务器，查看内核版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># reboot</div><div class="line"></div><div class="line"># uname -r</div><div class="line">3.10.107-1.el6.elrepo.x86_64</div></pre></td></tr></table></figure><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>对于CentOS 6.5，Docker可以在 <code>EPEL</code>  源中找到，安装 <code>EPEL</code> 源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># rpm -Uvh http://www.gtlib.gatech.edu/pub/fedora-epel/6/i386/epel-release-6-8.noarch.rpm</div></pre></td></tr></table></figure><p>删除CentOS 6.5默认自带的Docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># yum remove docker -y</div></pre></td></tr></table></figure><p>安装docker-io的RPM包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># yum install docker-io -y</div></pre></td></tr></table></figure><p>查看Docker版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># docker version</div><div class="line">Client version: 1.7.1</div><div class="line">Client API version: 1.19</div><div class="line">Go version (client): go1.4.2</div><div class="line">Git commit (client): 786b29d/1.7.1</div><div class="line">OS/Arch (client): linux/amd64</div><div class="line">Server version: 1.7.1</div><div class="line">Server API version: 1.19</div><div class="line">Go version (server): go1.4.2</div><div class="line">Git commit (server): 786b29d/1.7.1</div><div class="line">OS/Arch (server): linux/amd64</div></pre></td></tr></table></figure><p>启动Docker服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># service docker start</div></pre></td></tr></table></figure><h2 id="CentOS6-5-中升级docker版本"><a href="#CentOS6-5-中升级docker版本" class="headerlink" title="CentOS6.5 中升级docker版本"></a>CentOS6.5 中升级docker版本</h2><p>CentOS6.5支持的docker最稳定版本就是 <code>1.7.1</code>，实在不适合升级更高的版本，强行升级的话，会很不稳定的，不建议在生产环境中升级。</p><p>具体参考：<a href="http://www.pangxie.space/docker/364" target="_blank" rel="external">Docker升级至1.9.1版本-centos6.5（测试用）</a></p><p>虽然网上能搜到很多升级的文章，但我在实际操作后发现，升级docker版本到 <code>1.9.1</code> 后，启动诸多容器都失败了，换回 <code>1.7.1</code> 后，一切正常。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.docker.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Docker&lt;/a&gt;是一个能够把开发应用程序自动部署到容器的开源引擎。它由Docker公司的团队编写，基于Apache 2.0开源协议授权。它提供了一个简单、轻量的建模方式，使开发生命周期更高效快速，鼓励了面向服务的架构设计。&lt;/p&gt;
    
    </summary>
    
      <category term="docker" scheme="http://yoursite.com/categories/docker/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 6.x 上安装Go</title>
    <link href="http://yoursite.com/2017/CentOS-6-x-install-Go.html"/>
    <id>http://yoursite.com/2017/CentOS-6-x-install-Go.html</id>
    <published>2017-08-30T09:52:14.000Z</published>
    <updated>2017-09-14T15:58:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>Go 语言是由Google开发的一种静态强类型、编译型、并发型并具有垃圾回收功能的开源编程语言。<br>Go语言是基于Inferno操作系统所开发的。Go语言于2009年11月正式宣布推出，成为开放源代码项目，并在Linux及Mac OS X平台上进行了实现，后来追加了Windows系统下的实现。</p><blockquote><p><a href="https://golang.org/" target="_blank" rel="external">Go语言官网</a><br>目前最新版本：Go 1.9</p></blockquote><p>对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。</p><a id="more"></a><h3 id="安装Go"><a href="#安装Go" class="headerlink" title="安装Go"></a>安装Go</h3><p>获取Go语言的二进制归档文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># cd /usr/local/src</div><div class="line"># wget https://storage.googleapis.com/golang/go1.7.3.linux-amd64.tar.gz</div></pre></td></tr></table></figure><p>解压安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># tar zxvf go1.7.3.linux-amd64.tar.gz -C /usr/local/</div></pre></td></tr></table></figure><h3 id="配置Go环境"><a href="#配置Go环境" class="headerlink" title="配置Go环境"></a>配置Go环境</h3><p>现在，你需要设置转到语言环境变量为您的项目。通常你需要设置3个环境变量 <code>GOROOT</code>，<code>GOPATH</code> 和 <code>PATH</code> 。</p><p><code>GOROOT</code> 是软件包安装在系统上的位置。<br><code>GOPATH</code> 是你的工作目录。 例如我的项目目录是 <code>~/Projects/Proj1</code> ，则 <code>GOPATH=$HOME/Projects/Proj1</code></p><p>在 <code>/etc/bashrc</code> 中加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">GOROOT=/usr/local/go</div><div class="line">GOPATH=$HOME/Projects/Proj1   # 根据实际项目路径更改</div><div class="line">PATH=$GOPATH/bin:$GOROOT/bin:$PATH</div></pre></td></tr></table></figure><p>手动加载生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># source /etc/bashrc</div></pre></td></tr></table></figure><h3 id="验证安装是否成功"><a href="#验证安装是否成功" class="headerlink" title="验证安装是否成功"></a>验证安装是否成功</h3><p>检查Go版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># go version</div><div class="line">go version go1.7.3 linux/amd64</div></pre></td></tr></table></figure><p>验证所有环境变量是否配置正确</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># go env</div><div class="line">GOARCH=&quot;amd64&quot;</div><div class="line">GOBIN=&quot;&quot;</div><div class="line">GOEXE=&quot;&quot;</div><div class="line">GOHOSTARCH=&quot;amd64&quot;</div><div class="line">GOHOSTOS=&quot;linux&quot;</div><div class="line">GOOS=&quot;linux&quot;</div><div class="line">GOPATH=&quot;/root/Projects/Proj1&quot;</div><div class="line">GORACE=&quot;&quot;</div><div class="line">GOROOT=&quot;/usr/local/go&quot;</div><div class="line">GOTOOLDIR=&quot;/usr/local/go/pkg/tool/linux_amd64&quot;</div><div class="line">CC=&quot;gcc&quot;</div><div class="line">GOGCCFLAGS=&quot;-fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build311841584=/tmp/go-build&quot;</div><div class="line">CXX=&quot;g++&quot;</div><div class="line">CGO_ENABLED=&quot;1&quot;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Go 语言是由Google开发的一种静态强类型、编译型、并发型并具有垃圾回收功能的开源编程语言。&lt;br&gt;Go语言是基于Inferno操作系统所开发的。Go语言于2009年11月正式宣布推出，成为开放源代码项目，并在Linux及Mac OS X平台上进行了实现，后来追加了Windows系统下的实现。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://golang.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Go语言官网&lt;/a&gt;&lt;br&gt;目前最新版本：Go 1.9&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。&lt;/p&gt;
    
    </summary>
    
      <category term="技术杂项" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 6.x 安装JDK8</title>
    <link href="http://yoursite.com/2017/CentOS-6-x-install-JDK8.html"/>
    <id>http://yoursite.com/2017/CentOS-6-x-install-JDK8.html</id>
    <published>2017-08-30T08:00:46.000Z</published>
    <updated>2017-08-30T10:33:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>CentOS 6.x 系统默认安装了JDK7，可根据需要决定是否卸载JDK7。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># rpm -qa |grep jdk</div><div class="line">java-1.7.0-openjdk-devel-1.7.0.121-2.6.8.1.el6_8.x86_64</div><div class="line">java-1.7.0-openjdk-1.7.0.121-2.6.8.1.el6_8.x86_64</div></pre></td></tr></table></figure><a id="more"></a><h3 id="下载解压-JDK"><a href="#下载解压-JDK" class="headerlink" title="下载解压 JDK"></a>下载解压 JDK</h3><p>可以从其<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="external">官方下载页面</a>下载最新的Java SE Development Kit 8版本，或使用以下命令从shell下载。</p><p>对于64位系统：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># mkdir /usr/local/java</div><div class="line"># cd /usr/local/java</div><div class="line"># wget --no-cookies --no-check-certificate --header &quot;Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie&quot; &quot;http://download.oracle.com/otn-pub/java/jdk/8u141-b15/336fa29ff2bb4ef291e347e091f7f4a7/jdk-8u141-linux-x64.tar.gz&quot;</div><div class="line"># tar zxvf jdk-8u141-linux-x64.tar.gz</div></pre></td></tr></table></figure><p>对于32位系统：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># mkdir /usr/local/java</div><div class="line"># cd /usr/local/java</div><div class="line"># wget --no-cookies --no-check-certificate --header &quot;Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie&quot; &quot;http://download.oracle.com/otn-pub/java/jdk/8u141-b15/336fa29ff2bb4ef291e347e091f7f4a7/jdk-8u141-linux-i586.tar.gz&quot;</div><div class="line"># tar zxvf jdk-8u141-linux-i586.tar.gz</div></pre></td></tr></table></figure><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>绝大多数的Java应用，都是基于其环境变量来工作的，必须设置好。<br>在系统环境变量文件 <code>/etc/profile</code> 中添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">JAVA_HOME=/usr/local/java/jdk1.8.0_141</div><div class="line">JRE_HOME=/usr/local/java/jdk1.8.0_141/jre</div><div class="line">CLASSPATH=$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib</div><div class="line">PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin</div><div class="line"></div><div class="line">export JAVA_HOME JRE_HOME CLASSPATH PATH</div></pre></td></tr></table></figure><p>手动加载生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># source /etc/profile</div></pre></td></tr></table></figure><h3 id="验证JDK版本"><a href="#验证JDK版本" class="headerlink" title="验证JDK版本"></a>验证JDK版本</h3><p>检查JDK版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># java -version</div><div class="line">java version &quot;1.8.0_141&quot;</div><div class="line">Java(TM) SE Runtime Environment (build 1.8.0_141-b15)</div><div class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.141-b15, mixed mode)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CentOS 6.x 系统默认安装了JDK7，可根据需要决定是否卸载JDK7。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;# rpm -qa |grep jdk&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;java-1.7.0-openjdk-devel-1.7.0.121-2.6.8.1.el6_8.x86_64&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;java-1.7.0-openjdk-1.7.0.121-2.6.8.1.el6_8.x86_64&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>常用docker命令清单</title>
    <link href="http://yoursite.com/2017/Command-list-of-docker.html"/>
    <id>http://yoursite.com/2017/Command-list-of-docker.html</id>
    <published>2017-08-29T09:21:29.000Z</published>
    <updated>2017-09-01T02:36:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="连接到正在运行的容器上"><a href="#连接到正在运行的容器上" class="headerlink" title="连接到正在运行的容器上"></a>连接到正在运行的容器上</h2><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。有时候，我们需要进入容器进行操作，可以用docker自带的命令 <code>docker attach</code>。要 <code>attach</code> 上去的容器必须正在运行，可以同时连接上同一个容器来共享屏幕（与 <code>screen</code> 命令类似）</p><p><strong>注意</strong>：直接用 <code>docker attach $CONTAINER_ID</code> 命令连接上容器， <code>CTRL-C</code> 退出后，容器会停止运行。这不符合我们的需求，在 <code>attach</code> 时可以带上 <code>--sig-proxy=false</code> 来确保 <code>CTRL-D</code> 或 <code>CTRL-C</code> 不会关闭容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># docker attach --sig-proxy=false [$CONTAINER_ID | NAMES]</div></pre></td></tr></table></figure><p>若容器当前正在前台运行进程，如输出nginx的访问日志，而又想连上容器另外执行命令时，不能用 <code>docker attach</code> 命令，可以使用 <code>docker exec</code> 在容器内启动一个交互shell。</p><h2 id="在容器内部运行进程"><a href="#在容器内部运行进程" class="headerlink" title="在容器内部运行进程"></a>在容器内部运行进程</h2><p>在 <code>Docker 1.3</code> 之后，<code>docker exec</code> 命令被引入，该命令可以在容器内部额外启动新进程。<br>可在容器内运行的进程有两种：</p><blockquote><p>后台任务：在容器内运行且没有交互需求<br>交互式任务：保持在前台运行</p></blockquote><h3 id="在容器中运行后台任务"><a href="#在容器中运行后台任务" class="headerlink" title="在容器中运行后台任务"></a>在容器中运行后台任务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># docker exec -d test touch /tmp/test.txt</div></pre></td></tr></table></figure><p><code>-d</code> 表明需要运行一个后台进程，<code>test</code> 是容器名，<code>touch /tmp/test.txt</code> 是要要执行的命令。上述例子中的命令会在 <code>test</code> 容器内创建一个空文件 <code>/tmp/test.txt</code>。<br>通过 <code>docker exec</code> 后台命令，可以在正在运行的容器中进行维护、监控和管理任务。</p><h3 id="在容器内运行交互命令"><a href="#在容器内运行交互命令" class="headerlink" title="在容器内运行交互命令"></a>在容器内运行交互命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># docker exec -t -i test /bin/bash</div></pre></td></tr></table></figure><p><code>-t</code> 和 <code>-i</code> 参数为我们执行的进程创建了 <code>TTY</code> 并且捕捉 <code>STDIN</code> 。<code>test</code> 是容器名，<code>/bin/bash</code> 是要执行的命令。上述命令会在 <code>test</code> 容器中创建一个新的 <code>bash</code> 会话，有了这个会话，我们就可以在该容器中运行其他命令，而且用 <code>exit</code> 命令退出该会话后，容器不会停止。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;连接到正在运行的容器上&quot;&gt;&lt;a href=&quot;#连接到正在运行的容器上&quot; class=&quot;headerlink&quot; title=&quot;连接到正在运行的容器上&quot;&gt;&lt;/a&gt;连接到正在运行的容器上&lt;/h2&gt;&lt;p&gt;在使用 &lt;code&gt;-d&lt;/code&gt;
        
      
    
    </summary>
    
      <category term="docker" scheme="http://yoursite.com/categories/docker/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Python图像处理库:pillow</title>
    <link href="http://yoursite.com/2017/Image-processing-library-of-python-pillow.html"/>
    <id>http://yoursite.com/2017/Image-processing-library-of-python-pillow.html</id>
    <published>2017-08-15T03:51:30.000Z</published>
    <updated>2017-09-01T02:29:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>PIL(Python Imaging Library) 是pyhton常用的图像处理库，<a href="http://pythonware.com/products/pil/" target="_blank" rel="external"><strong>官方网站</strong></a>，最新版本是 <code>1.1.7</code> ，于2009年9月发布，支持Python <code>1.5.2 - 2.7</code>。<br>PIL项目似乎已经停止开发了，<a href="https://web.archive.org/web/20150315041249/http://hg.effbot.org/pil-2009-raclette" target="_blank" rel="external"><strong>PIL仓库</strong></a> 最后一次提交是2011年。<br>python 3.x 版本是无法使用原PIL库的，得使用Pillow库。</p><p>Pillow 库则是 PIL 的一个友好Fork，维护和开发活跃，Pillow 兼容 PIL 的绝大多数语法，推荐使用。<br>Pillow 库提供了广泛的文件格式支持，强大的图像处理能力，主要包括图像储存、图像显示、格式转换以及基本的图像处理操作等。</p><blockquote><p><a href="https://github.com/python-pillow/Pillow" target="_blank" rel="external"><strong>Pillow项目仓库</strong></a><br><a href="https://python-pillow.org/" target="_blank" rel="external"><strong>Pillow官网</strong></a><br><a href="http://pillow.readthedocs.io/en/latest/" target="_blank" rel="external"><strong>Pillow文档</strong></a></p></blockquote><a id="more"></a><h2 id="安装和介绍"><a href="#安装和介绍" class="headerlink" title="安装和介绍"></a>安装和介绍</h2><p>先安装一些依赖包，对于Mac OS系统，可以用 HomeBrew 来安装。这里使用的是python3.x，所以用 pip3 来安装pillow。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ brew install libtiff libjpeg libpng webp little-cms2 freetype</div><div class="line">$ sudo pip3 install pillow</div></pre></td></tr></table></figure><p>pillow库有几个重要的类：</p><ul><li>Image</li><li>ImageDraw</li><li>ImageFont</li></ul><h2 id="Image模块"><a href="#Image模块" class="headerlink" title="Image模块"></a>Image模块</h2><p>PIL 最重要的类是 <code>Image</code>，而<code>Image</code>类定义在同名的 <code>Image</code> 模块里。使用PIL的功能，一般都是从新建一个 <code>Image</code> 类的实例开始。你可以通过多种方法创建 <code>Image</code> 类的实例，如用 <code>Image</code> 模块的 <code>open()</code> 函数打开已有的图像，也可以处理其他实例，或者从零开始构建一个实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>im = Image.open(<span class="string">'avatar.jpeg'</span>)</div></pre></td></tr></table></figure><p>上面代码引入了 <code>Image</code> 模块，利用模块的 <code>open()</code> 函数，打开了当前目录中的 <code>avatar.jpeg</code> 图像，构建了 <code>im</code> 实例。如果打开失败，会抛出 <code>IOError</code> 异常。</p><p>Image实例有5个属性，如下：</p><ul><li><strong>format</strong> : 返回图像的格式(PNG,JPG,None等)。如果图像不是从文件读取的，它的值就是None</li><li><strong>mode</strong> : 返回图像的模式。常用模式有 <code>L</code> (luminance) 表示灰度图像, <code>RGB</code> 表示真彩色图像, and <code>CMYK</code> 表示出版图像。<a href="http://effbot.org/imagingbook/concepts.htm#mode" target="_blank" rel="external">官方说明-图像模式完整列表</a></li><li><strong>size</strong> : 是一个二元tuple，包含width和height（宽度和高度，单位都是px）</li><li><strong>palette</strong> : 仅当 mode 为 <code>P</code> 时有效，返回 ImagePalette 实例</li><li><strong>info</strong> : 以字典的形式返回实例的信息</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(im.format)</div><div class="line">JPEG</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(im.mode)</div><div class="line">RGB</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(im.size)</div><div class="line">(<span class="number">640</span>, <span class="number">640</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(im.palette)</div><div class="line"><span class="keyword">None</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(im.info)</div><div class="line">&#123;<span class="string">'jfif'</span>: <span class="number">257</span>, <span class="string">'jfif_unit'</span>: <span class="number">0</span>, <span class="string">'exif'</span>: <span class="string">'Exif\x00\x00MM\x00*\x00\x00\x00\x08\x00\x02\x01\x12\x00\x03\x00\x00\x00\x01\x00\x01\x00\x00\x87i\x00\x04\x00\x00\x00\x01\x00\x00\x00&amp;\x00\x00\x00\x00\x00\x03\xa0\x01\x00\x03\x00\x00\x00\x01\x00\x01\x00\x00\xa0\x02\x00\x04\x00\x00\x00\x01\x00\x00\x02\x80\xa0\x03\x00\x04\x00\x00\x00\x01\x00\x00\x02\x80\x00\x00\x00\x00'</span>, <span class="string">'progressive'</span>: <span class="number">1</span>, <span class="string">'jfif_version'</span>: (<span class="number">1</span>, <span class="number">1</span>), <span class="string">'jfif_density'</span>: (<span class="number">72</span>, <span class="number">72</span>), <span class="string">'progression'</span>: <span class="number">1</span>&#125;</div></pre></td></tr></table></figure><p>可以使用 <code>show()</code> 方法来查看实例（PIL 会将实例暂存为一个临时文件，然后打开它）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>im.show()</div></pre></td></tr></table></figure><p><img src="http://orku2pa7o.bkt.clouddn.com/2017-08-18-15030493677497.jpg" alt=""></p><h3 id="转换图像格式"><a href="#转换图像格式" class="headerlink" title="转换图像格式"></a>转换图像格式</h3><p>PIL 模块支持大量的图像格式。使用 <code>open()</code> 函数从磁盘中读取图像文件，不需要指定图像格式，它会根据文件内容自动确定图像格式。<br>可使用 <code>save(filename,format)</code> 函数以特定的图像格式保存图像。若不指定图像格式，<code>save()</code> 方法会根据文件扩展名来选择相应的图像格式。</p><p>例子：转换图像格式的脚本（转为png格式）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"> </div><div class="line"><span class="keyword">for</span> infile <span class="keyword">in</span> sys.argv[<span class="number">1</span>:]:</div><div class="line">    f,e = os.path.splitext(infile)   <span class="comment"># f 变量是除扩展名以外的文件名，e 变量是扩展名</span></div><div class="line">    outfile = f +<span class="string">".png"</span>  <span class="comment"># 拼凑输出文件名</span></div><div class="line">    <span class="keyword">if</span> infile != outfile:   <span class="comment"># 保存的图像格式跟原图像格式不一样</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            Image.open(infile).save(outfile)  <span class="comment"># 转换图像格式</span></div><div class="line">        <span class="keyword">except</span> IOError:</div><div class="line">            print(<span class="string">"Cannot convert"</span>, infile)  <span class="comment"># 图像无法打开，则处理异常</span></div></pre></td></tr></table></figure><h3 id="创建缩略图"><a href="#创建缩略图" class="headerlink" title="创建缩略图"></a>创建缩略图</h3><p>缩略图是网络开发或者图像软件预览常用的一种基本技术，使用Python的Pillow图像库可以很方便地建立缩略图。<br>Image 类的 <code>thumbnail()</code> 方法可以用来制作缩略图。它接受一个二元数组作为缩略图的尺寸，然后将实例缩小到指定尺寸。</p><p>例子：生成JPEG缩略图，大小是原图像的四分之一</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os, sys</div><div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</div><div class="line"></div><div class="line"><span class="keyword">for</span> infile <span class="keyword">in</span> sys.argv[<span class="number">1</span>:]:</div><div class="line">    outfile = os.path.splitext(infile)[<span class="number">0</span>] + <span class="string">".thumbnail"</span> <span class="comment"># 缩略图文件名+后缀</span></div><div class="line">    <span class="keyword">if</span> infile != outfile:</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            im   = Image.open(infile) <span class="comment"># 打开图像</span></div><div class="line">            x, y = im.size  <span class="comment"># 获取原图像的大小（width、height）</span></div><div class="line">            im.thumbnail((x//<span class="number">2</span>, y//<span class="number">2</span>)) <span class="comment"># 缩略图大小</span></div><div class="line">            im.save(outfile, <span class="string">"JPEG"</span>) <span class="comment"># 保存为 JPEG 格式</span></div><div class="line">        <span class="keyword">except</span> IOError:</div><div class="line">            <span class="keyword">print</span> <span class="string">"cannot create thumbnail for"</span>, infile</div></pre></td></tr></table></figure><p><strong>注意</strong>：Pillow库不会直接解码或者加载图像栅格数据。当你打开一个文件，只会读取文件头信息用来确定格式，颜色模式，大小等等，文件的剩余部分不会主动处理。这意味着打开一个图像文件的操作十分快速，跟图像大小和压缩方式无关。</p><h3 id="图像的剪切、粘贴与合并操作"><a href="#图像的剪切、粘贴与合并操作" class="headerlink" title="图像的剪切、粘贴与合并操作"></a>图像的剪切、粘贴与合并操作</h3><p>Image 类包含很多操作图像区域的方法。</p><h4 id="裁剪子矩形"><a href="#裁剪子矩形" class="headerlink" title="裁剪子矩形"></a>裁剪子矩形</h4><p><code>crop()</code> 方法可以从图像中提取一个子矩形选区，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">im = Image.open(<span class="string">"avatar.jpeg"</span>)</div><div class="line">box = (<span class="number">100</span>,<span class="number">100</span>,<span class="number">300</span>,<span class="number">300</span>)</div><div class="line">region = im.crop(box)</div></pre></td></tr></table></figure><p>矩形选区区域由一个4元元组决定，元组信息表示 <code>(左,上,右,下)</code> 的坐标。Pillow库以图像左上角为坐标原点 <code>(0,0)</code>，单位是 <code>px</code> 。<br>因此，上述代码是复制了一个 200x200 pixels 的矩形选区。</p><h4 id="处理子图，粘贴回原图"><a href="#处理子图，粘贴回原图" class="headerlink" title="处理子图，粘贴回原图"></a>处理子图，粘贴回原图</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">region = region.transpose(Image.ROTATE_180)   <span class="comment"># 旋转180°</span></div><div class="line">im.paste(region, box)</div></pre></td></tr></table></figure><p><img src="http://orku2pa7o.bkt.clouddn.com/2017-08-18-a1.jpg" alt="a1"></p><p><code>transpose()</code> 方法可以将图片左右颠倒、上下颠倒、旋转 90°、旋转 180° 或旋转 270°。<code>paste()</code> 方法则可以将一个 Image 实例粘贴到另一个 Image 实例上。</p><p><strong>注意</strong>：当你粘贴矩形选区的时候必须保证尺寸一致。此外，矩形选区不能在图像外。然而你不必保证矩形选区和原图的颜色模式一致，如果不一致，目标图像会在保存的时候自动进行转换。</p><p>例子（扩展实例）：翻转图像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">roll</span><span class="params">(image, delta)</span>:</span></div><div class="line">    <span class="string">"Roll an image sideways"</span></div><div class="line"></div><div class="line">    xsize, ysize = image.size</div><div class="line"></div><div class="line">    delta = delta % xsize  <span class="comment"># 翻卷多少像素</span></div><div class="line">    <span class="keyword">if</span> delta == <span class="number">0</span>: <span class="keyword">return</span> image   <span class="comment"># 不翻卷图形</span></div><div class="line"></div><div class="line">    part1 = image.crop((<span class="number">0</span>, <span class="number">0</span>, delta, ysize))  <span class="comment"># 左边矩形选区</span></div><div class="line">    part2 = image.crop((delta, <span class="number">0</span>, xsize, ysize))  <span class="comment"># 右边矩形选区</span></div><div class="line">    part1.load() </div><div class="line">    part2.load()</div><div class="line">    image.paste(part2, (<span class="number">0</span>, <span class="number">0</span>, xsize-delta, ysize)) <span class="comment"># 原右边图形贴到左边</span></div><div class="line">    image.paste(part1, (xsize-delta, <span class="number">0</span>, xsize, ysize))  <span class="comment"># 原左边图形贴到右边</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> image</div><div class="line"></div><div class="line"></div><div class="line">im = Image.open(<span class="string">'avatar.jpeg'</span>)</div><div class="line">print(im.size)   <span class="comment"># (356, 362)</span></div><div class="line"></div><div class="line">roll(im,<span class="number">100</span>).save(<span class="string">'avatar_roll.jpeg'</span>,<span class="string">'JPEG'</span>)</div></pre></td></tr></table></figure><p><img src="http://orku2pa7o.bkt.clouddn.com/2017-08-21-t11.jpeg" alt="t11"><br><strong>要注意的是</strong>，当你使用 <code>crop()</code> 方法来修改图像文件的时候, <code>load()</code> 方法会首先被调用。这是由于修改是一个惰性操作。如果 <code>load()</code> 未被调用，那么在 <code>paste</code> 使用前都不会执行修改这个操作。这暗示着 <code>part1</code> 会在首次修改 <code>image</code> 的时候被修改。</p><h4 id="分离和合并颜色通道"><a href="#分离和合并颜色通道" class="headerlink" title="分离和合并颜色通道"></a>分离和合并颜色通道</h4><p>对于多通道图像，有时候处理时希望能够分别对每个通道处理，处理完成后重新合成多通道，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">r,g,b = im.split()</div><div class="line">im = Image.merge(<span class="string">'RGB'</span>,(r,g,b))</div></pre></td></tr></table></figure><p>对于 <code>split()</code> 函数，如果是单通道的，则返回其本身。否则，返回各个通道。</p><h3 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h3><p><code>Image</code> 类包含了 <code>resize()</code> 和 <code>rotate</code> 方法来变换图像。前者需要传入一个表示新大小的元组，后者需要传入旋转的角度。</p><h4 id="简单的几何变换"><a href="#简单的几何变换" class="headerlink" title="简单的几何变换"></a>简单的几何变换</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">out = im.resize((<span class="number">128</span>, <span class="number">128</span>))</div><div class="line">out = im.rotate(<span class="number">45</span>) <span class="comment"># 顺时针角度表示</span></div></pre></td></tr></table></figure><p>要想以90°旋转图像，可以使用 <code>rotate</code> 方法，也可以使用 <code>transpose()</code> 方法，后者能水平或垂直翻转图像。</p><h4 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">out = im.transpose(Image.FLIP_LEFT_RIGHT) <span class="comment"># 左右颠倒</span></div><div class="line">out = im.transpose(Image.FLIP_TOP_BOTTOM) <span class="comment"># 上下颠倒</span></div><div class="line">out = im.transpose(Image.ROTATE_90)  <span class="comment"># 旋转90°</span></div><div class="line">out = im.transpose(Image.ROTATE_180)  <span class="comment"># 旋转180°</span></div><div class="line">out = im.transpose(Image.ROTATE_270)  <span class="comment"># 旋转270°</span></div></pre></td></tr></table></figure><p>更通用的图像变换方法可以使用 <a href="http://pillow-zh-cn.readthedocs.io/zh_CN/latest/reference/Image.html#PIL.Image.Image.transform" target="_blank" rel="external">transform()</a></p><h2 id="ImageDraw模块"><a href="#ImageDraw模块" class="headerlink" title="ImageDraw模块"></a>ImageDraw模块</h2><p>ImageDraw 模块提供了 <code>Draw</code> 类，它能在 <code>Image</code> 实例上进行简单的2D绘画。你可以使用这个模块来创建新图像或者修饰现有图像。</p><p>有关PIL的更高级绘图库，可以参考 <a href="http://effbot.org/zone/aggdraw-index.htm" target="_blank" rel="external">aggdraw模块</a></p><h3 id="创建-Draw-类的实例"><a href="#创建-Draw-类的实例" class="headerlink" title="创建 Draw 类的实例"></a>创建 Draw 类的实例</h3><p>要在 <code>Image</code> 实例上绘制新的图样，首先要创建一个 <code>Draw</code> 类的实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image,ImageDraw</div><div class="line">im = Image.open(<span class="string">'avatar.jpeg'</span>)</div><div class="line">drawAvatar = ImageDraw.Draw(im)</div></pre></td></tr></table></figure><h3 id="基本绘画操作"><a href="#基本绘画操作" class="headerlink" title="基本绘画操作"></a>基本绘画操作</h3><p>这里粗略介绍下 <code>Draw</code> 类中的基本绘画操作函数(英文都是函数名)：</p><ul><li>弦/弧/扇形: chord / arc / pieslice</li><li>椭圆: ellipse</li><li>线段/多段线: line</li><li>点: point</li><li>多边形: polygon</li><li>矩形: rectangle</li><li>文字: text</li><li>文字大小: textsize</li></ul><p>详细的使用说明，请看官方文档：<a href="https://pillow.readthedocs.io/en/4.2.x/reference/ImageDraw.html#functions" target="_blank" rel="external">Draw类的各函数使用说明</a></p><h3 id="画直线"><a href="#画直线" class="headerlink" title="画直线"></a>画直线</h3><p>为熟悉 <code>Draw</code> 类的函数的使用，下面以画几条线为例来说明。</p><p><code>Draw</code> 类提供了 <code>line(xy,options)</code> 函数绘制直线。<br>其中 <code>xy</code> 表示坐标列表，它可以是任何包含2元组[(x,y),…]或者数字[x,y,…]的序列对象，至少包含两个坐标：</p><ul><li>[(x1, y1), (x2, y2), …] ：包含若干个元组的列表</li><li>[x1, y1, x2, y2, …] ：按照顺序包含坐标信息的列表</li><li>[x1, y1, (x2, y2), …] ：以上两种情况的混合</li><li>((x1, y1), (x2, y2), …) ：包含若干个元组的元组</li><li>(x1, y1, x2, y2, …) ：按照顺序包含坐标信息的元组</li><li>(x1, y1, (x2, y2), …) ：以上两种情况的混合</li></ul><p><code>options</code> 可用的选项：</p><ul><li>fill = (R,G,B) ：指定线条颜色</li><li>width = integer ：指定线条宽度，单位是px</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image,ImageDraw</div><div class="line">im = Image.open(<span class="string">'avatar.jpeg'</span>)</div><div class="line">drawAvatar = ImageDraw.Draw(im)</div><div class="line"></div><div class="line">xSize,ySize = im.size</div><div class="line"></div><div class="line"><span class="comment"># 三等分位置</span></div><div class="line">drawAvatar.line([<span class="number">0</span>, <span class="number">0.33</span> * ySize, xSize, <span class="number">0.33</span> * ySize],\</div><div class="line">    fill = (<span class="number">255</span>, <span class="number">100</span>, <span class="number">0</span>), width = <span class="number">3</span>)</div><div class="line"><span class="comment"># 左下角到中心点，右下角到中心点</span></div><div class="line">drawAvatar.line([(<span class="number">0</span>, ySize), (<span class="number">0.5</span> * xSize, <span class="number">0.5</span> * ySize), (xSize, ySize)],\</div><div class="line">    fill = (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), width = <span class="number">3</span>)</div><div class="line"></div><div class="line">im.save(<span class="string">'avatar_line.jpeg'</span>)</div></pre></td></tr></table></figure><p><img src="http://orku2pa7o.bkt.clouddn.com/2017-08-21-t22.jpeg" alt="t22"><br>这里边，我们画了一条平行线和两条短线组成的折线（虽然看着有点像喷鼻血 ORZ ）。</p><h3 id="画弧线"><a href="#画弧线" class="headerlink" title="画弧线"></a>画弧线</h3><p><code>Draw</code> 类也提供了 <code>arc(xy, start, end, options)</code> 函数来绘制弧线。</p><p><code>xy</code> 是个长度为4的列表，用来表示一个 bounding box(边界区域)。如[x0, y0, x1, y1]，分别表示 弧线最左侧距离左边、弧线最顶点距离上边、弧线最右侧距离左边、弧线最低点距离上边的距离。<br><code>start</code> 和 <code>end</code> 则是弧的起止角度，单位是 °。其中水平向右的方向为 0°，竖直向下的方向为 90°，水平向左的方向为 180°，竖直向上的方向为 270°。<br><code>options</code> 中可用选项：</p><ul><li>fill = (R, G, B) ：指定线条颜色</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image,ImageDraw</div><div class="line">im = Image.open(<span class="string">'avatar.jpeg'</span>)</div><div class="line">drawAvatar = ImageDraw.Draw(im)</div><div class="line"></div><div class="line">drawAvatar.arc([<span class="number">10</span>,<span class="number">20</span>,<span class="number">100</span>,<span class="number">300</span>],<span class="number">0</span>,<span class="number">270</span>,fill=(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>))</div><div class="line"></div><div class="line">im.save(<span class="string">'avatar_arc.jpeg'</span>)</div></pre></td></tr></table></figure><p><img src="http://orku2pa7o.bkt.clouddn.com/2017-08-22-avatar_arc.jpeg" alt="avatar_arc"><br><code>arc</code> 方法将在内切于 bounding box(边界区域) 的椭圆中，按照给定的起止角度切下一段弧，并绘制于 <code>Image</code> 实例之上。</p><h3 id="在图片上写字"><a href="#在图片上写字" class="headerlink" title="在图片上写字"></a>在图片上写字</h3><p><code>Draw</code> 类提供了 <code>text(xy, text, options)</code> 函数，可以在 <code>Image</code> 实例上写字。</p><p><code>xy</code> 指定的是文本左上角的顶点，而不是文本中心。<br><code>options</code> 中可用选项：</p><ul><li>fill = (R, G, B) ：指定线条颜色</li><li>font = ImageFont instance ：指定字体，接受一个 ImageFont 的实例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image,ImageDraw</div><div class="line"></div><div class="line">im = Image.open(<span class="string">'avatar.jpeg'</span>)</div><div class="line">drawAvatar = ImageDraw.Draw(im)</div><div class="line"></div><div class="line">xSize,ySize = im.size</div><div class="line"></div><div class="line">drawAvatar.text([<span class="number">0.95</span> * xSize,<span class="number">0.05</span> * ySize], <span class="string">"6"</span>, fill = (<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>))</div><div class="line"></div><div class="line">im.save(<span class="string">'avatar_text.jpeg'</span>)</div></pre></td></tr></table></figure><p><img src="http://orku2pa7o.bkt.clouddn.com/2017-08-22-avatar_text.jpeg" alt="avatar_text"></p><p>这里不指定 <code>font</code> ，表示使用 <code>ImageDraw</code> 的默认字体。可以发现，默认字体太小了，为了调整字体，需要借助 <code>ImageFont</code> 模块。</p><h2 id="ImageFont模块"><a href="#ImageFont模块" class="headerlink" title="ImageFont模块"></a>ImageFont模块</h2><p><code>PIL</code> 可以使用 <code>bitmap</code> 字体或者 <code>OpenType/TrueType</code> 字体。<br><code>Bitmap</code> 字体被存储在 PIL 自己的格式中，一般包含两个文件：</p><ul><li>后缀是 <code>.pil</code> ，包含字体的矩阵；</li><li>后缀是 <code>.pbm</code>，包含栅格数据。</li></ul><p><code>ImageFont</code> 模块中，可以使用 <code>load()</code> 函数加载一个 <code>bitmap</code> 字体，使用 <code>truetype(fontfile, fontsize)</code> 函数加载一个 <code>OpenType/TrueType</code> 字体(注意，这个函数需要额外安装<code>_imageingft</code>模块)。</p><p><code>OpenType</code> 标准定义了 <code>OpenType</code> 文件名称的后缀名：</p><ul><li>包含TureType字体的OpenType文件后缀名为 <code>.ttf</code></li><li>包含PostScript字体的文件后缀名为 <code>.OTF</code></li><li>包含一系列TrueType字体的字体包文件，那么后缀名为 <code>.TTC</code></li></ul><p>例子：将你的 QQ 头像（或者微博头像）右上角加上红色的数字，类似于微信未读信息数量那种提示效果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># _*_ coding:utf-8 _*_</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image,ImageDraw,ImageFont</div><div class="line"></div><div class="line"><span class="comment"># 需要传入参数：字符串，字体颜色</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawText</span><span class="params">(text,color,imageName,new_imageName)</span>:</span></div><div class="line">    avatar = Image.open(imageName)</div><div class="line">    drawAvatar = ImageDraw.Draw(avatar)</div><div class="line">    xSize,ySize = avatar.size</div><div class="line"></div><div class="line">    <span class="comment"># 指定字体大小</span></div><div class="line">    fontSize = min(xSize,ySize) // <span class="number">12</span></div><div class="line"></div><div class="line">    <span class="comment"># 引用本地TrueType格式的字体文件，创建一个ImageFont实例</span></div><div class="line">    myFont = ImageFont.truetype(<span class="string">'/Library/Fonts/Arial.ttf'</span>,fontSize)</div><div class="line"></div><div class="line">    <span class="comment"># 在图片上写字，y轴位置根据字体大小变化，fill参数指定字的颜色，font参数必须是ImageFont实例的值</span></div><div class="line">    drawAvatar.text([<span class="number">0.9</span> * xSize, <span class="number">0.1</span> * ySize - fontSize], text,fill = color, font = myFont)</div><div class="line"></div><div class="line">    avatar.save(new_imageName)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    color = (<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>)</div><div class="line">    drawText(<span class="string">'9'</span>,color,<span class="string">'avatar.jpeg'</span>,<span class="string">'avatar_new.jpeg'</span>)</div></pre></td></tr></table></figure><p><img src="http://orku2pa7o.bkt.clouddn.com/2017-08-22-avatar_new1.jpeg" alt="avatar_new1"></p><h2 id="ImageFilter模块"><a href="#ImageFilter模块" class="headerlink" title="ImageFilter模块"></a>ImageFilter模块</h2><p><code>ImageFilter</code> 是 PIL 的滤镜模块，提供了滤波器的相关定义，这些滤波器主要用于 <code>Image</code> 类的 <code>filter()</code> 方法。</p><p>滤镜名称和含义说明：</p><ul><li>ImageFilter.BLUR ：模糊滤镜</li><li>ImageFilter.CONTOUR ：轮廓</li><li>ImageFilter.EDGE_ENHANCE ：边界加强</li><li>ImageFilter.EDGE_ENHANCE_MORE ：边界加强(阀值更大)</li><li>ImageFilter.EMBOSS ：浮雕滤镜</li><li>ImageFilter.FIND_EDGES ：边界滤镜</li><li>ImageFilter.SMOOTH ：平滑滤镜</li><li>ImageFilter.SMOOTH_MORE ：平滑滤镜(阀值更大)</li><li>ImageFilter.SHARPEN ：锐化滤镜</li></ul><p>例子：生成字母验证码图片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line"># _*_ coding:utf-8 _*_</div><div class="line"></div><div class="line">from PIL import Image, ImageDraw, ImageFont, ImageFilter</div><div class="line">import random</div><div class="line"></div><div class="line"># 随机字母（大写）:</div><div class="line">def rndChar():</div><div class="line">    return chr(random.randint(65, 90))</div><div class="line"></div><div class="line"># 随机颜色1:</div><div class="line">def rndColor():</div><div class="line">    return (random.randint(64, 255), random.randint(64, 255), random.randint(64, 255))</div><div class="line"></div><div class="line"># 随机颜色2:</div><div class="line">def rndColor2():</div><div class="line">    return (random.randint(32, 127), random.randint(32, 127), random.randint(32, 127))</div><div class="line"></div><div class="line"># 图片大小：240 x 60</div><div class="line">width = 60 * 4</div><div class="line">height = 60</div><div class="line"></div><div class="line"># 创建Image对象，背景为白色</div><div class="line">image = Image.new(&apos;RGB&apos;, (width, height), (255, 255, 255))</div><div class="line"># 创建Draw对象</div><div class="line">draw = ImageDraw.Draw(image)</div><div class="line"># 创建Font对象，字体为“Arial.ttf”</div><div class="line">font = ImageFont.truetype(&apos;Arial.ttf&apos;, 36)</div><div class="line"></div><div class="line"># 用随机颜色填充每个像素</div><div class="line">for x in range(width):</div><div class="line">    for y in range(height):</div><div class="line">        draw.point((x, y), fill=rndColor())</div><div class="line">        </div><div class="line"># 输出4个字母，字母颜色随机</div><div class="line">for t in range(4):</div><div class="line">    draw.text((60 * t + 10, 10), rndChar(), font=font, fill=rndColor2())</div><div class="line">    </div><div class="line"># 对图像模糊</div><div class="line">image = image.filter(ImageFilter.BLUR)</div><div class="line"></div><div class="line">image.save(&apos;code.jpg&apos;, &apos;jpeg&apos;)</div></pre></td></tr></table></figure><p><img src="http://orku2pa7o.bkt.clouddn.com/2017-08-22-code.jpg" alt="code"><br>用随机颜色填充图像的每个像素，再画上字母(颜色随机)，最后对图像进行模糊。</p><h2 id="强大图像处理库介绍"><a href="#强大图像处理库介绍" class="headerlink" title="强大图像处理库介绍"></a>强大图像处理库介绍</h2><p>Python还有个更强大的第三方图像处理库：OpenCV</p><p><code>OpenCV</code> 全称: <code>Open Source Computer Vision Library</code>，是一个开源的跨平台计算机视觉库，<a href="https://github.com/opencv/opencv" target="_blank" rel="external">GitHub地址</a>。<code>OpecCV</code> 主要用C/C++语言编写，也提供了Python、Java等语言的接口。</p><p>网上有几个写得挺不错的教程：<br><a href="https://www.kancloud.cn/aollo/aolloopencv/269602" target="_blank" rel="external">OpenCV-Python中文教程</a><br><a href="https://segmentfault.com/a/1190000003742481" target="_blank" rel="external">Python-OpenCV 图像与视频处理</a><br><a href="https://zhuanlan.zhihu.com/p/24425116" target="_blank" rel="external">给深度学习入门者的Python快速教程 - 番外篇之Python-OpenCV</a></p><h2 id="全文参考文档"><a href="#全文参考文档" class="headerlink" title="全文参考文档"></a>全文参考文档</h2><p><a href="https://liam0205.me/2015/04/22/pil-tutorial-basic-usage/" target="_blank" rel="external">PIL 简明教程 - 基本用法</a><br><a href="https://pillow.readthedocs.io/en/4.2.x/index.html" target="_blank" rel="external">Pillow官方文档</a><br><a href="http://python.jobbole.com/84956/" target="_blank" rel="external">Python图像处理库Pillow入门</a><br><a href="https://liam0205.me/2015/05/05/pil-tutorial-imagedraw-and-imagefont/" target="_blank" rel="external">PIL 简明教程 - 在现有的图片上涂涂改改</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PIL(Python Imaging Library) 是pyhton常用的图像处理库，&lt;a href=&quot;http://pythonware.com/products/pil/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;strong&gt;官方网站&lt;/strong&gt;&lt;/a&gt;，最新版本是 &lt;code&gt;1.1.7&lt;/code&gt; ，于2009年9月发布，支持Python &lt;code&gt;1.5.2 - 2.7&lt;/code&gt;。&lt;br&gt;PIL项目似乎已经停止开发了，&lt;a href=&quot;https://web.archive.org/web/20150315041249/http://hg.effbot.org/pil-2009-raclette&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;strong&gt;PIL仓库&lt;/strong&gt;&lt;/a&gt; 最后一次提交是2011年。&lt;br&gt;python 3.x 版本是无法使用原PIL库的，得使用Pillow库。&lt;/p&gt;
&lt;p&gt;Pillow 库则是 PIL 的一个友好Fork，维护和开发活跃，Pillow 兼容 PIL 的绝大多数语法，推荐使用。&lt;br&gt;Pillow 库提供了广泛的文件格式支持，强大的图像处理能力，主要包括图像储存、图像显示、格式转换以及基本的图像处理操作等。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/python-pillow/Pillow&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;strong&gt;Pillow项目仓库&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://python-pillow.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;strong&gt;Pillow官网&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://pillow.readthedocs.io/en/latest/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;strong&gt;Pillow文档&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python时间模块</title>
    <link href="http://yoursite.com/2017/Python-time-module.html"/>
    <id>http://yoursite.com/2017/Python-time-module.html</id>
    <published>2017-08-09T10:21:35.000Z</published>
    <updated>2017-08-14T03:13:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>python关于时间和日期的处理模块，常见的有以下几个：</p><blockquote><p>内置模块：time、datetime、calendar<br>第三方模块：pytz</p></blockquote><p>time模块基于C语言的库函数(library functions)，提供的接口与C标准库 time.h 基本一致。<br>datetime模块是基于time模块扩展的，提供的接口则更直观、更容易调用。datetime模块有datetime.date(日期)、datetime.time(时间)、datetime.datetime(日期时间)三个类</p><a id="more"></a><h2 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a>time模块</h2><h3 id="时间戳、元组、字符串之间相互转换"><a href="#时间戳、元组、字符串之间相互转换" class="headerlink" title="时间戳、元组、字符串之间相互转换"></a>时间戳、元组、字符串之间相互转换</h3><p>在time模块中，时间日期有三种表现形式：</p><ul><li>时间戳：一般指Unix时间戳，从 1970/1/1 0:0:0 到现在的秒数</li><li>元组形式(struct_time)：本地时间、UTC时间</li><li>格式化字符串形式</li></ul><p>三种表现形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="comment"># 时间戳</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>time.time()</div><div class="line"><span class="number">1502333067.252786</span></div><div class="line"></div><div class="line"><span class="comment"># 元组形式，分别为本地时间和UTC时间</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>time.localtime()</div><div class="line">time.struct_time(tm_year=<span class="number">2017</span>, tm_mon=<span class="number">8</span>, tm_mday=<span class="number">10</span>, tm_hour=<span class="number">10</span>, tm_min=<span class="number">45</span>, tm_sec=<span class="number">54</span>, tm_wday=<span class="number">3</span>, tm_yday=<span class="number">222</span>, tm_isdst=<span class="number">0</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>time.gmtime()</div><div class="line">time.struct_time(tm_year=<span class="number">2017</span>, tm_mon=<span class="number">8</span>, tm_mday=<span class="number">10</span>, tm_hour=<span class="number">2</span>, tm_min=<span class="number">45</span>, tm_sec=<span class="number">59</span>, tm_wday=<span class="number">3</span>, tm_yday=<span class="number">222</span>, tm_isdst=<span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="comment"># 格式化字符串</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>)</div><div class="line"><span class="string">'2017-08-10 10:46:43'</span></div></pre></td></tr></table></figure><p><img src="http://orku2pa7o.bkt.clouddn.com/2017-08-10-15023338195274.png" alt=""></p><p>如上图，三种方式相互转换(不能时间戳转格式化字符串，或者格式化字符串转时间戳，要通过中间元组形式转换)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> time</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>timestamp = time.time()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(timestamp)</div><div class="line"><span class="number">1502679390.184194</span></div><div class="line"></div><div class="line"><span class="comment"># 时间戳 转 元组形式</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>time.localtime(timestamp)</div><div class="line">time.struct_time(tm_year=<span class="number">2017</span>, tm_mon=<span class="number">8</span>, tm_mday=<span class="number">14</span>, tm_hour=<span class="number">10</span>, tm_min=<span class="number">56</span>, tm_sec=<span class="number">30</span>, tm_wday=<span class="number">0</span>, tm_yday=<span class="number">226</span>, tm_isdst=<span class="number">0</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>time.gmtime(timestamp)</div><div class="line">time.struct_time(tm_year=<span class="number">2017</span>, tm_mon=<span class="number">8</span>, tm_mday=<span class="number">14</span>, tm_hour=<span class="number">2</span>, tm_min=<span class="number">56</span>, tm_sec=<span class="number">30</span>, tm_wday=<span class="number">0</span>, tm_yday=<span class="number">226</span>, tm_isdst=<span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="comment"># 元组形式 转 时间戳</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>time.mktime(time.localtime(timestamp))</div><div class="line"><span class="number">1502679390.0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>time.mktime(time.gmtime(timestamp))</div><div class="line"><span class="number">1502650590.0</span></div><div class="line"></div><div class="line"><span class="comment"># 元组形式 转 字符串形式</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>,time.localtime(timestamp))</div><div class="line"><span class="string">'2017-08-14 10:56:30'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>,time.gmtime(timestamp))</div><div class="line"><span class="string">'2017-08-14 02:56:30'</span></div><div class="line"></div><div class="line"><span class="comment"># 字符串形式 转 元组形式</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>time.strptime(<span class="string">'2016-11-25'</span>, <span class="string">"%Y-%m-%d"</span>)</div><div class="line">time.struct_time(tm_year=<span class="number">2016</span>, tm_mon=<span class="number">11</span>, tm_mday=<span class="number">25</span>, tm_hour=<span class="number">0</span>, tm_min=<span class="number">0</span>, tm_sec=<span class="number">0</span>, tm_wday=<span class="number">4</span>, tm_yday=<span class="number">330</span>, tm_isdst=<span class="number">-1</span>)</div></pre></td></tr></table></figure><h2 id="datetime模块"><a href="#datetime模块" class="headerlink" title="datetime模块"></a>datetime模块</h2><h3 id="时间戳、datetime类型、字符串之间相互转换"><a href="#时间戳、datetime类型、字符串之间相互转换" class="headerlink" title="时间戳、datetime类型、字符串之间相互转换"></a>时间戳、datetime类型、字符串之间相互转换</h3><p>datetime模块中包含4个主要的类：</p><ul><li>datetime.time：时间类，只包含时、分、秒、微秒等时间信息。</li><li>datetime.date：日期类，只包含年、月、日、星期等日期信息。</li><li>datetime.datetime：日期时间类，包含以上两者的全部信息。</li><li>datetime.timedelta：时间日期差值类，用来表示两个datetime之间的差值。</li></ul><p>在datetime模块中，时间日期主要表现为三种常用形式：</p><ul><li>时间戳：一般指Unix时间戳，从 <code>1970-1-1 0:0:0</code> 到现在的秒数</li><li>datetime类型：本地时间、UTC时间</li><li>格式化字符串形式</li></ul><p><img src="http://orku2pa7o.bkt.clouddn.com/2017-08-10-15023354142691.jpg" alt=""><br>如上图，datetime模块的三种形式相互转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"></div><div class="line"><span class="comment"># 获取datetime.datetime类型的本地时间和UTC时间</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>datetime_local = datetime.now()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>datetime_utc = datetime.utcnow()</div><div class="line"></div><div class="line"><span class="comment"># datetime类型 转 时间戳</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>datetime_local.timestamp()</div><div class="line"><span class="number">1502336341.267918</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>datetime_utc.timestamp()</div><div class="line"><span class="number">1502307553.165676</span></div><div class="line"></div><div class="line"><span class="comment"># 时间戳 转 datetime类型 （本地时间和UTC时间）</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.fromtimestamp(time.time())</div><div class="line">datetime.datetime(<span class="number">2017</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">46</span>, <span class="number">13</span>, <span class="number">106668</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.utcfromtimestamp(time.time())</div><div class="line">datetime.datetime(<span class="number">2017</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">46</span>, <span class="number">23</span>, <span class="number">873827</span>)</div><div class="line"></div><div class="line"><span class="comment"># datetime类型 转 字符串形式</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.now().strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>)</div><div class="line"><span class="string">'2017-08-10 14:49:20'</span></div><div class="line"></div><div class="line"><span class="comment"># 字符串形式 转 datetime类型</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.strptime(<span class="string">"2017-8-10 14:47:12"</span>,<span class="string">"%Y-%m-%d %H:%M:%S"</span>)</div><div class="line">datetime.datetime(<span class="number">2017</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">47</span>, <span class="number">12</span>)</div></pre></td></tr></table></figure><p>当然，也可以将 datetime类型 转为 元组形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># datetime类型 转 元组形式 （本地时间和UTC时间）</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>datetime_local.timetuple()</div><div class="line">time.struct_time(tm_year=<span class="number">2017</span>, tm_mon=<span class="number">8</span>, tm_mday=<span class="number">10</span>, tm_hour=<span class="number">11</span>, tm_min=<span class="number">39</span>, tm_sec=<span class="number">1</span>, tm_wday=<span class="number">3</span>, tm_yday=<span class="number">222</span>, tm_isdst=<span class="number">-1</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>datetime_utc.utctimetuple()</div><div class="line">time.struct_time(tm_year=<span class="number">2017</span>, tm_mon=<span class="number">8</span>, tm_mday=<span class="number">10</span>, tm_hour=<span class="number">3</span>, tm_min=<span class="number">39</span>, tm_sec=<span class="number">13</span>, tm_wday=<span class="number">3</span>, tm_yday=<span class="number">222</span>, tm_isdst=<span class="number">0</span>)</div></pre></td></tr></table></figure><h3 id="timedelta类"><a href="#timedelta类" class="headerlink" title="timedelta类"></a>timedelta类</h3><p>datetime模块中有个timedelta类，timedelta对象代表两个时间之间的时间差，两个date 或 datetime 类型对象相减时，可以返回一个timedelta对象。</p><p>原型如下：</p><blockquote><p>class datetime.timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0)<br>所有参数可选，默认都是0，参数的值可以是整数、浮点数、正数或者负数。</p></blockquote><p>例子：计算昨天的日期时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from datetime import timedelta</div><div class="line">&gt;&gt;&gt; now = datetime.now()</div><div class="line">&gt;&gt;&gt; print(now)</div><div class="line">2017-08-14 11:11:19.815021</div><div class="line">&gt;&gt;&gt; now</div><div class="line">datetime.datetime(2017, 8, 14, 11, 11, 19, 815021)</div><div class="line">&gt;&gt;&gt; now - timedelta(days=1)</div><div class="line">datetime.datetime(2017, 8, 13, 11, 11, 19, 815021)</div></pre></td></tr></table></figure><h3 id="timezone类"><a href="#timezone类" class="headerlink" title="timezone类"></a>timezone类</h3><p>datetime模块中有个timezone类，是tzinfo的子类。timezone类，其每个实例表示由与UTC的固定偏移量定义的时区。</p><blockquote><p>class datetime.timezone(offset, name=None)</p></blockquote><ul><li>offset 参数必须指定为表示本地时间和UTC之间差异的 timedelta 对象。它必须严格地在 -timedelta(hours=24) 和 timedelta(hours=24) 之间，并且表示整数分钟，否则产生 ValueError。</li><li>name 参数是可选的。如果指定，它必须是将被用作 datetime.tzname() 方法返回值的字符串。</li></ul><p>Python3.2开始才提供了datetime.timezone类。</p><h4 id="本地时间转UTC时间"><a href="#本地时间转UTC时间" class="headerlink" title="本地时间转UTC时间"></a>本地时间转UTC时间</h4><p>本地时间是指系统设定时区的时间，例如北京时间是UTC+8:00时区的时间，而UTC时间指UTC+0:00时区的时间。</p><p>一个datetime类型有一个时区属性tzinfo，但是默认为None，所以无法区分这个datetime到底是哪个时区，除非强行给datetime设置一个时区：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime,timedelta,timezone</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>tz_utc_8 = timezone(timedelta(hours=<span class="number">8</span>))  <span class="comment"># 创建时区UTC+8:00</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.now()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>now</div><div class="line">datetime.datetime(<span class="number">2017</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">17</span>, <span class="number">21</span>, <span class="number">35</span>, <span class="number">983594</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dt = now.replace(tzinfo=tz_utc_8)  <span class="comment"># 强制设置为UTC+8:00时区</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dt</div><div class="line">datetime.datetime(<span class="number">2017</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">17</span>, <span class="number">21</span>, <span class="number">35</span>, <span class="number">983594</span>, tzinfo=datetime.timezone(datetime.timedelta(<span class="number">0</span>, <span class="number">28800</span>)))</div></pre></td></tr></table></figure><p>例子：获取用户输入的日期和时间，如<code>2017-8-10 15:02:11</code>，以及一个时区信息<code>UTC+6:00</code>，均是字符串类型，编写一个函数将其转换为timestamp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timezone, timedelta</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_timestamp</span><span class="params">(dt_str, tz_str)</span>:</span></div><div class="line">    date = datetime.strptime(dt_str, <span class="string">'%Y-%m-%d %H:%M:%S'</span>)  <span class="comment"># 字符串 转 datetime类型</span></div><div class="line">    tz_int = int(re.search(<span class="string">'(\-|\+)\d+'</span>, tz_str).group())  <span class="comment"># 正则匹配，获取时区号(+或-)</span></div><div class="line">    tz_utc_x = timezone(timedelta(hours=tz_int)) <span class="comment"># 时区变量</span></div><div class="line">    date_utc = date.replace(tzinfo=tz_utc_x) <span class="comment"># 强制设置时区</span></div><div class="line">    tstamp = date_utc.timestamp()  <span class="comment"># datetime类型 转 时间戳</span></div><div class="line">    <span class="keyword">return</span> tstamp</div><div class="line"></div><div class="line"><span class="comment"># 测试</span></div><div class="line">t1 = to_timestamp(<span class="string">'2015-6-1 08:10:30'</span>, <span class="string">'UTC+7:00'</span>)</div><div class="line"><span class="keyword">assert</span> t1 == <span class="number">1433121030.0</span>, t1</div></pre></td></tr></table></figure><h2 id="time模块和datetime模块之间相互转换"><a href="#time模块和datetime模块之间相互转换" class="headerlink" title="time模块和datetime模块之间相互转换"></a>time模块和datetime模块之间相互转换</h2><p>time 转 datetime</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; timestamp = time.time()</div><div class="line">&gt;&gt;&gt; datetime.fromtimestamp(timestamp)</div><div class="line">datetime.datetime(2017, 8, 10, 14, 57, 47, 666371)</div></pre></td></tr></table></figure><p>datetime 转 time：先将datetime类型转为元组形式，再转为时间戳</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; datetime_local = datetime.now()</div><div class="line">&gt;&gt;&gt; time.mktime(datetime_local.timetuple())</div><div class="line">1502348313.0</div></pre></td></tr></table></figure><h2 id="pytz模块"><a href="#pytz模块" class="headerlink" title="pytz模块"></a>pytz模块</h2><p>pytz模块，使用<a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones" target="_blank" rel="external">Olson TZ Database</a>解决了跨平台的时区计算一致性问题，解决了夏令时带来的计算问题。</p><p>参考资料：<br><a href="https://zhuanlan.zhihu.com/p/23679915" target="_blank" rel="external">你真的了解Python中的日期时间处理吗？</a><br><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431937554888869fb52b812243dda6103214cd61d0c2000" target="_blank" rel="external">廖雪峰python教程-datetime模块</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python关于时间和日期的处理模块，常见的有以下几个：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;内置模块：time、datetime、calendar&lt;br&gt;第三方模块：pytz&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;time模块基于C语言的库函数(library functions)，提供的接口与C标准库 time.h 基本一致。&lt;br&gt;datetime模块是基于time模块扩展的，提供的接口则更直观、更容易调用。datetime模块有datetime.date(日期)、datetime.time(时间)、datetime.datetime(日期时间)三个类&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>换源总集</title>
    <link href="http://yoursite.com/2017/Change-source-collection.html"/>
    <id>http://yoursite.com/2017/Change-source-collection.html</id>
    <published>2017-08-08T09:46:26.000Z</published>
    <updated>2017-09-01T02:28:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>很多国外镜像，在国内访问会很慢。遇到这种情况，可以通过两种方法解决：</p><blockquote><p>使用代理<br>更换为国内源</p></blockquote><p>这里总结常用的换源和介绍国内较好的源。</p><a id="more"></a><h2 id="Pypi-换源"><a href="#Pypi-换源" class="headerlink" title="Pypi 换源"></a>Pypi 换源</h2><h3 id="mac系统"><a href="#mac系统" class="headerlink" title="mac系统"></a>mac系统</h3><p>要注意，mac在家目录中默认没有 <code>.pip</code> 目录，要自己创建<br>进入家目录，新建 <code>.pip</code> 目录，在该目录中新建一个文件 <code>pip.conf</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cd ~</div><div class="line">$ mkdir .pip</div><div class="line">$ touch .pip/pip.conf</div></pre></td></tr></table></figure><p>编辑 <code>pip.conf</code> 配置文件，加入国内的pypi源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 阿里云的pypi源</span></div><div class="line">[global]</div><div class="line">index-url = http://mirrors.aliyun.com/pypi/simple/</div><div class="line"></div><div class="line">[install]</div><div class="line">trusted-host=mirrors.aliyun.com</div></pre></td></tr></table></figure><p>或者：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 豆瓣的pypi源</span></div><div class="line">[global]</div><div class="line">index-url = http://pypi.douban.com/simple</div><div class="line"></div><div class="line">[install]</div><div class="line">trusted-host=pypi.douban.com</div></pre></td></tr></table></figure><h2 id="Homebrew-换源"><a href="#Homebrew-换源" class="headerlink" title="Homebrew 换源"></a>Homebrew 换源</h2><p>Homebrew是一款自由及开放源代码的软件包管理系统，用以简化 Mac OS 系统上的软件安装过程。<br>Homebrew主要分两部分：git repo（位于GitHub）和 二进制bottles（位于bintray），这两者在国内访问都不太顺畅。可以替换成国内的镜像。</p><p><a href="https://lug.ustc.edu.cn/wiki/mirrors/help/brew.git" target="_blank" rel="external">USTC的官方文档</a></p><h3 id="替换和重置Homebrew默认源"><a href="#替换和重置Homebrew默认源" class="headerlink" title="替换和重置Homebrew默认源"></a>替换和重置Homebrew默认源</h3><p>这里使用中科大的镜像，速度蛮快的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 替换brew.git</span></div><div class="line">$ <span class="built_in">cd</span> <span class="string">"<span class="variable">$(brew --repo)</span>"</span></div><div class="line">$ git remote <span class="built_in">set</span>-url origin https://mirrors.ustc.edu.cn/brew.git</div></pre></td></tr></table></figure><p>当中科大源失效或宕机时，可以切回官方源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 重置brew.git</div><div class="line">$ cd &quot;$(brew --repo)&quot;</div><div class="line">$ git remote set-url origin https://github.com/Homebrew/brew.git</div></pre></td></tr></table></figure><h3 id="替换和重置Homebrew-Bottles源"><a href="#替换和重置Homebrew-Bottles源" class="headerlink" title="替换和重置Homebrew Bottles源"></a>替换和重置Homebrew Bottles源</h3><p>Homebrew Bottles是Homebrew提供的二进制代码包。<br>对于bash用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ echo &apos;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&apos; &gt;&gt; ~/.bash_profile</div><div class="line">$ source ~/.bash_profile</div></pre></td></tr></table></figure><p>对于zsh用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ echo &apos;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&apos; &gt;&gt; ~/.zshrc</div><div class="line">$ source ~/.zshrc</div></pre></td></tr></table></figure><p>注释掉bash或zsh配置文件里的有关Homebrew Bottles即可恢复官方源。然后重读该配置文件使其生效。</p><h2 id="Docker换源"><a href="#Docker换源" class="headerlink" title="Docker换源"></a>Docker换源</h2><p>国内有3家的Docker镜像源蛮不错，速度挺快的：</p><ul><li>DaoCloud</li><li>USTC(中科大)</li><li>阿里云</li></ul><h3 id="DaoCloud的Docker加速器"><a href="#DaoCloud的Docker加速器" class="headerlink" title="DaoCloud的Docker加速器"></a>DaoCloud的Docker加速器</h3><p>DaoCloud加速器需要用户注册，每个用户每月限制10GB。注册登录后，访问<a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="external"><strong>配置Docker加速器</strong></a>，会介绍如何使用。</p><p><img src="http://orku2pa7o.bkt.clouddn.com/2017-08-31-15041926638654.jpg" alt=""><br>红色涂改处的地址，会根据每个人ID不同而有不同。记得设置后，要重新启动docker服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># service docker restart</div></pre></td></tr></table></figure><p>注意，该Docker加速器对Docker版本有要求，需要 Docker 1.8 或更高版本才能使用。</p><h3 id="USTC的Docker镜像"><a href="#USTC的Docker镜像" class="headerlink" title="USTC的Docker镜像"></a>USTC的Docker镜像</h3><p>官方文档 <a href="https://lug.ustc.edu.cn/wiki/mirrors/help/docker" target="_blank" rel="external"><strong>Docker镜像使用帮助</strong></a> 里已写得很清楚，这里就不冗余的贴出来。<br>USTC的镜像源做的很好，速度很快，个人强烈推荐使用。</p><h3 id="阿里云的Docker加速器"><a href="#阿里云的Docker加速器" class="headerlink" title="阿里云的Docker加速器"></a>阿里云的Docker加速器</h3><p>阿里云的会繁琐点，不仅要注册为阿里云用户，还要加入<a href="https://dev.aliyun.com/search.html" target="_blank" rel="external">开发者平台</a>。<br>配置方法跟DaoCloud的类似，也是开通加速器后给一个URL，详情看：<a href="https://yq.aliyun.com/articles/29941" target="_blank" rel="external"><strong>Docker镜像加速器的配置</strong></a></p><p><img src="http://orku2pa7o.bkt.clouddn.com/2017-08-31-15041942060010.jpg" alt=""><br>阿里云的Docker加速器，要求Docker版本 大于 1.10 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多国外镜像，在国内访问会很慢。遇到这种情况，可以通过两种方法解决：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用代理&lt;br&gt;更换为国内源&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里总结常用的换源和介绍国内较好的源。&lt;/p&gt;
    
    </summary>
    
      <category term="技术杂项" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="杂项" scheme="http://yoursite.com/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>Git常用操作</title>
    <link href="http://yoursite.com/2017/Git-common-operations.html"/>
    <id>http://yoursite.com/2017/Git-common-operations.html</id>
    <published>2017-07-26T03:22:04.000Z</published>
    <updated>2017-09-11T10:45:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>整理Git的常用命令，方便以后查找。</p><a id="more"></a><h3 id="配置用户信息"><a href="#配置用户信息" class="headerlink" title="配置用户信息"></a>配置用户信息</h3><p>Git的设置文件为 <code>.gitconfig</code> ，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><p>设置用户名称和邮箱地址，<code>--global</code> 表示全局设置，本机上所有的Git仓库通用该配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name &quot;[name]&quot;</div><div class="line">$ git config --global user.email &quot;[email address]&quot;</div></pre></td></tr></table></figure><p>查看配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查看[仓库级|全局级|系统级]的 config</span></div><div class="line">$ git config [--<span class="built_in">local</span>|--global|--system] -l</div><div class="line"></div><div class="line"><span class="comment"># 查看当前生效的配置</span></div><div class="line">$ git config -l</div></pre></td></tr></table></figure><p>编辑配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查看仓库级的config</span></div><div class="line">$ git config --<span class="built_in">local</span> -e</div><div class="line">$ git config -e </div><div class="line"></div><div class="line"><span class="comment"># 查看全局级的config</span></div><div class="line">$ git config --global -e</div><div class="line"></div><div class="line"><span class="comment"># 查看系统级的config</span></div><div class="line">$ git config --system -e</div></pre></td></tr></table></figure><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 添加指定文件到暂存区，可指定多个文件</span></div><div class="line">$ git add [file1] [dir/file2] ...</div><div class="line"></div><div class="line"><span class="comment"># 添加指定文件到暂存区，可指定通配符；如 *.txt，匹配所有txt文件</span></div><div class="line">$ git add [file-pattern]</div><div class="line"></div><div class="line"><span class="comment"># 添加指定目录到暂存区，包括子目录</span></div><div class="line">$ git add [dir]</div><div class="line"></div><div class="line"><span class="comment"># 添加当前目录的所有文件到暂存区</span></div><div class="line">$ git add .</div></pre></td></tr></table></figure><h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 提交暂存区所有文件到仓库区，一定要记得添加提交信息(message)</span></div><div class="line">$ git commit -m [message]</div><div class="line"></div><div class="line"><span class="comment"># 提交暂存区的指定文件到仓库区</span></div><div class="line">$ git commit [file1] [file2] ... -m [message]</div><div class="line"></div><div class="line"><span class="comment"># 提交工作区自上次commit之后的变化，直接到仓库区 (省略 git add 那一步)</span></div><div class="line">$ git commit -a </div><div class="line"></div><div class="line"><span class="comment"># 使用一次新的commit，替代上一次提交</span></div><div class="line"><span class="comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></div><div class="line">$ git commit --amend -m [message]</div><div class="line"></div><div class="line"><span class="comment"># 重做上一次commit，并包括指定文件的新变化</span></div><div class="line">$ git commit --amend [file1] [file2] ...</div></pre></td></tr></table></figure><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 删除工作区文件(已被追踪的文件)，并将这次删除放入暂存区</span></div><div class="line">$ git rm [file1] [file2] ...</div><div class="line"></div><div class="line"><span class="comment"># 停止追踪指定文件(在暂存区中删除)，但该文件会保留在工作区</span></div><div class="line">$ git rm --cached [file]</div><div class="line"></div><div class="line"><span class="comment"># 文件改名(工作区)，并将这个改名放入暂存区</span></div><div class="line">$ git mv [file-oldname] [file-newname]</div></pre></td></tr></table></figure><h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 检查当前文件状态</span></div><div class="line">$ git status</div><div class="line"></div><div class="line"><span class="comment"># 显示当前分支的版本历史(按提交时间排序)</span></div><div class="line">$ git <span class="built_in">log</span></div><div class="line"></div><div class="line"><span class="comment"># 简洁模式，每个提交只显示一行信息，包括 commit id（版本号）和 提交说明</span></div><div class="line">$ git <span class="built_in">log</span> --pretty=oneline</div><div class="line"></div><div class="line"><span class="comment"># 显示暂存区和工作区的差异</span></div><div class="line">$ git diff</div><div class="line"></div><div class="line"><span class="comment"># 显示暂存区和上一个commit的差异</span></div><div class="line">$ git diff --cached [file]</div><div class="line"></div><div class="line"><span class="comment"># 显示工作区与当前分支最新commit之间的差异</span></div><div class="line">$ git diff HEAD</div><div class="line"></div><div class="line"><span class="comment"># 显示两次提交之间的差异</span></div><div class="line">$ git diff [first-commit]..[second-commit]</div><div class="line"></div><div class="line"><span class="comment"># 显示某次提交的元数据和内容变化</span></div><div class="line">$ git show [commit-id]</div><div class="line"></div><div class="line"><span class="comment"># 显示当前分支的最近几次操作(操作历史)</span></div><div class="line">$ git reflog</div></pre></td></tr></table></figure><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 列出所有的分支，"*" 标识的是当前分支</span></div><div class="line">$ git branch </div><div class="line"></div><div class="line"><span class="comment"># 列出所有远程分支</span></div><div class="line">$ git branch -r</div><div class="line"></div><div class="line"><span class="comment"># 列出所有本地分支和远程分支</span></div><div class="line">$ git branch -a</div><div class="line"></div><div class="line"><span class="comment"># 新建分支，但仍停留在当前分支</span></div><div class="line">$ git branch [branch-name]</div><div class="line"></div><div class="line"><span class="comment"># 新建分支，并切换到该分支</span></div><div class="line">$ git checkout -b [branch-name]</div><div class="line"></div><div class="line"><span class="comment"># 切换到指定分支，并更新工作区</span></div><div class="line">$ git checkout [branch-name]</div><div class="line"></div><div class="line"><span class="comment"># 合并指定分支到当前分支</span></div><div class="line">$ git merge [branch-name]</div><div class="line"></div><div class="line"><span class="comment"># 删除分支</span></div><div class="line">$ git branch -d [branch-name]</div></pre></td></tr></table></figure><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 列出所有tag</span></div><div class="line">$ git tag</div><div class="line"></div><div class="line"><span class="comment"># 新建一个tag在当前commit</span></div><div class="line">$ git tag [tag-name]</div><div class="line"></div><div class="line"><span class="comment"># 新建一个tag在指定commit</span></div><div class="line">$ git tag [tag-name] [commit-id]</div><div class="line"></div><div class="line"><span class="comment"># 新建一个tag，并指定标签注释说明</span></div><div class="line">$ git tag -a [tag-name] -m <span class="string">"message"</span></div><div class="line"></div><div class="line"><span class="comment"># 提交指定tag到指定远程仓库（ git push 默认不提交标签到远程仓库）</span></div><div class="line">$ git push [remote-name] [tag-name]</div><div class="line"></div><div class="line"><span class="comment"># 提交所有的tag到指定远程仓库</span></div><div class="line">$ git push [remote-name] --tags</div><div class="line"></div><div class="line"><span class="comment"># 查看tag信息</span></div><div class="line">$ git show [tag-name]</div><div class="line"></div><div class="line"><span class="comment"># 删除本地tag</span></div><div class="line">$ git tag -d [tag-name]</div><div class="line"></div><div class="line"><span class="comment"># 删除指定远程仓库的tag</span></div><div class="line">$ git push [remote-name] :refs/tags/[tag-name]</div></pre></td></tr></table></figure><h3 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h3><p>默认远程仓库名：origin<br>默认分支：master</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 抓取指定远程仓库的所有变动，不做合并，不影响工作区</span></div><div class="line">$ git fetch [remote]</div><div class="line"></div><div class="line"><span class="comment"># 显示所有远程仓库(显示仓库地址)</span></div><div class="line">$ git remote -v</div><div class="line"></div><div class="line"><span class="comment"># 显示指定远程仓库的信息(仓库地址、HEAD指向分支、所有分支等)</span></div><div class="line">$ git remote show [remote-name]</div><div class="line"></div><div class="line"><span class="comment"># 增加一个新的远程仓库，并命名</span></div><div class="line">$ git remote add [remote-name] [url]</div><div class="line"></div><div class="line"><span class="comment"># 删除指定的远程仓库</span></div><div class="line">$ git remote remove [remote-name]</div><div class="line"></div><div class="line"><span class="comment"># 取回指定远程仓库的变化，并与本地分支合并</span></div><div class="line">$ git pull [remote-name] [branch-name]</div><div class="line"></div><div class="line"><span class="comment"># 上传本地指定分支到指定远程仓库</span></div><div class="line">$ git push [remote-name] [branch-name]</div><div class="line"></div><div class="line"><span class="comment"># 推送所有分支到指定远程仓库</span></div><div class="line">$ git push [remote-name] --all</div><div class="line"></div><div class="line"><span class="comment"># 强行推送当前分支到指定远程仓库，即使有冲突</span></div><div class="line">$ git push [remote-name] --force</div></pre></td></tr></table></figure><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 恢复暂存区指定文件到工作区( 没"--"，就变成切换分支了 )</span></div><div class="line">$ git checkout -- [file]</div><div class="line"></div><div class="line"><span class="comment"># 恢复某个commit的指定文件到暂存区和工作区</span></div><div class="line">$ git checkout [commit-id] [file]</div><div class="line"></div><div class="line"><span class="comment"># 恢复暂存区的所有文件到工作区</span></div><div class="line">$ git checkout .</div><div class="line"></div><div class="line"><span class="comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></div><div class="line">$ git reset [file]</div><div class="line"></div><div class="line"><span class="comment"># 重置暂存区与工作区，与上一次commit保持一致</span></div><div class="line">$ git reset --hard</div><div class="line"></div><div class="line"><span class="comment"># 暂时将未提交的变化移到堆栈中(工作区变干净)</span></div><div class="line"><span class="comment"># 从堆栈中恢复最新的存储，--index 重新应用之前被暂存的变更</span></div><div class="line">$ git stash</div><div class="line">$ git stash pop [--index]</div></pre></td></tr></table></figure><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 新建一个commit，用来撤销指定的commit（commit历史会保留）</span></div><div class="line"><span class="comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span></div><div class="line">$ git revert [commit-id]</div><div class="line"></div><div class="line"><span class="comment"># 回滚到commit-id，将该commit-id之后的commit都删除。(commit历史会被删掉)</span></div><div class="line"><span class="comment"># --hard 重设暂存区和工作区</span></div><div class="line">$ git reset --hard [commit-id]</div></pre></td></tr></table></figure><p>抄自阮一峰老师的博文：<a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="external">常用 Git 命令清单</a></p><p>基本没啥自己整理的，该篇博文权当自己备忘用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理Git的常用命令，方便以后查找。&lt;/p&gt;
    
    </summary>
    
      <category term="版本控制" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>利用GitLab的Webhooks功能，实现网站代码自动更新部署</title>
    <link href="http://yoursite.com/2017/The-site-code-auto-update-with-GitLab-webhooks.html"/>
    <id>http://yoursite.com/2017/The-site-code-auto-update-with-GitLab-webhooks.html</id>
    <published>2017-07-04T08:33:42.000Z</published>
    <updated>2017-07-06T10:16:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>根据业务需求，已部署GitLab-CE，网站代码上线流程如下图：</p><p><img src="http://orku2pa7o.bkt.clouddn.com/2017-07-06-14993278977067.jpg" alt=""></p><p>开发者 push 推送代码之后，网站代码仍没更新，还需要操作多一步：<strong>登录前端web服务器，手动git pull 拉取更新的代码</strong>。这一步是运维的工作，很无趣又烦琐。</p><p>幸亏，GitLab提供了Webhooks功能，可以轻松实现网站代码自动更新部署。</p><p><img src="http://orku2pa7o.bkt.clouddn.com/2017-07-06-14993282026422.jpg" alt=""></p><a id="more"></a><h2 id="一、webhooks原理"><a href="#一、webhooks原理" class="headerlink" title="一、webhooks原理"></a>一、webhooks原理</h2><p><a href="https://docs.gitlab.com/ce/user/project/integrations/webhooks.html" target="_blank" rel="external">Webhooks的原理</a></p><blockquote><p>Project webhooks allow you to trigger a URL if for example new code is pushed or a new issue is created.<br>You can configure webhooks to listen for specific events like pushes, issues or merge requests. GitLab will send a POST request with data to the webhook URL.<br>Webhooks can be used to update an external issue tracker, trigger CI jobs, update a backup mirror, or even deploy to your production server.</p></blockquote><p>简单说明</p><blockquote><p>webhooks允许指定一个URL，用于触发push或其他事件时进行自定义操作。<br>例如，当开发者push代码到GitLab服务器，会触发push事件，GitLab会发送一个POST请求连带数据（<a href="https://docs.gitlab.com/ce/user/project/integrations/webhooks.html#push-events" target="_blank" rel="external">数据格式</a>）给webhooks指定的URL，该URL可以是前端web的php程序或Python程序等。这样，每当GitLab有push事件，就能在前端web服务器上执行一个脚本程序。</p></blockquote><p>使用webhooks的步骤：</p><ul><li>在前端web服务器上安装Git客户端，用于拉取远程仓库 git pull</li><li>创建并添加公钥，以便免密码拉取远程仓库</li><li>创建脚本程序，并配置webhooks</li></ul><h2 id="二、安装Git客户端"><a href="#二、安装Git客户端" class="headerlink" title="二、安装Git客户端"></a>二、安装Git客户端</h2><p>在前端web服务器上，执行以下安装命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># yum install git</span></div></pre></td></tr></table></figure><h2 id="三、创建并添加公钥"><a href="#三、创建并添加公钥" class="headerlink" title="三、创建并添加公钥"></a>三、创建并添加公钥</h2><p>前端web服务器的 nginx 和 php-fpm 都是以 www 用户来运行的，所以要为www用户创建并添加公钥。</p><p>www 用户的家目录是:  /home/www/</p><p>修改 www 用户的 shell 为 /bin/bash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">www:x:511:511::/home/www:/bin/bash</div></pre></td></tr></table></figure><h3 id="创建用户的公钥"><a href="#创建用户的公钥" class="headerlink" title="创建用户的公钥"></a>创建用户的公钥</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># su www</span></div><div class="line">$ ssh-keygen -t rsa</div></pre></td></tr></table></figure><p>遇到交互，全部回车就好。<br>最后会在/home/www/.ssh 目录下生成两个文件，私钥文件：id_rsa，公钥文件：id_rsa.pub</p><h3 id="添加公钥到GitLab后台"><a href="#添加公钥到GitLab后台" class="headerlink" title="添加公钥到GitLab后台"></a>添加公钥到GitLab后台</h3><p>获取www用户的公钥文件内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /home/www/.ssh/id_rsa.pub</div></pre></td></tr></table></figure><p>复制公钥内容，添加公钥，GitLab后台添加公钥的位置：管理员 &gt; Settings &gt; SSH Keys</p><p><img src="http://orku2pa7o.bkt.clouddn.com/17-7-5/48924488.jpg" alt=""></p><h3 id="修改网站根目录的权限"><a href="#修改网站根目录的权限" class="headerlink" title="修改网站根目录的权限"></a>修改网站根目录的权限</h3><p>修改网站根目录( /home/www/test/ ) 的权限，否则以www用户git pull 会报权限问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># chmod 775 /home/www/test/ -R</div><div class="line"># chown www.www /home/www/test/ -R</div></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试www用户基于公钥是否能从Git服务器远程拉取代码</p><p>手动执行pull操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># su www</span></div><div class="line">$ <span class="built_in">cd</span> /home/www/<span class="built_in">test</span>/  </div><div class="line">$ git pull</div></pre></td></tr></table></figure><h2 id="四、部署webhooks"><a href="#四、部署webhooks" class="headerlink" title="四、部署webhooks"></a>四、部署webhooks</h2><h3 id="编写webhooks应用的PHP程序"><a href="#编写webhooks应用的PHP程序" class="headerlink" title="编写webhooks应用的PHP程序"></a>编写webhooks应用的PHP程序</h3><p>在前端web服务器的网站根目录（/home/www/test/）下新建一个webhooks.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">//网站目录</span></div><div class="line">$www_file=<span class="string">'/home/www/test/'</span>;</div><div class="line"></div><div class="line"><span class="comment">//打开网站目录下的hooks.log文件,需要在服务器上创建,并给写权限</span></div><div class="line">$fs = fopen(<span class="string">'/home/www/test/hooks.log'</span>, <span class="string">'a'</span>);</div><div class="line"></div><div class="line">fwrite($fs, <span class="string">'================ Update Start ==============='</span>.PHP_EOL.PHP_EOL);</div><div class="line"></div><div class="line"><span class="comment">//自定义字串掩码 用于验证</span></div><div class="line">$access_token = <span class="string">'QhNO8YHqym5PHQQsexapF7041xOhzm62DRH'</span>;</div><div class="line"></div><div class="line"><span class="comment">//接受的ip数组，也就是允许哪些IP访问这个文件 这里是gitlab服务器IP</span></div><div class="line">$access_ip = <span class="keyword">array</span>(<span class="string">'192.168.1.15'</span>,<span class="string">'14.xxx.xxx.19'</span>);</div><div class="line"></div><div class="line"><span class="comment">//如果使用www.xxx.com/xxx.php?token=xxxxxxx 的方式来传送验证字符串，则用这个方法获取</span></div><div class="line"><span class="comment"># $client_token = $_GET['token'];</span></div><div class="line"></div><div class="line"><span class="comment">// 获取请求端的secret token</span></div><div class="line">$client_token = $_SERVER[<span class="string">"HTTP_X_GITLAB_TOKEN"</span>];</div><div class="line"></div><div class="line"><span class="comment">//获取请求端的IP</span></div><div class="line">$client_ip = $_SERVER[<span class="string">'REMOTE_ADDR'</span>];</div><div class="line"></div><div class="line"><span class="comment">//把请求的IP和时间写进log</span></div><div class="line">fwrite($fs, <span class="string">'Request on ['</span>.date(<span class="string">"Y-m-d H:i:s"</span>).<span class="string">'] from ['</span>.$client_ip.<span class="string">']'</span>.PHP_EOL);</div><div class="line"></div><div class="line"><span class="comment">//验证token 有错就写进日志并退出</span></div><div class="line"><span class="keyword">if</span> ($client_token !== $access_token)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">"error 403"</span>;</div><div class="line">    fwrite($fs, <span class="string">"Invalid token [&#123;$client_token&#125;]"</span>.PHP_EOL);</div><div class="line">    <span class="keyword">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//验证ip</span></div><div class="line"><span class="keyword">if</span> ( !in_array($client_ip, $access_ip))</div><div class="line">&#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">"error 503"</span>;</div><div class="line">    fwrite($fs, <span class="string">"Invalid ip [&#123;$client_ip&#125;]"</span>.PHP_EOL);</div><div class="line">    <span class="keyword">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//获取请求端发送来的信息，具体格式参见gitlab的文档</span></div><div class="line">$json = file_get_contents(<span class="string">'php://input'</span>);</div><div class="line">$data = json_decode($json, <span class="keyword">true</span>);</div><div class="line"></div><div class="line"><span class="comment">//如果有需要 可以打开下面，把传送过来的信息写进log</span></div><div class="line"><span class="comment"># fwrite($fs, 'Data: '.print_r($data, true).PHP_EOL);</span></div><div class="line"></div><div class="line"><span class="comment">//执行shell命令并把返回信息写进日志</span></div><div class="line">$output=shell_exec(<span class="string">"cd $www_file &amp;&amp; git pull 2&gt;&amp;1"</span>);</div><div class="line">fwrite($fs, <span class="string">'Info:'</span>. $output.PHP_EOL);</div><div class="line"></div><div class="line">fwrite($fs,PHP_EOL. <span class="string">'================ Update End ==============='</span>.PHP_EOL.PHP_EOL);</div><div class="line"></div><div class="line">$fs <span class="keyword">and</span> fclose($fs);</div><div class="line"></div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure><h3 id="修改PHP配置"><a href="#修改PHP配置" class="headerlink" title="修改PHP配置"></a>修改PHP配置</h3><p>因为webhooks用到的php代码中使用了 shell_exec 函数，一般配置php会禁止这个函数，需要打开 shell_exec 函数。<br>修改前端web服务器上php.ini的 disable_functions 列表，去掉 shell_exec 。<br>重启php-fpm服务。</p><h3 id="配置GitLab"><a href="#配置GitLab" class="headerlink" title="配置GitLab"></a>配置GitLab</h3><p>project &gt; Settings &gt; Integrations</p><p><img src="http://orku2pa7o.bkt.clouddn.com/2017-07-06-14993335564376.jpg" alt=""></p><p>Secret Token中字符串的值，要跟webhooks.php中$access_token 的值相同。<br>Enable SSL verification 不要勾。</p><p><img src="http://orku2pa7o.bkt.clouddn.com/2017-07-06-14993342147315.jpg" alt=""></p><p>可以按 [Test] 按钮，测试配置是否生效。</p><h2 id="五、遇到的问题"><a href="#五、遇到的问题" class="headerlink" title="五、遇到的问题"></a>五、遇到的问题</h2><p>在部署webhooks中，遇到了个很诡异的问题。</p><p>前提说明</p><blockquote><p>GitLab-CE 版本：9.2.6<br>使用<a href="https://gitlab.com/xhang/gitlab" target="_blank" rel="external">xhang项目</a>对GitLab-CE进行汉化过</p></blockquote><p>问题描述：</p><blockquote><p>已成功部署webhooks，按 [Test] 按钮测试正常。<br>但在实际使用中，开发者push代码后，webhooks.php没有被执行，前端web代码没有git pull 记录，日志也没有记录。<strong>GitLab没有检测到开发者的push事件。</strong></p></blockquote><p>问题分析：</p><ul><li>通过另外部署一套同版本的、不打汉化补丁的GitLab-CE，发现不是汉化补丁的问题。</li><li>回想起之前遇到的一个问题，在GitLab-CE上新创建test项目时，开发者push后，GitLab上仍然显示该项目是空项目，无法检测到push事件，后来还是通过修改项目名来使得其能识别push事件。</li></ul><p>问题解决：</p><blockquote><p>后来偶然发现，webhooks时GitLab没有及时检测到开发者的push事件，是因为对 <strong>/var/opt/gitlab/</strong> 目录做了软链接的缘故。<br>去掉软链接，改为正常的目录路径。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据业务需求，已部署GitLab-CE，网站代码上线流程如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://orku2pa7o.bkt.clouddn.com/2017-07-06-14993278977067.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;开发者 push 推送代码之后，网站代码仍没更新，还需要操作多一步：&lt;strong&gt;登录前端web服务器，手动git pull 拉取更新的代码&lt;/strong&gt;。这一步是运维的工作，很无趣又烦琐。&lt;/p&gt;
&lt;p&gt;幸亏，GitLab提供了Webhooks功能，可以轻松实现网站代码自动更新部署。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://orku2pa7o.bkt.clouddn.com/2017-07-06-14993282026422.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="版本控制" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git问题集锦</title>
    <link href="http://yoursite.com/2017/Git-problem-sets.html"/>
    <id>http://yoursite.com/2017/Git-problem-sets.html</id>
    <published>2017-06-27T07:42:24.000Z</published>
    <updated>2017-09-14T08:16:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录Git使用过程中出现的问题<br><a id="more"></a></p><h2 id="git子模块问题"><a href="#git子模块问题" class="headerlink" title="git子模块问题"></a>git子模块问题</h2><p>最近要将某个项目的代码加入Git版本控制，在该项目目录做Git初始化后，提交推送到Git服务器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># cd test</span></div><div class="line"><span class="comment"># git init</span></div><div class="line"><span class="comment"># git remote add origin git@gitlab.xxx.com:test/test.git</span></div><div class="line"><span class="comment"># git add .</span></div><div class="line"><span class="comment"># git commit -m "Initial commit"</span></div><div class="line"><span class="comment"># git push -u origin master</span></div></pre></td></tr></table></figure><p>将该项目拉到本地电脑的时候，出现了问题，monolog目录下没有拉到任何文件</p><p><img src="http://orku2pa7o.bkt.clouddn.com/17-6-27/86605188.jpg" alt=""></p><p>手动在项目代码服务器上 git add 该目录下的文件，也报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fatal: Pathspec &apos;composer.json&apos; is in submodule &apos;web/passport_v3/vendor/monolog/monolog/&apos;</div></pre></td></tr></table></figure><p><strong>分析：</strong><br>monolog 本身就是一个git库，父目录被Git初始化后，monolog目录变成了子模块。</p><p>现在，不需要将monolog目录作为子模块。</p><p><strong>解决方法：</strong></p><ul><li>删除monolog目录下git相关的文件，如.git目录、.gitignore等</li><li>用git rm –cached 删除已经被提交到暂存区的特定文件，重新添加提交</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># cd test</span></div><div class="line"><span class="comment"># git rm -rf --cached web/passport_v3/vendor/monolog/monolog/</span></div><div class="line"><span class="comment"># git add web/passport_v3/vendor/monolog/monolog/</span></div><div class="line"><span class="comment"># git commit -m "子模块问题解决"</span></div></pre></td></tr></table></figure><h2 id="Git回滚远程版本"><a href="#Git回滚远程版本" class="headerlink" title="Git回滚远程版本"></a>Git回滚远程版本</h2><h2 id="提取仓库根目录下的某目录文件，配置为另外一个Git仓库"><a href="#提取仓库根目录下的某目录文件，配置为另外一个Git仓库" class="headerlink" title="提取仓库根目录下的某目录文件，配置为另外一个Git仓库"></a>提取仓库根目录下的某目录文件，配置为另外一个Git仓库</h2><p>线上服务器中，<code>dev</code> 仓库下有个 <code>test</code> 目录，这是一个项目目录，现想将该目录内容提取出来，另外配置一个git仓库。</p><p>在Git服务器上创建一个裸仓库，裸仓库没有工作区，因服务器上的Git仓库纯粹为了共享，不让用户直接登录Git服务器改工作区，并且Git服务器上的仓库通常都以 <code>.git</code> 结尾。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># cd /git</div><div class="line"># git init --bare test.git</div><div class="line"># chown -R git.git test.git</div></pre></td></tr></table></figure><p>克隆空仓库 <code>test</code> 到线上服务器，拷贝 <code>test</code> 目录下的所有文件到空仓库 <code>test</code> 目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># cd /home/www</div><div class="line"># git clone git@xx.xx.xx.xx:/git/test.git</div><div class="line"># cp -a /home/www/dev/test/* /home/www/test/</div></pre></td></tr></table></figure><p>添加文件并提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># git add .</div><div class="line"># git commit -m &quot;初始化提交&quot;</div></pre></td></tr></table></figure><p>配置好 <code>.gitignore</code>，推送到Git服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># git push</div></pre></td></tr></table></figure><p>在版本库中删除 <code>dev</code> 仓库下的 <code>test</code> 目录，本地工作区保留目录文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># cd /home/www/dev</div><div class="line"># git rm -r --cached test</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录Git使用过程中出现的问题&lt;br&gt;
    
    </summary>
    
      <category term="版本控制" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>GitLab汉化指南</title>
    <link href="http://yoursite.com/2017/GitLab-Chinesization-guide.html"/>
    <id>http://yoursite.com/2017/GitLab-Chinesization-guide.html</id>
    <published>2017-06-24T14:22:42.000Z</published>
    <updated>2017-06-24T14:56:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>为了方便，降低新手上手的难度，对GitLab进行汉化。</p><p>以下介绍GitLab汉化的两个方法</p><a id="more"></a><h2 id="1、直接安装中文版"><a href="#1、直接安装中文版" class="headerlink" title="1、直接安装中文版"></a>1、直接安装中文版</h2><p>GitLab中文社区有集成了中文版的rpm安装包，可以直接去下载安装。</p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/" target="_blank" rel="external">GitLab中文社区的安装源</a>，目前汉化的最新版本是 gitlab-ce-9.3.0</p><p>CentOS 6.x 中，安装GitLab中文版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># curl -LJO https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el6/gitlab-ce-9.3.0-ce.0.el6.x86_64.rpm</div><div class="line"># rpm -i gitlab-ce-9.3.0-ce.0.el6.x86_64.rpm</div></pre></td></tr></table></figure><p>修改配置/etc/gitlab/gitlab.rb，绑定域名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">external_url &apos;http://gitlab.xxx.com&apos;</div></pre></td></tr></table></figure><blockquote><p>修改这个配置，会影响GitLab里面显示的仓库链接。</p></blockquote><p>使配置生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 重新生成配置，启动服务</div><div class="line">gitlab-ctl reconfigure   </div><div class="line"></div><div class="line"># 清空缓存</div><div class="line">gitlab-rake cache:clear RAILS_ENV=production</div><div class="line">  </div><div class="line"># 重启所有 gitlab 组件</div><div class="line">gitlab-ctl restart</div></pre></td></tr></table></figure><h2 id="2、汉化"><a href="#2、汉化" class="headerlink" title="2、汉化"></a>2、汉化</h2><h3 id="确定GitLab安装版本"><a href="#确定GitLab安装版本" class="headerlink" title="确定GitLab安装版本"></a>确定GitLab安装版本</h3><p>通过官方提供的GitLab-CE Omnibus安装包安装了GitLab CE 9.2.6</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># cat /opt/gitlab/embedded/service/gitlab-rails/VERSION</div></pre></td></tr></table></figure><h3 id="克隆GitLab汉化源代码仓库"><a href="#克隆GitLab汉化源代码仓库" class="headerlink" title="克隆GitLab汉化源代码仓库"></a>克隆GitLab汉化源代码仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 克隆 GitLab.com 仓库</div><div class="line">git clone https://gitlab.com/xhang/gitlab.git</div><div class="line"></div><div class="line"># 如果是8.8之前的版本可以使用这个</div><div class="line">git clone https://gitlab.com/larryli/gitlab.git</div></pre></td></tr></table></figure><ul><li><a href="https://gitlab.com/larryli/gitlab" target="_blank" rel="external"><strong>larryli项目</strong></a> ：只更新到8.8.5版本。</li><li><a href="https://gitlab.com/xhang/gitlab" target="_blank" rel="external"><strong>xhang项目</strong></a> ：延续Larry Li项目的8-8-zh中文版本进行更新，目前最新版本是9.3.0 。</li></ul><p>根据安装的版本到 <strong>LarryLi项目</strong> 或 <strong>xhang项目</strong> 查看汉化是否支持，注意只要前两位版本号一致就好，如：安装GitLab版本是8.8.6，可以使用 v8.8.0 汉化版本。</p><h3 id="打汉化补丁"><a href="#打汉化补丁" class="headerlink" title="打汉化补丁"></a>打汉化补丁</h3><p>以 9.2.6 版本为例（使用xhang的git仓库）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># 进入克隆仓库得到的gitlab目录</div><div class="line">cd gitlab </div><div class="line"></div><div class="line"># 查看tag版本，选择合适的汉化版本</div><div class="line">git tag</div><div class="line"></div><div class="line"># 对比不同，这里比较的是tag，v9.2.6为英文原版，v9.2.6-zh为汉化版本。diff结果是汉化补丁。</div><div class="line">git diff v9.2.6..v9.2.6-zh &gt; /tmp/9.2.6.diff</div><div class="line"></div><div class="line"># 停止gitlab</div><div class="line">gitlab-ctl stop</div><div class="line"></div><div class="line"># 应用汉化补丁</div><div class="line">cd /opt/gitlab/embedded/service/gitlab-rails</div><div class="line">git apply /tmp/9.2.6.diff</div><div class="line"></div><div class="line"># 启动gitlab</div><div class="line">gitlab-ctl start</div></pre></td></tr></table></figure><p>如果汉化中出现问题，请重新安装GitLab，<strong>注意要先备份数据</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了方便，降低新手上手的难度，对GitLab进行汉化。&lt;/p&gt;
&lt;p&gt;以下介绍GitLab汉化的两个方法&lt;/p&gt;
    
    </summary>
    
      <category term="版本控制" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>GitLab搭建及配置</title>
    <link href="http://yoursite.com/2017/GitLab-install-config.html"/>
    <id>http://yoursite.com/2017/GitLab-install-config.html</id>
    <published>2017-06-23T10:31:06.000Z</published>
    <updated>2017-09-05T02:37:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于公司业务，需要上Git版本控制。</p><blockquote><ul><li>目前市面上比较有名的Git服务提供商，国外有<a href="https://github.com/" target="_blank" rel="external">GitHub</a>、<a href="https://bitbucket.org/" target="_blank" rel="external">BitBucket</a>、<a href="https://about.gitlab.com/" target="_blank" rel="external">GitLab</a>，国内有<a href="https://coding.net/" target="_blank" rel="external">Coding</a>。</li><li>现有的服务商，对于免费的套餐都有一定的限制。比如：GitHub只允许建立免费的开源repository，建立私有的仓库需要收费。BitBucket允许建立无限制的私有项目，不过对于项目中参与的开发人员是有人数限制的，当团队中开发者规模达到一定数量后，需要付费购买相应的套餐。</li></ul></blockquote><p>GitLab社区版是免费的，不但能建立免费的私有仓库而且没有数量上限，参与人员也没有数量限制，还能设置成员的权限，甚至细致到具体某条分支的权限，以及强大的工作流等等。</p><p>GitLab很适合中小型非开源项目公司。</p><p><img src="http://orku2pa7o.bkt.clouddn.com/17-6-24/12188324.jpg" alt=""></p><a id="more"></a><h1 id="一、GitLab-简介"><a href="#一、GitLab-简介" class="headerlink" title="一、GitLab 简介"></a>一、GitLab 简介</h1><p>GitLab 是一个利用Ruby on Rails 开发的开源版本控制系统，实现一个自托管的Git项目仓库，可通过Web界面进行访问公开的或者私人项目。</p><p>它拥有与GitHub类似的功能，能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。团队成员可以利用内置的简单聊天程序（Wall）进行交流。它还提供一个代码片段收集功能可以轻松实现代码复用，便于日后有需要的时候进行查找。</p><p>开源中国代码托管平台 <a href="http://git.oschina.net/" target="_blank" rel="external">码云</a> 就是基于GitLab项目搭建。</p><p>GitLab 分为 GitLab Community Edition(CE) 社区版 和 GitLab Enterprise Edition(EE) 专业版。社区版免费，专业版收费，两个版本在功能上的差异对比，可以参考<a href="https://about.gitlab.com/features/#compare" target="_blank" rel="external">官方对比说明</a></p><h1 id="二、GitLab-安装和配置"><a href="#二、GitLab-安装和配置" class="headerlink" title="二、GitLab 安装和配置"></a>二、GitLab 安装和配置</h1><p>安装社区版，GitLab CE 版本：9.2.6</p><h2 id="1、GitLab安装"><a href="#1、GitLab安装" class="headerlink" title="1、GitLab安装"></a>1、GitLab安装</h2><p>通过GitLab官方提供的Omnibus安装包来安装，相对方便。Omnibus安装包套件整合了大部分的套件（Nginx、ruby on rails、git、redis、postgresql等），再不用额外安装这些软件，减轻了绝大部分安装量。</p><p><a href="https://www.gitlab.com.cn/downloads/#centos6" target="_blank" rel="external">GitLab官方安装文档</a> ：CentOS6.x系统</p><h3 id="安装依赖包，并配置postfix服务为GitLab邮件服务"><a href="#安装依赖包，并配置postfix服务为GitLab邮件服务" class="headerlink" title="安装依赖包，并配置postfix服务为GitLab邮件服务"></a>安装依赖包，并配置postfix服务为GitLab邮件服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># yum install curl openssh-server openssh-clients postfix cronie</span></div><div class="line"><span class="comment"># service postfix start</span></div><div class="line"><span class="comment"># chkconfig postfix on</span></div></pre></td></tr></table></figure><h3 id="打开HTTP和SSH端口"><a href="#打开HTTP和SSH端口" class="headerlink" title="打开HTTP和SSH端口"></a>打开HTTP和SSH端口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># iptables -I INPUT -m tcp -p tcp --dport 22 -j ACCEPT</span></div><div class="line"><span class="comment"># iptables -I INPUT -m tcp -p tcp --dport 80 -j ACCEPT</span></div></pre></td></tr></table></figure><h3 id="两种安装源"><a href="#两种安装源" class="headerlink" title="两种安装源"></a>两种安装源</h3><ul><li><strong>从官方镜像源安装</strong></li></ul><p>添加GitLab仓库并安装到服务器上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># curl -sS http://packages.gitlab.cc/install/gitlab-ce/script.rpm.sh | sudo bash</span></div><div class="line"><span class="comment"># yum install gitlab-ce     # 自动安装最新版本</span></div><div class="line"></div><div class="line"><span class="comment"># yum install gitlab-ce-9.2.1-ce.0.el6     # 安装指定版本</span></div></pre></td></tr></table></figure><ul><li><strong>从第三方镜像源安装</strong></li></ul><p>官方镜像源在国外，国内安装会很慢，甚至有时因网络问题会无法安装。</p><blockquote><p>国内推荐使用<a href="https://mirror.tuna.tsinghua.edu.cn/help/gitlab-ce/" target="_blank" rel="external"><strong>清华大学开源软件镜像源</strong></a>。</p></blockquote><p>新建 /etc/yum.repos.d/gitlab-ce.repo，内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[gitlab-ce]</div><div class="line">name=Gitlab CE Repository</div><div class="line">baseurl=https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el$releasever/</div><div class="line">gpgcheck=0</div><div class="line">enabled=1</div></pre></td></tr></table></figure><p>再执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># yum makecache   # 更新本地YUM缓存</span></div><div class="line"><span class="comment"># yum install gitlab-ce    # 自动安装最新版本</span></div></pre></td></tr></table></figure><h3 id="修改配置文件-etc-gitlab-gitlab-rb，绑定域名"><a href="#修改配置文件-etc-gitlab-gitlab-rb，绑定域名" class="headerlink" title="修改配置文件/etc/gitlab/gitlab.rb，绑定域名"></a>修改配置文件/etc/gitlab/gitlab.rb，绑定域名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">external_url &apos;http://gitlab.xxx.com&apos;</div></pre></td></tr></table></figure><h3 id="启动GitLab，使得配置生效"><a href="#启动GitLab，使得配置生效" class="headerlink" title="启动GitLab，使得配置生效"></a>启动GitLab，使得配置生效</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># gitlab-ctl reconfigure</span></div></pre></td></tr></table></figure><h3 id="在Dnspod中添加解析记录"><a href="#在Dnspod中添加解析记录" class="headerlink" title="在Dnspod中添加解析记录"></a>在Dnspod中添加解析记录</h3><h3 id="使用浏览器访问GitLab"><a href="#使用浏览器访问GitLab" class="headerlink" title="使用浏览器访问GitLab"></a>使用浏览器访问GitLab</h3><blockquote><p>首次访问GitLab,系统会让你重新设置管理员的密码,设置成功后会返回登录界面.<br>默认的管理员账号是root,如果你想更改默认管理员账号,请输入上面设置的新密码登录系统后修改帐号名.</p></blockquote><h3 id="GitLab安装细节"><a href="#GitLab安装细节" class="headerlink" title="GitLab安装细节"></a>GitLab安装细节</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">主配置文件: /etc/gitlab/gitlab.rb</div><div class="line">GitLab 文档根目录: /opt/gitlab</div><div class="line">默认存储库位置: /var/opt/gitlab/git-data/repositories</div><div class="line">GitLab Nginx 配置文件路径:  /var/opt/gitlab/nginx/conf/gitlab-http.conf</div><div class="line">Postgresql 数据目录: /var/opt/gitlab/postgresql/data</div></pre></td></tr></table></figure><h3 id="GitLab由以下服务构成"><a href="#GitLab由以下服务构成" class="headerlink" title="GitLab由以下服务构成"></a>GitLab由以下服务构成</h3><ul><li>nginx: 静态web服务器</li><li>gitlab-shell: 用于处理Git命令和修改authorized keys列表</li><li>gitlab-workhorse: 轻量级的反向代理服务器</li><li>logrotate：日志文件管理工具</li><li>postgresql：数据库</li><li>redis：缓存数据库</li><li>sidekiq：用于在后台执行队列任务（异步执行）</li><li>unicorn：An HTTP server for Rack applications，GitLab Rails应用是托管在这个服务器上面的。</li></ul><h2 id="2、配置SMTP服务"><a href="#2、配置SMTP服务" class="headerlink" title="2、配置SMTP服务"></a>2、配置SMTP服务</h2><p>如果你不想用服务器自带的postfix服务来发邮件，可以改用SMTP服务。</p><p>修改GitLab邮件服务配置(gitlab.rb文件)，使用腾讯企业邮箱的SMTP服务器，填写账号和密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">gitlab_rails[&apos;smtp_address&apos;] = &quot;smtp.exmail.qq.com&quot;</div><div class="line">gitlab_rails[&apos;smtp_port&apos;] = 25</div><div class="line">gitlab_rails[&apos;smtp_user_name&apos;] = &quot;xxx&quot;</div><div class="line">gitlab_rails[&apos;smtp_password&apos;] = &quot;xxx&quot;</div><div class="line">gitlab_rails[&apos;smtp_domain&apos;] = &quot;smtp.qq.com&quot;</div><div class="line">gitlab_rails[&apos;smtp_authentication&apos;] = &apos;plain&apos;</div><div class="line">gitlab_rails[&apos;smtp_enable_starttls_auto&apos;] = true</div></pre></td></tr></table></figure><p>使配置生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># gitlab-ctl reconfigure</span></div><div class="line"><span class="comment"># gitlab-rake cache:clear RAILS_ENV=production      # 清除缓存</span></div></pre></td></tr></table></figure><h2 id="3、GitLab配置HTTPS"><a href="#3、GitLab配置HTTPS" class="headerlink" title="3、GitLab配置HTTPS"></a>3、GitLab配置HTTPS</h2><p>GitLab默认是使用HTTP的，可以手动配置为HTTPS</p><h3 id="上传SSL证书"><a href="#上传SSL证书" class="headerlink" title="上传SSL证书"></a>上传SSL证书</h3><p>创建ssl目录，用于存放SSL证书</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># mkdir -p /etc/gitlab/ssl</span></div><div class="line"><span class="comment"># chmod 0700 /etc/gitlab/ssl</span></div></pre></td></tr></table></figure><p>上传证书并修改证书权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># chmod 600 /etc/gitlab/ssl/*</span></div></pre></td></tr></table></figure><h3 id="修改GitLab的配置文件"><a href="#修改GitLab的配置文件" class="headerlink" title="修改GitLab的配置文件"></a>修改GitLab的配置文件</h3><p>修改配置文件/etc/gitlab/gitlab.rb</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">external_url &quot;https://gitlab.xxx.com&quot;</div><div class="line">nginx[&apos;redirect_http_to_https&apos;] = true</div><div class="line">nginx[&apos;ssl_certificate&apos;] = &quot;/etc/gitlab/ssl/gitlab.xxx.com.crt&quot;</div><div class="line">nginx[&apos;ssl_certificate_key&apos;] = &quot;/etc/gitlab/ssl/gitlab.xxx.com.key&quot;</div></pre></td></tr></table></figure><p>重建配置，使其生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># gitlab-ctl reconfigure</div></pre></td></tr></table></figure><p>以上操作后，GitLab自带的Nginx服务的配置文件 /var/opt/gitlab/nginx/conf/gitlab-http.conf 会被重新修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">  listen *:80;</div><div class="line">  server_name gitlab.xxx.com;</div><div class="line">  server_tokens off; ## Don&apos;t show the nginx version number, a security best practice</div><div class="line">  return 301 https://gitlab.xxx.com:443$request_uri;</div><div class="line">  access_log  /var/log/gitlab/nginx/gitlab_access.log gitlab_access;</div><div class="line">  error_log   /var/log/gitlab/nginx/gitlab_error.log;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>不用额外再配置，HTTP 会自动跳转到 HTTPS 。</p><h3 id="开放443端口"><a href="#开放443端口" class="headerlink" title="开放443端口"></a>开放443端口</h3><p>在防火墙上开放443端口，用于HTTPS</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># iptables -I INPUT -m tcp -p tcp --dport 443 -j ACCEPT</span></div></pre></td></tr></table></figure><h2 id="4、修改root用户密码"><a href="#4、修改root用户密码" class="headerlink" title="4、修改root用户密码"></a>4、修改root用户密码</h2><p>对于普通用户而言，可通过系统重置密码，接收邮件即可。可是GitLab管理员账号，缺省邮箱 <code>admin@example.com</code> 是个不存在的邮箱地址，无法通过邮箱修改密码。<br><a href="http://docs.gitlab.com/ce/security/reset_root_password.html" target="_blank" rel="external"><strong>官方修改密码文档</strong></a>，根据文档，修改root密码的方法如下：</p><h3 id="打开与Rails程序交互的控制台"><a href="#打开与Rails程序交互的控制台" class="headerlink" title="打开与Rails程序交互的控制台"></a>打开与Rails程序交互的控制台</h3><p>在root权限下，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># gitlab-rails console production</div></pre></td></tr></table></figure><p>等待一会，直到控制台加载成功。</p><h3 id="获取用户信息并修改root用户密码"><a href="#获取用户信息并修改root用户密码" class="headerlink" title="获取用户信息并修改root用户密码"></a>获取用户信息并修改root用户密码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># gitlab-rails console production</div><div class="line">Loading production environment (Rails 4.2.8)</div><div class="line">irb(main):001:0&gt; user = User.where(id: 1).first</div><div class="line">=&gt; #&lt;User id: 1, email: &quot;admin@example.com&quot;......</div><div class="line">irb(main):009:0&gt; user.password = &apos;12345678&apos;</div><div class="line">=&gt; &quot;12345678&quot;</div><div class="line">irb(main):010:0&gt; user.password_confirmation = &apos;12345678&apos;</div><div class="line">=&gt; &quot;12345678&quot;</div><div class="line">irb(main):011:0&gt; user.save!</div><div class="line">Enqueued ActionMailer::DeliveryJob (Job ID: 510bb5be-a156-4522-9983-44d8a895e92a) to Sidekiq(mailers) with arguments: &quot;DeviseMailer&quot;, &quot;password_change&quot;, &quot;deliver_now&quot;, gid://gitlab/User/1</div><div class="line">=&gt; true</div><div class="line">irb(main):011:0&gt; exit</div></pre></td></tr></table></figure><h1 id="三、GitLab-常用命令"><a href="#三、GitLab-常用命令" class="headerlink" title="三、GitLab 常用命令"></a>三、GitLab 常用命令</h1><h2 id="运维管理排查"><a href="#运维管理排查" class="headerlink" title="运维管理排查"></a>运维管理排查</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查看版本</span></div><div class="line">cat /opt/gitlab/embedded/service/gitlab-rails/VERSION</div><div class="line"></div><div class="line"><span class="comment"># 检查gitlab</span></div><div class="line">gitlab-rake gitlab:check SANITIZE=<span class="literal">true</span> --trace</div><div class="line"></div><div class="line"><span class="comment"># 实时查看日志</span></div><div class="line">gitlab-ctl tail</div><div class="line"></div><div class="line"><span class="comment"># 数据库关系升级</span></div><div class="line">gitlab-rake db:migrate</div><div class="line"></div><div class="line"><span class="comment"># 清理redis缓存</span></div><div class="line">gitlab-rake cache:clear</div><div class="line"></div><div class="line"><span class="comment"># 升级GitLab-ce 版本</span></div><div class="line">yum update gitlab-ce</div><div class="line"></div><div class="line"><span class="comment"># 升级PostgreSQL最新版本</span></div><div class="line">gitlab-ctl pg-upgrade</div></pre></td></tr></table></figure><h2 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 启动所有 gitlab 组件：</span></div><div class="line">gitlab-ctl start</div><div class="line"></div><div class="line"><span class="comment"># 停止所有 gitlab 组件：</span></div><div class="line">gitlab-ctl stop</div><div class="line"></div><div class="line"><span class="comment"># 停止所有 gitlab postgresql 组件：</span></div><div class="line">gitlab-ctl stop postgresql</div><div class="line"></div><div class="line"><span class="comment"># 停止相关数据连接服务</span></div><div class="line">gitlab-ctl stop unicorn</div><div class="line">gitlab-ctl stop sidekiq</div><div class="line"></div><div class="line"><span class="comment"># 重启所有 gitlab 组件：</span></div><div class="line">gitlab-ctl restart</div><div class="line"></div><div class="line"><span class="comment"># 重启所有 gitlab gitlab-workhorse 组件：</span></div><div class="line">gitlab-ctl restart  gitlab-workhorse</div><div class="line"></div><div class="line"><span class="comment"># 查看服务状态</span></div><div class="line">gitlab-ctl status</div><div class="line"></div><div class="line"><span class="comment"># 生成配置并启动服务</span></div><div class="line">gitlab-ctl reconfigure</div></pre></td></tr></table></figure><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 实时查看所有日志</span></div><div class="line">gitlab-ctl tail</div><div class="line"></div><div class="line"><span class="comment"># 实时检查redis的日志</span></div><div class="line">gitlab-ctl tail redis</div><div class="line"> </div><div class="line"><span class="comment"># 实时检查postgresql的日志</span></div><div class="line">gitlab-ctl tail postgresql</div><div class="line"> </div><div class="line"><span class="comment"># 检查gitlab-workhorse的日志</span></div><div class="line">gitlab-ctl tail gitlab-workhorse</div><div class="line"> </div><div class="line"><span class="comment"># 检查logrotate的日志</span></div><div class="line">gitlab-ctl tail logrotate</div><div class="line"> </div><div class="line"><span class="comment"># 检查nginx的日志</span></div><div class="line">gitlab-ctl tail nginx</div><div class="line"> </div><div class="line"><span class="comment"># 检查sidekiq的日志</span></div><div class="line">gitlab-ctl tail sidekiq</div><div class="line"> </div><div class="line"><span class="comment"># 检查unicorn的日志</span></div><div class="line">gitlab-ctl tail unicorn</div></pre></td></tr></table></figure><h1 id="四、GitLab备份和恢复"><a href="#四、GitLab备份和恢复" class="headerlink" title="四、GitLab备份和恢复"></a>四、GitLab备份和恢复</h1><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>GitLab作为公司项目代码的版本管理系统，数据非常重要，必须做好备份。</p><h3 id="修改备份目录"><a href="#修改备份目录" class="headerlink" title="修改备份目录"></a>修改备份目录</h3><p>GitLab备份的默认目录是 /var/opt/gitlab/backups ，如果想改备份目录，可修改/etc/gitlab/gitlab.rb：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gitlab_rails[&apos;backup_path&apos;] = &apos;/data/backups&apos;</div></pre></td></tr></table></figure><p>修改配置后，记得：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gitlab-ctl reconfigure</div></pre></td></tr></table></figure><h3 id="备份命令"><a href="#备份命令" class="headerlink" title="备份命令"></a>备份命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gitlab-rake gitlab:backup:create</div></pre></td></tr></table></figure><p>该命令会在备份目录（默认：/var/opt/gitlab/backups/）下创建一个tar压缩包xxxxxxxx_gitlab_backup.tar，其中开头的xxxxxx是备份创建的时间戳，这个压缩包包括GitLab整个的完整部分。</p><h3 id="自动备份"><a href="#自动备份" class="headerlink" title="自动备份"></a>自动备份</h3><p>通过任务计划crontab 实现自动备份</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 每天2点备份gitlab数据</div><div class="line">0 2 * * * /usr/bin/gitlab-rake gitlab:backup:create</div></pre></td></tr></table></figure><h3 id="备份保留7天"><a href="#备份保留7天" class="headerlink" title="备份保留7天"></a>备份保留7天</h3><p>可设置只保留最近7天的备份，编辑配置文件 /etc/gitlab/gitlab.rb </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 数值单位：秒</div><div class="line">gitlab_rails[&apos;backup_keep_time&apos;] = 604800</div></pre></td></tr></table></figure><p>重新加载gitlab配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gitlab-ctl reconfigure</div></pre></td></tr></table></figure><h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><p>备份文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/var/opt/gitlab/backups/1499244722_2017_07_05_9.2.6_gitlab_backup.tar</div></pre></td></tr></table></figure><p>停止 unicorn 和 sidekiq ，保证数据库没有新的连接，不会有写数据情况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 停止相关数据连接服务</span></div><div class="line">gitlab-ctl stop unicorn</div><div class="line">gitlab-ctl stop sidekiq</div><div class="line"></div><div class="line"><span class="comment"># 指定恢复文件，会自动去备份目录找。确保备份目录中有这个文件。</span></div><div class="line"><span class="comment"># 指定文件名的格式类似：1499242399_2017_07_05_9.2.6，程序会自动在文件名后补上：“_gitlab_backup.tar”</span></div><div class="line"><span class="comment"># 一定按这样的格式指定，否则会出现 The backup file does not exist! 的错误</span></div><div class="line">gitlab-rake gitlab:backup:restore BACKUP=1499242399_2017_07_05_9.2.6</div><div class="line"></div><div class="line"><span class="comment"># 启动Gitlab</span></div><div class="line">gitlab-ctl start</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于公司业务，需要上Git版本控制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;目前市面上比较有名的Git服务提供商，国外有&lt;a href=&quot;https://github.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;、&lt;a href=&quot;https://bitbucket.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BitBucket&lt;/a&gt;、&lt;a href=&quot;https://about.gitlab.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitLab&lt;/a&gt;，国内有&lt;a href=&quot;https://coding.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Coding&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;现有的服务商，对于免费的套餐都有一定的限制。比如：GitHub只允许建立免费的开源repository，建立私有的仓库需要收费。BitBucket允许建立无限制的私有项目，不过对于项目中参与的开发人员是有人数限制的，当团队中开发者规模达到一定数量后，需要付费购买相应的套餐。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;GitLab社区版是免费的，不但能建立免费的私有仓库而且没有数量上限，参与人员也没有数量限制，还能设置成员的权限，甚至细致到具体某条分支的权限，以及强大的工作流等等。&lt;/p&gt;
&lt;p&gt;GitLab很适合中小型非开源项目公司。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://orku2pa7o.bkt.clouddn.com/17-6-24/12188324.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="版本控制" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git 安装</title>
    <link href="http://yoursite.com/2017/Git-install.html"/>
    <id>http://yoursite.com/2017/Git-install.html</id>
    <published>2017-06-22T02:50:53.000Z</published>
    <updated>2017-06-24T16:21:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git-简介"><a href="#Git-简介" class="headerlink" title="Git 简介"></a>Git 简介</h1><p><img src="http://orku2pa7o.bkt.clouddn.com/17-6-24/36802017.jpg" alt=""></p><p>Git是目前世界上最先进的分布式版本控制系统，用C语言开发的，以追求最高的性能。<br>Linux之父 Linus Torvalds 用10天编出Git第一个版本。</p><a id="more"></a><h1 id="在CentOS-6-x-7-x-上安装最新版的Git"><a href="#在CentOS-6-x-7-x-上安装最新版的Git" class="headerlink" title="在CentOS 6.x/7.x 上安装最新版的Git"></a>在CentOS 6.x/7.x 上安装最新版的Git</h1><blockquote><p>CentOS 6.5 上，官方yum源的git版本是 1.7.1 。<br>CentOS 7 上，官方yum源的git版本是 1.8.3 。</p></blockquote><p>下面介绍安装最新版Git的两种方法</p><h2 id="1、通过第三方RPM包来安装"><a href="#1、通过第三方RPM包来安装" class="headerlink" title="1、通过第三方RPM包来安装"></a>1、通过第三方RPM包来安装</h2><p>可以使用<a href="http://opensource.wandisco.com/centos/" target="_blank" rel="external">WANDisco的yum源</a>安装Git，里边有WANDisco集成的rpm安装包。截止2017年6月22日，WANDisco的最新版本是2.11.1</p><h3 id="安装WANDisco-repo包"><a href="#安装WANDisco-repo包" class="headerlink" title="安装WANDisco repo包"></a>安装WANDisco repo包</h3><p>centos 6.x</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># yum install http://opensource.wandisco.com/centos/6/git/x86_64/wandisco-git-release-6-1.noarch.rpm</div></pre></td></tr></table></figure><p>centos 7.x </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># yum install http://opensource.wandisco.com/centos/7/git/x86_64/wandisco-git-release-7-1.noarch.rpm</div></pre></td></tr></table></figure><h3 id="安装最新版Git"><a href="#安装最新版Git" class="headerlink" title="安装最新版Git"></a>安装最新版Git</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># yum install git -y</div></pre></td></tr></table></figure><h3 id="验证已安装的Git版本"><a href="#验证已安装的Git版本" class="headerlink" title="验证已安装的Git版本"></a>验证已安装的Git版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># git version</div></pre></td></tr></table></figure><h2 id="2、编译安装"><a href="#2、编译安装" class="headerlink" title="2、编译安装"></a>2、编译安装</h2><h3 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h3><p>Git 的工作需要调用 curl，zlib，openssl，expat，libiconv 等库的代码，所以需要先安装这些依赖工具。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel -y</div><div class="line"># yum install  gcc perl-ExtUtils-MakeMaker -y</div></pre></td></tr></table></figure><h3 id="下载解压并编译安装Git"><a href="#下载解压并编译安装Git" class="headerlink" title="下载解压并编译安装Git"></a>下载解压并编译安装Git</h3><p><a href="https://www.kernel.org/pub/software/scm/git/" target="_blank" rel="external">Git镜像源</a>，截止2017年6月22日，镜像源中提供的git源代码最新版是 2.13.1 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># cd /usr/local/src/</div><div class="line"># wget https://www.kernel.org/pub/software/scm/git/git-2.13.1.tar.gz</div><div class="line"># tar zxvf git-2.13.1.tar.gz</div></pre></td></tr></table></figure><p>下载并解压Git源代码后，继续编译安装Git</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># cd git-2.13.1</div><div class="line"># make configure</div><div class="line"># ./configure --prefix=/usr/local/git</div><div class="line"># make all doc info</div><div class="line"># make install install-doc install-html install-info</div></pre></td></tr></table></figure><p>配置环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># echo &quot;export PATH=$PATH:/usr/local/git/bin&quot; &gt;&gt; /etc/bashrc</div><div class="line"># source /etc/bashrc</div></pre></td></tr></table></figure><h3 id="检查Git版本"><a href="#检查Git版本" class="headerlink" title="检查Git版本"></a>检查Git版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># git version</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Git-简介&quot;&gt;&lt;a href=&quot;#Git-简介&quot; class=&quot;headerlink&quot; title=&quot;Git 简介&quot;&gt;&lt;/a&gt;Git 简介&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://orku2pa7o.bkt.clouddn.com/17-6-24/36802017.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Git是目前世界上最先进的分布式版本控制系统，用C语言开发的，以追求最高的性能。&lt;br&gt;Linux之父 Linus Torvalds 用10天编出Git第一个版本。&lt;/p&gt;
    
    </summary>
    
      <category term="版本控制" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 查询缓存</title>
    <link href="http://yoursite.com/2017/MySQL-query-cache.html"/>
    <id>http://yoursite.com/2017/MySQL-query-cache.html</id>
    <published>2017-06-20T06:55:56.000Z</published>
    <updated>2017-06-20T07:56:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>开启查询缓存后，查询语句的解析过程：</p><blockquote><p>在解析一个查询语句之前，如果查询缓存是打开的，那么MySQL会优先检查这个查询是否命中查询缓存中的数据。如果当前的查询恰好命中了查询缓存，那么在返回查询结果之前MySQL会检查一次用户权限。若权限没有问题，MySQL会跳过所有其他阶段（解析、优化、执行等），直接从缓存中拿到结果并返回给客户端。这种情况下，查询不会被解析，不用生成执行计划，不会被执行。</p></blockquote><a id="more"></a><h2 id="开启查询缓存"><a href="#开启查询缓存" class="headerlink" title="开启查询缓存"></a>开启查询缓存</h2><h3 id="设置使用查询缓存的方式"><a href="#设置使用查询缓存的方式" class="headerlink" title="设置使用查询缓存的方式"></a>设置使用查询缓存的方式</h3><p>使用 <strong>query_cache_type</strong> 变量来开启查询缓存，开启方式有三种：</p><ul><li><strong>ON</strong> : 正常缓存。表示在使用 SELECT 语句查询时，若没指定 SQL_NO_CACHE 或其他非确定性函数，则一般都会将查询结果缓存下来。</li><li><p><strong>DEMAND</strong> ：指定SQL_CACHE才缓存。表示在使用 SELECT 语句查询时，必须在该 SELECT 语句中指定 SQL_CACHE 才会将该SELECT语句的查询结果缓存下来。</p><blockquote><p>例如：select SQL_CACHE name from user where id = 15;    #只有明确指定  SQL_CACHE 的SELECT语句，才会将查询结果缓存。</p></blockquote></li><li><strong>OFF</strong>： 关闭查询缓存。</li></ul><h4 id="立刻生效，重启服务失效"><a href="#立刻生效，重启服务失效" class="headerlink" title="立刻生效，重启服务失效"></a>立刻生效，重启服务失效</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; set global query_cache_type=1;</div></pre></td></tr></table></figure><p><font color="red"><strong>注意:</strong></font><br>　　当my.cnf 中，<strong>query_cache_type = OFF</strong> ，启动mysql服务后，在mysql命令行中使用上面语句开启查询缓存，会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ERROR 1651 (HY000): Query cache is disabled; restart the server with query_cache_type=1 to enable it</div></pre></td></tr></table></figure><p>　  遇到这种情况，是无法在mysql命令行中开启查询缓存的，必须修改my.cnf的query_cache_type = ON，然后重启mysql服务。 </p><h4 id="永久生效"><a href="#永久生效" class="headerlink" title="永久生效"></a>永久生效</h4><p>修改 my.cnf : </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">query_cache_type = ON</div></pre></td></tr></table></figure><p>重启 mysql 服务</p><h3 id="设置查询缓存的大小"><a href="#设置查询缓存的大小" class="headerlink" title="设置查询缓存的大小"></a>设置查询缓存的大小</h3><blockquote><p>query_cache_size ：查询缓存的总体可用空间。</p></blockquote><p><font color="red"><strong>注意:</strong></font> 如果 query_cache_size=0 ，那即便你设置了 query_cache_type = ON，查询缓存仍然是无法工作的。</p><h4 id="立刻生效，重启服务失效-1"><a href="#立刻生效，重启服务失效-1" class="headerlink" title="立刻生效，重启服务失效"></a>立刻生效，重启服务失效</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; set global query_cache_size=536870912;   #单位为字节，必须为1024的倍数。</div></pre></td></tr></table></figure><h4 id="永久生效-1"><a href="#永久生效-1" class="headerlink" title="永久生效"></a>永久生效</h4><p>修改 my.cnf :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">query_cache_size = 500M   #支持单位：K,M,G</div></pre></td></tr></table></figure><p>重启 mysql 服务</p><h3 id="查询缓存相关参数"><a href="#查询缓存相关参数" class="headerlink" title="查询缓存相关参数"></a>查询缓存相关参数</h3><p>与缓存功能相关的服务器变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SHOW GLOBAL VARIABLES LIKE &apos;query_cache%&apos;;</div><div class="line">+------------------------------+----------+</div><div class="line">| Variable_name                | Value    |</div><div class="line">+------------------------------+----------+</div><div class="line">| query_cache_limit            | 1048576  |</div><div class="line">| query_cache_min_res_unit     | 4096     |</div><div class="line">| query_cache_size             | 16777216 |</div><div class="line">| query_cache_strip_comments   | OFF      |</div><div class="line">| query_cache_type             | ON       |</div><div class="line">| query_cache_wlock_invalidate | OFF      |</div><div class="line">+------------------------------+----------+</div></pre></td></tr></table></figure><p>变量说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">query_cache_limit :  MySQL能够缓存的最大查询结果；如果某查询的结果大小大于此值，则不会被缓存；</div><div class="line">query_cache_min_res_unit : 查询缓存中分配内存的最小单位；(注意：此值通常是需要调整的，此值被调整为接近所有查询结果的平均值是最好的)</div><div class="line">                           计算单个查询的平均缓存大小：（query_cache_size-Qcache_free_memory）/Qcache_queries_in_cache</div><div class="line">query_cache_size : 查询缓存的总体可用空间，单位为字节；其必须为1024的倍数；</div><div class="line">query_cache_type: 查询缓存类型；是否开启缓存功能，开启方式有三种&#123;ON|OFF|DEMAND&#125;；</div><div class="line">query_cache_wlock_invalidate : 当其它会话锁定此次查询用到的资源时，是否不能再从缓存中返回数据；（OFF表示可以从缓存中返回数据）</div></pre></td></tr></table></figure><h2 id="关闭查询缓存"><a href="#关闭查询缓存" class="headerlink" title="关闭查询缓存"></a>关闭查询缓存</h2><p>关闭查询缓存，需要以下两步：</p><blockquote><ol><li>将query_cache_type设置为OFF。</li><li>将查询缓存的大小设置为0，这样才会真正不缓存数据。</li></ol></blockquote><p><font color="red"><strong>注意:</strong></font> 即便query_cache_size = 0，但 query_cache_type 非 0 的话，在实际环境中，可能会频繁发生报错：Waiting for query cache lock 。</p><h2 id="查询缓存状态"><a href="#查询缓存状态" class="headerlink" title="查询缓存状态"></a>查询缓存状态</h2><h3 id="1、与缓存相关的状态变量"><a href="#1、与缓存相关的状态变量" class="headerlink" title="1、与缓存相关的状态变量"></a>1、与缓存相关的状态变量</h3><p>不能也无需修改这些状态数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SHOW  GLOBAL STATUS  LIKE  &apos;Qcache%&apos;;</div><div class="line">+-------------------------+----------+</div><div class="line">| Variable_name            | Value   |</div><div class="line">+-------------------------+----------+</div><div class="line">| Qcache_free_blocks       | 1       | #查询缓存中的空闲块</div><div class="line">| Qcache_free_memory       | 16759656| #查询缓存中尚未使用的空闲内存空间</div><div class="line">| Qcache_hits              | 16      | #缓存命中次数</div><div class="line">| Qcache_inserts           | 71      | #向查询缓存中添加缓存记录的条数</div><div class="line">| Qcache_lowmem_prunes     | 0       | #表示因缓存满了而不得不清理部分缓存以存储新的缓存，这样操作的次数。若此数值过大，则表示缓存空间太小了。</div><div class="line">| Qcache_not_cached        | 57      | #没能被缓存的次数</div><div class="line">| Qcache_queries_in_cache  | 0       | #此时仍留在查询缓存的缓存个数</div><div class="line">| Qcache_total_blocks      | 1       | #共分配出去的块数</div><div class="line">+-------------------------+----------+</div></pre></td></tr></table></figure><h3 id="2、衡量缓存是否有效"><a href="#2、衡量缓存是否有效" class="headerlink" title="2、衡量缓存是否有效"></a>2、衡量缓存是否有效</h3><h4 id="缓存命中率的计算（次数）"><a href="#缓存命中率的计算（次数）" class="headerlink" title="缓存命中率的计算（次数）"></a>缓存命中率的计算（次数）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">mysql&gt; SHOW GLOBAL STATUS WHERE Variable_name=&apos;Qcache_hits&apos; OR Variable_name=&apos;Com_select&apos;;</div><div class="line">+---------------+-----------+</div><div class="line">| Variable_name | Value |</div><div class="line">+---------------+-----------+</div><div class="line">| Com_select    | 279292490 | #非缓存查询次数</div><div class="line">| Qcache_hits   | 307366973 | # 缓存命中次数</div><div class="line">+---------------+-----------</div></pre></td></tr></table></figure><blockquote><p>缓存命中率：Qcache_hits/(Qcache_hits+Com_select)</p></blockquote><h4 id="“命中和写入”的比率"><a href="#“命中和写入”的比率" class="headerlink" title="“命中和写入”的比率"></a>“命中和写入”的比率</h4><p>这是另外一种衡量缓存是否有效的指标。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SHOW GLOBAL STATUS WHERE Variable_name=&apos;Qcache_hits&apos; OR Variable_name=&apos;Qcache_inserts&apos;;</div><div class="line">+----------------+-----------+</div><div class="line">| Variable_name  | Value     |</div><div class="line">+----------------+-----------+</div><div class="line">| Qcache_hits | 307416113    | #缓存命中次数</div><div class="line">| Qcache_inserts | 108873957 | #向查询缓存中添加缓存记录的条数</div><div class="line">+----------------+-----------+</div></pre></td></tr></table></figure><blockquote><p>“命中和写入”的比率: Qcache_hits/Qcache_inserts # 如果此比值大于3:1, 说明缓存也是有效的；如果高于10:1，相当理想；</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开启查询缓存后，查询语句的解析过程：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在解析一个查询语句之前，如果查询缓存是打开的，那么MySQL会优先检查这个查询是否命中查询缓存中的数据。如果当前的查询恰好命中了查询缓存，那么在返回查询结果之前MySQL会检查一次用户权限。若权限没有问题，MySQL会跳过所有其他阶段（解析、优化、执行等），直接从缓存中拿到结果并返回给客户端。这种情况下，查询不会被解析，不用生成执行计划，不会被执行。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>加密、解密原理和openssl自建CA过程详解</title>
    <link href="http://yoursite.com/2017/The-principle-of-encryption-decryption-and-build-CA-with-openssl.html"/>
    <id>http://yoursite.com/2017/The-principle-of-encryption-decryption-and-build-CA-with-openssl.html</id>
    <published>2017-06-19T07:21:22.000Z</published>
    <updated>2017-06-19T10:50:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、加密和解密相关知识简介"><a href="#一、加密和解密相关知识简介" class="headerlink" title="一、加密和解密相关知识简介"></a>一、加密和解密相关知识简介</h1><h2 id="1、信息安全标准"><a href="#1、信息安全标准" class="headerlink" title="1、信息安全标准"></a>1、信息安全标准</h2><p>NIST（National Institute of Standards and Technology）美国国家标准与技术研究院，制定了网络信息安全与保密的三个要素：（这三大要素被简称为：CIA）</p><blockquote><ul><li>保密性(confidentiality)：信息不泄露给非授权用户、实体或过程，或供其利用的特性。（一般包括数据保密性、隐私性。）</li><li>完整性(Integrity)：数据未经授权不能进行改变的特性。即信息在存储或传输过程中保持不被修改、不被破坏和丢失的特性。（一般包括数据完整性、系统完整性。）</li><li>可用性(Availability)：可被授权实体访问并按需求使用的特性。即当需要时能否存取所需的信息。例如网络环境下拒绝服务、破坏网络和有关系统的正常运行等都属于对可用性的攻击；</li></ul></blockquote><p>尽管三要素能保证网络信息安全和保密，但从很多从事网络安全的研究人员的反馈发现，除了CIA外，还有另外两个标准也被经常提醒：</p><blockquote><ul><li>真实性：一个实体是真实的，是可被验证的。要确保数据发送方的确是它所声称的那个人。</li><li>可追溯性：一旦受到攻击，能追溯攻击发生的原处在什么地方。</li></ul></blockquote><a id="more"></a><h2 id="2、OSI组织定义的安全框架x-800"><a href="#2、OSI组织定义的安全框架x-800" class="headerlink" title="2、OSI组织定义的安全框架x.800"></a>2、OSI组织定义的安全框架x.800</h2><p>安全攻击：</p><ul><li>被动攻击：窃听、（常见报文捕获、监听流量）</li><li>主动攻击：伪装、重播、消息修改、拒绝服务</li></ul><p>安全机制：</p><ul><li>加密、数字签名、访问控制、数据完整性、认证交换、流量填充、路由控制、公证</li></ul><p>安全服务：</p><ul><li>认证 ：同等实体认证</li><li>访问控制</li><li>数据保密性：连接保密性、无连接保密性、选择域保密性、流量保密性    </li><li>数据完整性 ：不允许插入、删除、修改、重播</li><li>不可否认性</li></ul><h2 id="3、加密方式和算法"><a href="#3、加密方式和算法" class="headerlink" title="3、加密方式和算法"></a>3、加密方式和算法</h2><h3 id="1-、对称加密"><a href="#1-、对称加密" class="headerlink" title="(1)、对称加密"></a>(1)、对称加密</h3><p>对称加密：采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密。<br>  对称加密的算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">DES : 数据加密标准（56位密钥）</div><div class="line">3DES</div><div class="line">AES ：高级加密标准（128，192，256，384，512）</div><div class="line">Blowfish</div><div class="line">Twofish</div><div class="line">IDEA</div><div class="line">RC6</div><div class="line">CAST5</div></pre></td></tr></table></figure><p>对称加密的特性：</p><ul><li>加密、解密使用同一口令；</li><li>将明文分隔成固定大小的块，逐个进行加密</li></ul><p>对称加密的缺陷：</p><ul><li>密钥过多；</li><li>密钥传输；<br>密钥交换、身份验正、数据完整性</li></ul><h3 id="2-、公钥加密"><a href="#2-、公钥加密" class="headerlink" title="(2)、公钥加密"></a>(2)、公钥加密</h3><p>公钥加密：由对应的一对唯一性密钥（即公开密钥和私有密钥）组成的加密方法。</p><blockquote><p>密钥：public key, secret key  （p/s）<br>公钥是从私钥中提取出来的。<br>公钥加密，只能私钥解密。私钥加密，也只能公钥解密。</p></blockquote><p>常用加密算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RSA</div><div class="line">DSA:只能用于身份验证</div><div class="line">EIGamal</div></pre></td></tr></table></figure><h3 id="3-、单向加密"><a href="#3-、单向加密" class="headerlink" title="(3)、单向加密"></a>(3)、单向加密</h3><p>单向加密：不可逆的加密<br>单向加密特性：</p><ul><li>定长输出: 无论原始数据是多大，结果大小都相同的</li><li>雪崩效应: 输入的微小改变，将会引起结果的巨大改变</li></ul><p>单向加密算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MD5（128位）、SHA1、SHA256、SHA384、SHA512</div></pre></td></tr></table></figure><h1 id="二、加密和解密的过程和原理"><a href="#二、加密和解密的过程和原理" class="headerlink" title="二、加密和解密的过程和原理"></a>二、加密和解密的过程和原理</h1><p>首先问一个问题：</p><blockquote><p>假设B与A通信，B向A发送报文，怎么才能保证B的报文安全、可靠地被A接收到，并且保证报文数据的完整性？</p></blockquote><p>接下来围绕着这个问题来说明一下。</p><h2 id="加密和解密的过程和原理图"><a href="#加密和解密的过程和原理图" class="headerlink" title="加密和解密的过程和原理图"></a>加密和解密的过程和原理图</h2><p><img src="http://orku2pa7o.bkt.clouddn.com/17-6-19/8409695.jpg" alt=""></p><h2 id="加密解密过程和原理详细说明："><a href="#加密解密过程和原理详细说明：" class="headerlink" title="加密解密过程和原理详细说明："></a>加密解密过程和原理详细说明：</h2><h3 id="1、发送端B"><a href="#1、发送端B" class="headerlink" title="1、发送端B"></a>1、发送端B</h3><ul><li><p>为保证安全，要对报文加密。加密方法有三类：对称加密、公钥加密和单向加密。对称加密不安全，单向加密是不可逆的，因而使用公钥加密。</p><blockquote><p>问题：公钥加密安全（一般为2048位），但是加密过程太慢了，不适用当前网络需求，该怎么办？</p></blockquote></li><li><p>为了解决上述问题，B可以用单向加密提取出报文的特征码（特征码能保证报文的数据完整性），再使用自身的私钥对特征码进行公钥加密（特征码数据小，对其进行公钥加密速度快），并把加密后的特征码附加到报文后。（使用私钥加密是为了验证身份）</p><blockquote><p>问题：这种方式能实现数据完整性和身份验证的检验，但是却缺失了报文的数据保密性，又该怎么办？</p></blockquote></li><li><p>为了解决上述问题，B在把加密的特征码附加到报文后，把特征码和报文当做一个数据（假设为data），使用对称加密算法对该数据(data)加密得出一个密码，再把密码附加到该数据(data)后。为了使得在传输过程中密码不被其他人获取或篡改，使用A的公钥对密码进行加密（只有A的私钥能对其解密），把加密的密码附加到数据data后，再这些数据一并发送给A。</p></li></ul><h3 id="2、接收端A"><a href="#2、接收端A" class="headerlink" title="2、接收端A"></a>2、接收端A</h3><ul><li>A接收到B传来的报文，利用自身的私钥对其解密，获得密码。因为只有A的私钥能对B传来的报文（使用A的公钥加密密码）解密，所以能防止其他人对该传输的报文进行解密而获得其中的信息，保证了数据的保密性。</li><li>A利用获得的密码解密其中对称加密的数据，获得经过加密的特征码和原报文。</li><li>A使用B的公钥对该特征码解密，能解密则说明该报文是B发送过来的，实现了身份验证。（假设解密后的特征码是fcode）</li><li>A使用同等单向加密算法对接收到的原报文提取其特征码。使用该特征码和解密后获得的特征码(fcode)做比较，如果一样，则说明原报文的数据完整。</li></ul><blockquote><p>问题：以上这种方式能保证数据完整性、身份验证和数据的保密性，在加密和解密的过程中都要用到对方的公钥，如何在传输过程中安全可靠地获得对方的公钥就成了关键的一环，那该如何做呢？<br>答：安全可靠地获取对方的公钥靠CA(Certificate Authority )证书授权中心来实现。</p></blockquote><p>因而接下来，我们来说说CA。</p><h1 id="三、CA（证书授权中心）"><a href="#三、CA（证书授权中心）" class="headerlink" title="三、CA（证书授权中心）"></a>三、CA（证书授权中心）</h1><h2 id="1、CA证书标准：x-509"><a href="#1、CA证书标准：x-509" class="headerlink" title="1、CA证书标准：x.509"></a>1、CA证书标准：x.509</h2><p>x.509: 定义了证书结构和认证协议标准；（基于公钥和数字签名）<br>用于：IP安全、TLS/SSL（传输层安全）和S/MIME（安全电子邮件通信）<br><img src="http://orku2pa7o.bkt.clouddn.com/17-6-19/50161478.jpg" alt=""></p><p>x.509证书标准详细说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">（1）版本号（默认为1，如果有多个扩展，可能为3）</div><div class="line">（2）证书序列号（是一个整数，在CA中唯一标识，表明发行了多少个证书）</div><div class="line">（3）算法参数 （标志用了那种算法）</div><div class="line">（4）发行者的名称（CA自己的名字）</div><div class="line">（5）有效期限</div><div class="line">（6）主体名称（证书拥有者名称）(很关键！！！)（个人用户使用的是个人用户名，主机使用的必须是主机名而不是ip地址）</div><div class="line">（7）公钥（最重要）（公钥由证书拥有者提供）</div><div class="line">（8）发行者的ID（CA的唯一编号）</div><div class="line">（9）主体的ID（CA生成的证书拥有者唯一编号）</div><div class="line">（10）扩展</div><div class="line">（11）CA的签名（用于验证CA的来源合法性）</div></pre></td></tr></table></figure><p>CA是相对于发送方B和接收方A的第三方，是具有公信力的机构。</p><h2 id="2、验证数字证书的过程"><a href="#2、验证数字证书的过程" class="headerlink" title="2、验证数字证书的过程"></a>2、验证数字证书的过程</h2><p>B在发送之前获得A的数字证书或A在接收之前获得B的数字证书，都会去验证该数字证书的真伪。<br>以B在发送之前获得A的数字证书为例，说明验证数字证书的过程：</p><blockquote><ol><li>要用对应给A发数字证书的那个CA的公钥去解密CA的签名，如果能解密，则说明A的数字证书确实是那个信任的CA所颁发的证书。</li><li>解密出一段特征码，B再使用同样的单向加密算法提取A的数字证书的特征码，比较这两个特征码是否一样，如果一样，则表示获得的A的数字证书是完整的。</li><li>此后，还要去验证该数字证书中的持有者是不是A，如果验证通过，才可以确定该数字证书确实是A的数字证书。</li><li>确认该数字证书的拥有者是A后，还要去查看该数字证书是否在有效期限内和是否在CA的数字证书吊销列表中。</li></ol></blockquote><h1 id="四、SSL层"><a href="#四、SSL层" class="headerlink" title="四、SSL层"></a>四、SSL层</h1><h2 id="1、SSL层"><a href="#1、SSL层" class="headerlink" title="1、SSL层"></a>1、SSL层</h2><p>SSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。<br><strong>版本：sslv1, sslv2, sslv3</strong></p><blockquote><p>ssl是介于应用层和传输层之间的半层，一般被制作成公共共享库，要想使用ssl就要调用ssl共享库。</p></blockquote><p><img src="http://orku2pa7o.bkt.clouddn.com/17-6-19/92102078.jpg" alt=""></p><h2 id="2、https通信过程"><a href="#2、https通信过程" class="headerlink" title="2、https通信过程"></a>2、https通信过程</h2><p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL。</p><p>以https为例，进一步说明如何依靠CA来可靠的获得通信对方的公钥<br><img src="http://orku2pa7o.bkt.clouddn.com/17-6-19/38392141.jpg" alt=""></p><p>https的主要实现过程说明：</p><blockquote><p>（1）在通信之前，服务器端通过加密算法生成一对密钥，并把其公钥发给CA申请数字证书<br>（2）CA审核后，结合服务端发来的相关信息生成数字证书，并把该数字证书发回给服务器端。<br>（3）客户端和服务器端经tcp三次握手，建立初步连接。<br>（4）客户端发送http报文请求并协商使用哪种加密算法。<br>（5）服务端响应报文并把自身的数字签名发给服务端。<br>（6）客服端下载CA的公钥，验证其数字证书的拥有者是否是服务器端（这个过程可以得到服务器端的公钥）。（一般是客户端验证服务端的身份，服务端不用验证客户端的身份。）<br>（7）如果验证通过，客户端生成一个随机对称密钥，用该密钥加密要发送的URL链接申请，再用服务器端的公钥加密该密钥<br>（8）客户端把加密的密钥和加密的URL链接一起发送到服务器。<br>（9）服务器端使用自身的私钥解密，获得一个对称密钥，再用该对称密钥解密经加密的URL链接，获得URL链接申请。<br>（10）服务器端根据获得的URL链接取得该链接的网页内容，并用客户端发来的对称密钥把该网页内容加密后发给客户端。<br>（11）客户端收到加密的网页内容，用自身的对称密钥解密，就能获得网页的内容了。<br>（12）TCP四次挥手，通信结束。</p></blockquote><h1 id="五、openssl自建CA过程详解"><a href="#五、openssl自建CA过程详解" class="headerlink" title="五、openssl自建CA过程详解"></a>五、openssl自建CA过程详解</h1><p>OpenSSL是套开放源代码的软件库包，实现了SSL与TLS协议。其主要库是以C语言所写成，实现了基本的加密功能。<br>OpenSSL可以运行在绝大多数类Unix操作系统上（包括Solaris，Linux，Mac OS X与各种版本的开放源代码BSD操作系统），OpenVMS与Microsoft Windows。它也提供了一个移植版本，可以在IBM i（OS/400）上运作。<br>此软件是以Eric Young以及Tim Hudson两人所写的SSLeay为基础所发展的，SSLeay随着两人前往RSA公司任职而停止开发。<br>虽然此软件是开放源代码的，但其授权书条款与GPL有冲突之处，故GPL软件使用OpenSSL时（如Wget）必须对OpenSSL给予例外。</p><h2 id="openssl建立私有CA"><a href="#openssl建立私有CA" class="headerlink" title="openssl建立私有CA"></a>openssl建立私有CA</h2><p>openssl创建私有CA的过程：</p><p>前提：安装openssl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># yum install openssl</div></pre></td></tr></table></figure><h3 id="1、建立CA服务器"><a href="#1、建立CA服务器" class="headerlink" title="1、建立CA服务器"></a>1、建立CA服务器</h3><h4 id="（1）生成密钥"><a href="#（1）生成密钥" class="headerlink" title="（1）生成密钥"></a>（1）生成密钥</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># (umask 077; openssl genrsa -out /etc/pki/CA/private/cakey.pem 2048)</div></pre></td></tr></table></figure><p><strong>命令解释：</strong></p><ul><li>( ) 表示将会在当前shell中新建一个子shell，将（）中的命令放到该子shell中执行，执行完毕后关闭子shell并回到当前shell。<br>由于要对生成的cakey.pem文件设置合适权限，可使用umask修改文件的默认权限设置。为了不影响当前shell的默认权限设置，使用（）将这些命令放到子shell中执行就行了！</li><li>genrsa  : 指定使用rsa算法生成私钥</li><li>-out ：指定生成的私钥的存放位置<strong>（注意：该存放位置是在配置文件中默认定义了的，路径和文件名不能随意修改！！！）</strong></li><li>2048 ：指定生成一个2048位的私钥</li></ul><h4 id="（2）自签证书"><a href="#（2）自签证书" class="headerlink" title="（2）自签证书"></a>（2）自签证书</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># openssl req -new -x509 -key /etc/pki/CA/private/cakey.pem -out /etc/pki/CA/cacert.pem -days 3655</div></pre></td></tr></table></figure><p><img src="http://orku2pa7o.bkt.clouddn.com/17-6-19/86778904.jpg" alt=""></p><p><strong>命令解释：</strong></p><ul><li>req: 生成证书签署请求</li><li>-news: 新请求</li><li>-x509: 专门用于生成自签署证书</li><li>-key /path/to/keyfile: 指定私钥文件（req命令能根据私钥自动抽取出公钥）</li><li>-out /path/to/somefile: <strong>（注意：路径和文件名不用随意修改！）</strong></li><li>-days n: 有效天数（一般和-x509一起使用才有意义。）</li></ul><h4 id="（3）初始化工作环境"><a href="#（3）初始化工作环境" class="headerlink" title="（3）初始化工作环境"></a>（3）初始化工作环境</h4><p><strong>只有第一次创建CA时，才需要初始化工作环境</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># touch /etc/pki/CA/&#123;index.txt,serial&#125;</div><div class="line"># echo 01 &gt; /etc/pki/CA/serial   （指定序列号从那个数字开始）</div></pre></td></tr></table></figure><h3 id="2、节点申请证书"><a href="#2、节点申请证书" class="headerlink" title="2、节点申请证书"></a>2、节点申请证书</h3><h4 id="1-节点生成请求"><a href="#1-节点生成请求" class="headerlink" title="(1) 节点生成请求"></a>(1) 节点生成请求</h4><ul><li>生成密钥对儿</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># (umask 077; openssl genrsa -out /etc/httpd/ssl/httpd.key 2048)</div></pre></td></tr></table></figure><ul><li>生成证书签署请求</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># openssl req -new -key /etc/httpd/ssl/httpd.key -out /etc/httpd/ssl/httpd.csr</div></pre></td></tr></table></figure><blockquote><p>.csr ：证书签署请求，一般都是这样的后缀</p></blockquote><p><img src="http://orku2pa7o.bkt.clouddn.com/17-6-19/27547946.jpg" alt=""><br><strong>红框中的信息，需要和CA自签证书中填写的保持一致，否则会出错。</strong></p><ul><li>把签署请求文件发送给CA服务器</li></ul><h4 id="2-CA签署证书"><a href="#2-CA签署证书" class="headerlink" title="(2) CA签署证书"></a>(2) CA签署证书</h4><ul><li>验正证书中的信息</li><li>签署证书</li></ul><blockquote><p>格式：openssl ca -in /path/to/somefile.csr -out /path/to/somefile.crt -days N<br>说明：-in 指定证书签署请求文件 ； -out CA根据请求文件生成的证书，一般为 .crt 后缀；N 指定证书生效时长，天为单位</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">[root@localhost CA]# openssl ca -in /etc/httpd/ssl/httpd.csr -out /etc/httpd/ssl/httpd.crt -days 1000     </div><div class="line">Using configuration from /etc/pki/tls/openssl.cnf      </div><div class="line">Check that the request matches the signature      </div><div class="line">Signature ok      </div><div class="line">Certificate Details:      </div><div class="line">        Serial Number: 1 (0x1)      </div><div class="line">        Validity      </div><div class="line">            Not Before: Jul  3 14:07:23 2014 GMT      </div><div class="line">            Not After : Mar 29 14:07:23 2017 GMT      </div><div class="line">        Subject:      </div><div class="line">            countryName               = CN      #国家名</div><div class="line">            stateOrProvinceName       = GuangDong   #省份名   </div><div class="line">            organizationName          = 51CTOblog   #公司名</div><div class="line">            organizationalUnitName    = Ops         #部门名</div><div class="line">            commonName                = www.hjqjk.com   #主机名   </div><div class="line">            emailAddress              = hjqjk@163.com   #邮箱   </div><div class="line">        X509v3 extensions:      </div><div class="line">            X509v3 Basic Constraints:       </div><div class="line">                CA:FALSE      </div><div class="line">            Netscape Comment:       </div><div class="line">                OpenSSL Generated Certificate      </div><div class="line">            X509v3 Subject Key Identifier:       </div><div class="line">                F9:DB:00:04:8A:D7:17:C8:21:B7:2D:15:F2:E9:89:66:BB:6D:D5:F9      </div><div class="line">            X509v3 Authority Key Identifier:       </div><div class="line">                keyid:98:56:B3:30:B0:9D:75:A1:69:AD:BF:2F:E4:0D:FE:3F:17:87:B0:A8</div><div class="line">Certificate is to be certified until Mar 29 14:07:23 2017 GMT (1000 days)     </div><div class="line">Sign the certificate? [y/n]:y  #询问是否签署证书</div><div class="line">1 out of 1 certificate requests certified, commit? [y/n]y     </div><div class="line">Write out database with 1 new entries      </div><div class="line">Data Base Updated      </div><div class="line">[root@localhost CA]# ls /etc/httpd/ssl      #证书已签署，自建CA到这里就成功了</div><div class="line">httpd.crt  httpd.csr  httpd.key</div></pre></td></tr></table></figure><ul><li>发送给请求者</li></ul><p>之后，只要把签署的证书发回给申请者就行了！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、加密和解密相关知识简介&quot;&gt;&lt;a href=&quot;#一、加密和解密相关知识简介&quot; class=&quot;headerlink&quot; title=&quot;一、加密和解密相关知识简介&quot;&gt;&lt;/a&gt;一、加密和解密相关知识简介&lt;/h1&gt;&lt;h2 id=&quot;1、信息安全标准&quot;&gt;&lt;a href=&quot;#1、信息安全标准&quot; class=&quot;headerlink&quot; title=&quot;1、信息安全标准&quot;&gt;&lt;/a&gt;1、信息安全标准&lt;/h2&gt;&lt;p&gt;NIST（National Institute of Standards and Technology）美国国家标准与技术研究院，制定了网络信息安全与保密的三个要素：（这三大要素被简称为：CIA）&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;保密性(confidentiality)：信息不泄露给非授权用户、实体或过程，或供其利用的特性。（一般包括数据保密性、隐私性。）&lt;/li&gt;
&lt;li&gt;完整性(Integrity)：数据未经授权不能进行改变的特性。即信息在存储或传输过程中保持不被修改、不被破坏和丢失的特性。（一般包括数据完整性、系统完整性。）&lt;/li&gt;
&lt;li&gt;可用性(Availability)：可被授权实体访问并按需求使用的特性。即当需要时能否存取所需的信息。例如网络环境下拒绝服务、破坏网络和有关系统的正常运行等都属于对可用性的攻击；&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;尽管三要素能保证网络信息安全和保密，但从很多从事网络安全的研究人员的反馈发现，除了CIA外，还有另外两个标准也被经常提醒：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;真实性：一个实体是真实的，是可被验证的。要确保数据发送方的确是它所声称的那个人。&lt;/li&gt;
&lt;li&gt;可追溯性：一旦受到攻击，能追溯攻击发生的原处在什么地方。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="安全" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
</feed>
